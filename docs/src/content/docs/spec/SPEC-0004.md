---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 4
status: draft
title: Enum Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0004: Enum Compilation

## Overview

This SPEC documents the compiler's deterministic behavior for parsing, validating, and registering enum types. It specifies the value type inference algorithm (fork parsing to determine integer vs. string), discriminant assignment rules, variant name uniqueness validation, and registration into the type registry. This SPEC is normative for implementers who must reproduce the compiler's enum handling.

![Enum Value Type Determination](../../../../diagrams/enum_value_determination.png)

## Motivation

Code generators and downstream tooling rely on consistent enum discriminant values and type classifications. This SPEC records the precise parsing and validation algorithms so implementations produce identical outputs for the same source schemas. The fork-based type inference ensures the parser can distinguish integer and string enums without backtracking or lookahead limitations.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

### Parse-time value type inference

The parser uses fork-based lookahead to determine the enum's value type before committing to a parse:

- Fork the token stream after parsing the `enum` keyword, name, and opening brace
- Attempt to parse the first variant as an integer-valued variant (`EnumVariant<Token![number]>`)
- If successful, parse the full enum as `TypedEnum<Token![number]>` (integer enum)
- If unsuccessful, parse the full enum as `TypedEnum<Token![string]>` (string enum)

> [!IMPORTANT]
> This fork-based approach avoids backtracking and ensures the parser commits to the correct variant type immediately.

### Discriminant assignment (integer enums)

For integer enums, the compiler assigns discriminants as follows:

- The first variant with no explicit value receives discriminant `0`
- Each subsequent variant with no explicit value receives the previous variant's discriminant + 1
- Variants with explicit values use their specified discriminant

**Example:**

```kintsu
enum Status {
    Pending,      // 0
    Active = 5,   // 5
    Inactive      // 6
}
```

### Explicit value requirement (string enums)

For string enums, all variants must have explicit string values. The compiler does not auto-assign string discriminants.

> [!WARNING]
> Parsing a string enum with a unit variant (no explicit value) results in a parse error.

### Variant name uniqueness validation

During parsing, the compiler tracks variant names and rejects duplicate names within the same enum.

Duplicate variant names produce a diagnostic error referencing the first and duplicate occurrences.

### Explicit value uniqueness

The compiler does not reject enums with duplicate explicit values (some use cases intentionally define aliased variants).

> [!NOTE]
> Code generators may emit warnings or errors if the target language does not support duplicate discriminants.

### Registration into type registry

After parsing, enum definitions are registered into the type registry as first-class types.

- Enums are added to the namespace's children map with the enum name as the key
- The compiler validates that enum names are unique within the namespace (no duplicate type names)

## Acceptance criteria

- [ ] The compiler must use fork-based parsing to infer enum value type (integer vs. string) before committing to a parse.
- [ ] Integer enums must assign sequential discriminants starting from 0 for unit variants, with explicit values taking precedence.
- [ ] String enums must require explicit values for all variants (no auto-assignment).
- [ ] The compiler must reject enums with duplicate variant names within the same enum.
- [ ] The compiler must register enums into the type registry and validate name uniqueness within the namespace.
- [ ] Enums must be referenceable by name in struct fields, operation signatures, and type aliases.

## Design Principles

- Determinism: the parsing algorithm is reproducible; fork-based type inference eliminates ambiguity.
- Explicit semantics: string enums require explicit values to avoid confusion about auto-assignment rules.
- Validation: the compiler enforces variant name uniqueness to prevent schema errors.

## Implications

- Schema authors must provide explicit values for all variants in string enums.
- Code generators must handle both integer and string enums, translating discriminants to target-language representations.
- Wire-format serializers must preserve discriminant values exactly as specified in the schema.

## References

- [RFC-0004: Enum Type Design](../rfc/RFC-0004.md)
- [TSY-0004: Enum Types](../tsy/TSY-0004.md)
