---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 6
status: draft
title: Type Alias Design
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0006: Type Alias Design

## Abstract

This RFC documents the design rationale for type aliases in Kintsu. Type aliases provide semantic names for type expressions, improving code readability and maintainability. The design supports recursive resolution chains, circular dependency detection, and special handling for union and anonymous struct aliases that generate concrete struct definitions.

## Motivation

Complex type expressions can reduce code clarity. A field typed as `(oneof i32 | str | bool)[]` conveys structural information but lacks semantic meaning. Type aliases address this by providing meaningful names:

```kintsu
type Value = oneof i32 | str | bool;
type Values = Value[];

struct Config {
    settings: Values
};
```

The alias `Values` communicates intent more clearly than the raw type expression. This improves maintainability and enables consistent reuse of complex types.

### Why Type Aliases?

**Semantic naming:** Aliases attach domain meaning to structural types. `UserId` is clearer than `i64`.

**Code reuse:** Complex type expressions (unions, oneofs, arrays) can be defined once and referenced multiple times.

**Simplified refactoring:** Changing `type UserId = i64;` to `type UserId = str;` updates all references automatically.

**Anonymous struct extraction:** Aliases for anonymous structs provide a 1:1 name mapping, avoiding the context-based naming used for inline anonymous structs.

## Specification

### Syntax

Type aliases use the `type` keyword followed by a name, an equals sign, and a type expression:

```kintsu
type Name = Type;
```

**Examples:**

```kintsu
type Id = i64;
type Timestamp = datetime;
type MaybeError = i64!;              // result type
type Pair = oneof i32 | str;
type Combined = User & Permissions;  // union
type Items = (oneof i32 | f32)[];    // array of oneof
```

### Resolution Chains

Aliases can reference other aliases. The compiler follows the resolution chain until it reaches a concrete type:

```kintsu
type A = i64;
type B = A;
type C = B;
```

**Resolution:** `C → B → A → i64`. The final resolved type for `C` is `i64`.

> [!IMPORTANT]
> Resolution is transitive and deterministic. All references to an alias resolve to the same concrete type.

### Circular Dependency Prevention

Circular alias chains are invalid and detected during compilation:

```kintsu
// INVALID: circular alias
type A = B;
type B = A;  // ERROR: circular type alias detected
```

The compiler uses depth-first search (DFS) to detect cycles and reports the cycle path for debugging.

### Union and Anonymous Struct Aliases

Aliases for unions and anonymous structs generate concrete struct definitions:

**Union alias:**

```kintsu
type UserData = User & Permissions & Metadata;
```

After union resolution, a struct named `UserData` is generated with merged fields from the union operands.

**Anonymous struct alias:**

```kintsu
type Point = {
    x: i32,
    y: i32
};
```

After extraction, a struct named `Point` is generated with the inline fields. This provides a clean 1:1 mapping between alias name and struct name.

> [!NOTE]
> This special handling simplifies generated code by avoiding complex context-based naming rules.

## Rationale

### Why Allow Alias Chains?

Alias chains enable layered semantic abstractions:

```kintsu
type RawId = i64;
type UserId = RawId;
type AdminId = UserId;
```

Each layer adds semantic meaning while preserving the underlying type. This is common in domain modeling where IDs have hierarchical relationships.

### Why Detect Cycles?

Circular aliases create infinite resolution loops. Early detection prevents downstream compilation errors and provides actionable error messages with the full cycle path.

### Why Special Handling for Unions and Anonymous Structs?

Union and anonymous struct aliases represent a common pattern: defining an inline composite type with a meaningful name. Generating a named struct from the alias simplifies code generation and eliminates ambiguity about the struct's identity.

**Without special handling:**

```kintsu
type Config = { host: str, port: i32 };
```

Would generate a context-dependent name like `NamespaceConfigAnonymous0`, losing the semantic clarity of `Config`.

**With special handling:**

The generated struct is simply named `Config`, matching the alias name directly.

## Acceptance Criteria

- [ ] **AC-1:** Type aliases support all type expressions: builtins, named types, arrays, oneofs, unions, parenthesized types, result types, and anonymous structs
- [ ] **AC-2:** Alias resolution chains are followed transitively until a concrete type is reached
- [ ] **AC-3:** Circular alias chains are detected and reported with the full cycle path
- [ ] **AC-4:** Union and anonymous struct aliases generate struct definitions using the alias name

## Backwards Compatibility

Type aliases are a foundational feature present in Kintsu v0.1.0. No breaking changes are introduced by this specification.

Future changes to alias resolution behavior (e.g., supporting conditional aliasing or generic aliases) would require separate RFCs and coordination with code generators.

## References

- [TSY-0006](../tsy/TSY-0006.md) - Type alias type-system rules
- [SPEC-0006](../spec/SPEC-0006.md) - Type alias compilation implementation
- [TSY-0002](../tsy/TSY-0002.md) - Struct types (for union/anonymous struct context)
- [TSY-0007](../tsy/TSY-0007.md) - Union types (for union alias behavior)
