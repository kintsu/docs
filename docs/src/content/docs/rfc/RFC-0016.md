---
author: joshua-auchincloss
components:
  - compiler
created: 2025-10-31
kind: RFC
number: 16
status: draft
title: Union Or (&|)
updates:
  - author: joshua-auchincloss
    date: 2025-10-31
    description: Created specification
    version_after: 0.1.0
    version_before: null
---

# RFC-0016: Union Or (`&|`)

## Abstract

This RFC defines the `&|` (Union Or) operator: a struct-level composition operator that merges fields from multiple struct operands while resolving conflicting field types into `oneof` alternatives. The operator is intended to provide a concise, semantically clear way to compose structs when some fields need variant typing rather than deep structural merging.

## Motivation

Authors often want to compose multiple struct types while preserving distinct type alternatives for conflicting fields. The `&|` operator merges non-conflicting fields directly and produces `oneof` for conflicting field types. This avoids manual wrapper types and keeps intent explicit: composition plus conflict-as-alternatives.

## Specification

### Syntax

Use `&|` between struct type expressions to compose them with conflict-as-`oneof` semantics.

```kintsu
// Two simple structs
struct A { foo: i32, bar: str };
struct B { foo: str, baz: bool };

// Compose with Union Or
type C = A &| B;
```

### Semantics

- Only `struct` operands are allowed. If any operand is not a struct (enum, error, primitive, alias resolving to non-struct), the compiler emits an error (same behavior as RFC-0007 for invalid union operands).
- Fields present in only a subset of the operands are carried through unchanged.
- For a field name that appears in multiple operands with differing types, the resulting field type is a `oneof` whose alternatives are the distinct operand types in left-to-right operand order. Duplicate types are deduplicated.
- Conflicting types are treated as whole alternatives. No further merging of the conflicting types is performed.

### Evaluation order and associativity

- `&|` is left-associative. Expressions are evaluated left-to-right. Parentheses are honored and inner parenthesized expressions are evaluated first.

Examples:

- `A &| B &| C` is parsed as `(A &| B) &| C` and the conflict for field `f` will become `oneof` of distinct types from A then B then C in that order.
- `A & (B &| C)` evaluates `B &| C` first, then merges result with `A`.

### Name generation

- When an `&|` expression is used in a type alias (`type Name = ...`), the alias name is used for the generated struct (if an anonymous wrapper would otherwise be needed). This follows the same anonymous-type naming rules as RFC-0007.
- When `&|` appears in a struct field, the compiler generates an anonymous wrapper name using parent struct + field naming rules (same convention as anonymous unions/structs today).

### Conflict `oneof` details

- The `oneof` representing a conflicting field uses the syntax `oneof T1 | T2 | ...` where `T1`, `T2` are the distinct types from operands in left-to-right order.
- If an operand's conflicting type is a named struct, that struct type is used directly as one alternative.

### Compound and nested types

- For now, compound differences (e.g., `list<i32>` vs `list<str>`, `option<i32>` vs `i32`) are treated as distinct types and placed into `oneof` as-is. No structural normalization is applied in this first iteration.

## Rationale

This design gives authors a compact mechanism for composing structs while preserving type alternatives where fields disagree. It avoids deep, potentially surprising automatic merges across structurally different types and explicitly surfaces variance as `oneof`, which downstream codegen and consumers already handle.

Key reasons:

- Predictability: left-to-right merging is deterministic and intuitive.
- Explicitness: conflicting types become `oneof` variants so code generators can choose appropriate representations.
- Low implementation complexity: normalization reduces to producing merged field lists and `oneof` nodes for conflicts; existing `oneof` validation/codegen is reused.

## Examples

1. Simple conflict

```kintsu
struct A { foo: i32 };
struct B { foo: str };

type C = A &| B;

// Normalized:
struct C { foo: oneof i32 | str };
```

2. Multi-field and dedupe

```kintsu
struct A { foo: i32, x: bool };
struct B { foo: i32, y: str };
struct D { foo: str };

type E = A &| B &| D;

// Normalized (foo deduped i32 then str):
struct E { foo: oneof i32 | str, x: bool, y: str }
```

3. Field present only on one operand

```kintsu
struct A { a: i32 };
struct B { b: str };

type X = A &| B; // as with union, result has both a and b unchanged
```

## Acceptance Criteria

- [ ] **AC-1:** `&|` parses in type aliases and struct fields and supports parenthesized grouping.
- [ ] **AC-2:** Only struct operands are allowed; non-struct operands produce a clear diagnostic.
- [ ] **AC-3:** Non-conflicting fields are carried through unchanged.
- [ ] **AC-4:** Conflicting fields become `oneof` with distinct alternatives in left-to-right order.
- [ ] **AC-5:** Name generation uses alias or parent+field rules consistent with RFC-0007.
- [ ] **AC-6:** Existing `oneof` codegen/validation paths are reused for generated `oneof` nodes.

## Backwards Compatibility

`&|` is additive; it introduces new syntax and semantics but does not change existing behavior. Existing code remains valid. Any future changes to codegen defaults or representation will be opt-in and documented with migration guidance.

## References

- [RFC-0007](./RFC-0007.md) - Union Type Support (field-merging `&` semantics)
- [SPEC-000y](../spec/SPEC-000y.md) - `oneof` compilation and codegen
  EOF
