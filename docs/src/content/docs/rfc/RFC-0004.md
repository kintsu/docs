---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 4
status: draft
title: Enum Type Design
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0004: Enum Type Design

## Abstract

This RFC proposes enum types for Kintsu, providing a named set of discriminated variants. Enums support three styles: unit variants (names only), integer-valued variants (explicit or auto-incremented discriminants), and string-valued variants. The design ensures type safety through consistent value types within each enum and enables ergonomic modeling of categorical data like status codes, roles, and error classifications.

## Motivation

Schema languages need concise, type-safe representations for categorical data. Without enum types, schema authors must resort to:

- Unvalidated strings (e.g., `status: str` with documentation stating "valid values: active, inactive")
- Integer constants with external documentation (e.g., `http_status: i64 // 200=OK, 404=NotFound`)
- Struct-based sum types with boilerplate field definitions

Enums address these problems by:

- Providing explicit, named variants that code generators can translate to native enum types in target languages
- Supporting both integer and string discriminants for compatibility with existing APIs and databases
- Enabling compiler validation of variant names and value types
- Auto-generating sequential discriminants when explicit values are not needed

Use cases include: HTTP status codes, user roles, request states, error categories, and any domain-specific categorical classification.

## Specification

### Syntax

Enums are declared with the `enum` keyword, a name, and a brace-delimited list of comma-separated variants:

```kintsu
enum Priority {
    Low,
    Medium,
    High
};
```

Variants may have explicit integer or string values:

```kintsu
enum HttpStatus {
    Ok = 200,
    NotFound = 404,
    ServerError = 500
};

enum Role {
    Admin = "admin",
    User = "user",
    Guest = "guest"
};
```

### Variant styles

- **Unit variants**: name only (e.g., `Low`). The compiler assigns sequential integer values starting from 0.
- **Integer variants**: name with explicit `i64` value (e.g., `Ok = 200`).
- **String variants**: name with explicit string value (e.g., `Admin = "admin"`).

> [!IMPORTANT]
> All variants within an enum must use the same value type (all unit/integer, or all string). Mixing integer and string values is rejected at parse time.

### Discriminant assignment

- If no explicit values are provided, the compiler assigns sequential integers starting from 0.
- If the first variant has an explicit integer value, subsequent variants without explicit values continue the sequence (e.g., `A = 10, B, C` assigns B=11, C=12).

> [!NOTE]
> String enums require explicit values for all variants (no auto-assignment).

## Rationale

### Three variant styles

Supporting unit, integer, and string variants balances ergonomics with interoperability:

- Unit variants reduce boilerplate for simple categorical data (compiler auto-generates discriminants).
- Integer variants enable compatibility with numeric status codes, database enums, and legacy APIs.
- String variants support textual identifiers common in JSON APIs and configuration formats.

### Value type consistency

Requiring all variants to use the same value type (integer or string) ensures:

- Code generators can translate enums to native target-language types without runtime type checks.
- Wire-format serialization is unambiguous (no polymorphic discriminant handling needed).
- Schema authors explicitly document the enum's representation strategy.

The parser enforces this rule by forking the token stream and testing for integer vs. string values before committing to a parse.

### Sequential discriminant assignment

Auto-incrementing discriminants (0, 1, 2, ...) reduces boilerplate for enums where explicit values are not semantically meaningful (e.g., `Priority { Low, Medium, High }`). This follows precedent from C, Rust, TypeScript, and other languages with enum support.

For enums with explicit values, the compiler preserves the author's assignments without reordering or normalization, ensuring the schema accurately reflects domain constraints (e.g., HTTP status codes must match RFC specifications).

## Acceptance Criteria

- [ ] AC-1: The compiler must parse enum declarations with unit, integer-valued, and string-valued variants.
- [ ] AC-2: Unit variants (no explicit values) must receive auto-assigned integer discriminants starting from 0.
- [ ] AC-3: The compiler must reject enums with mixed integer and string values (all variants must use the same type).
- [ ] AC-4: Enums must be registered in the type registry and referenceable by structs, operations, and other types.

## Backwards Compatibility

This RFC introduces a new type construct. No backwards compatibility concerns (enum types are new).

## References

- [TSY-0004: Enum Types](../tsy/TSY-0004.md)
- [SPEC-0004: Enum Compilation](../spec/SPEC-0004.md)
