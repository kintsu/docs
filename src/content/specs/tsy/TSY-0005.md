---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 5
status: draft
title: Error Types
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Enhanced code blocks with expressive-code markers
version_after: 0.1.0
version_before: null
---

# TSY-0005: Error Types

## Overview

This document defines the normative type-system rules for error types in Kintsu. Errors declare named variants representing operation failure modes. Variants can be struct variants (inline anonymous structs), tuple variants (references to existing types), or unit variants (no payload). This TSY specifies the syntax, variant parsing rules, anonymous struct extraction for struct variants, type reference validation for tuple variants, and error-operation association semantics.

## Motivation

Error types provide structured, type-safe representations of failure cases for operations. This TSY documents the exact syntax and variant semantics so schema authors and code generators can rely on consistent error behavior. The anonymous struct extraction algorithm for struct variants is normative â€” implementations must generate the same struct names to ensure interoperability.

## Design Principles

- Explicit failure modes: each variant represents a distinct failure case with optional payload data
- Flexible payload types: struct variants (inline fields), tuple variants (type references), unit variants (no data)
- Deterministic extraction: struct variant payloads are extracted to named structs using ErrorName + VariantName
- Operation association: errors are bound to operations via `#[err(...)]` metadata, supporting namespace-level defaults and operation-level overrides

## Type system rules (normative)

The following diagram illustrates the structure of error types with their three variant forms and operation association mechanisms:

![Error Type Structure](../../../../diagrams/error_structure.png)

### Syntax and parsing

Error declarations use the `error` keyword followed by a name and a brace-delimited list of variants separated by commas.

**Variant syntax:**

- **Struct variant:** `VariantName { field1: Type, field2: Type, ... }`
- **Tuple variant:** `VariantName(Type)`
- **Unit variant:** `VariantName`

**Example:**

```kintsu
error ApiError {
    Validation {
        field: str,
        reason: str
    },
    NotFound(ResourceId),
    InternalError
};
```

### Struct variant extraction and naming

Struct variants with inline field lists are treated as anonymous structs during compilation.

The compiler extracts the inline struct and generates a name by concatenating the error name and variant name in PascalCase.

**Example:** Error `RequestError`, variant `InvalidInput` -> generated struct name `RequestErrorInvalidInput`.

> [!IMPORTANT]
> After extraction, the struct variant is transformed into a tuple variant referencing the generated struct. The generated struct is registered in the namespace like any explicitly declared struct.

**Example transformation:**

```kintsu
// Source
error NetworkError {
    Timeout {
        endpoint: str,
        duration_ms: i64
    }
};

// After extraction
struct NetworkErrorTimeout {
    endpoint: str,
    duration_ms: i64
};

error NetworkError {
    Timeout(NetworkErrorTimeout)
};
```

### Tuple variant type reference validation

Tuple variants specify a parenthesized type reference. The compiler validates that the referenced type exists in the type registry during resolution.

> [!WARNING]
> If the referenced type is not found, compilation fails with an error indicating the missing type and the error variant location.

**Example:**

```kintsu
error AppError {
    Database(DbError)  // DbError must exist in type registry
};
```

### Variant name uniqueness

Variant names must be unique within the error. Duplicate names are rejected with a compile error.

**Example (invalid):**

```kintsu del={1,5}
error Status {
    Pending,
    Active,
    Pending  // ERROR: duplicate variant 'Pending'
};
```

### Error-operation association

Errors are associated with operations using the `#[err(...)]` metadata attribute.

**Operation-level association:**

```kintsu
error ValidationError {
    InvalidField { name: str }
};

#[err(ValidationError)]
operation validate(data: str) -> bool!;
```

**Namespace-level default:**

```kintsu
#![err(DefaultError)]

namespace api;

error DefaultError {
    Unknown
};

// All operations inherit DefaultError
operation process(value: i32) -> str!;
```

> [!NOTE]
> Operations with result types (return type with `!` suffix) must have an associated error type. Operation-level `#[err(...)]` takes precedence over namespace-level `#![err(...)]`.

### Optional fields in struct variants

Fields in struct variants can be marked optional with `?` separator, following the same rules as struct fields.

**Example:**

```kintsu
error ApiError {
    RateLimit {
        retry_after?: i64,
        message: str
    }
};
```

## Implications

- Code generators must handle three variant forms: struct variants (generate target-language structs for payloads), tuple variants (reference existing types), unit variants (no payload).
- Extracted struct names (ErrorName + VariantName) must be surfaced in documentation and diagnostics.
- Error-operation associations must be validated at compile time; operations with result types cannot omit error associations.

## References

- [RFC-0005: Error Type Design](/specs/rfc/rfc-0005)
- [SPEC-0005: Error Compilation](/specs/spec/spec-0005)
- [TSY-0003: Anonymous Structs](/specs/tsy/tsy-0003)
