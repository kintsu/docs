---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 6
status: draft
title: Type Aliases
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0006: Type Aliases

## Overview

This document defines the normative type-system rules for type aliases in Kintsu. Type aliases provide named references to type expressions using the `type Name = Type;` syntax. This TSY specifies alias syntax, recursive resolution semantics, circular dependency constraints, target type validation, and special handling for union and anonymous struct aliases.

## Motivation

Type aliases enable semantic naming of complex type expressions and promote code reuse. This TSY documents the exact resolution behavior and validation rules so schema authors and code generators can rely on consistent alias semantics. The circular dependency detection algorithm and topological ordering requirements are normative — implementations must reject circular aliases and resolve dependencies in the correct order.

## Design Principles

- **Transitive resolution:** Alias chains are followed recursively until a concrete type is reached
- **Deterministic ordering:** Aliases are resolved in topological order based on dependencies
- **Cycle detection:** Circular alias chains are rejected with actionable error messages
- **Special struct handling:** Union and anonymous struct aliases generate concrete struct definitions with predictable names
- **Type validation:** All type references in alias targets must resolve to valid types

## Type system rules (normative)

The following diagram illustrates how type aliases are resolved through transitive chains:

![Type Alias Resolution Chain](../../../../diagrams/alias_resolution_chain.png)

### Syntax and parsing

Type alias declarations use the `type` keyword followed by an identifier (alias name), an equals sign, and a type expression:

```kintsu
type Name = Type;
```

**Type expressions include:**

- Builtins: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `str`, `bytes`, `datetime`
- Named types: references to structs, enums, errors, or other aliases
- Arrays: `Type[]` (unsized), `Type[N]` (sized)
- Oneofs: `oneof Type1 | Type2 | ...`
- Unions: `Type1 & Type2 & ...`
- Parenthesized types: `(Type)`
- Result types: `Type!`
- Anonymous structs: `{ field1: Type1, field2: Type2, ... }`

**Examples:**

```kintsu
type UserId = i64;
type Timestamp = datetime;
type Value = oneof i32 | str | bool;
type Config = User & Permissions;
type Items = (oneof i32 | f32)[];
type Point = { x: i32, y: i32 };
```

### Recursive resolution

Alias resolution is transitive. When an alias references another alias, the compiler follows the chain until it reaches a concrete (non-alias) type.

**Example:**

```kintsu
type A = i64;
type B = A;
type C = B;
```

**Resolution chain:** `C -> B -> A -> i64`. The final resolved type for `C` is `i64`.

> [!IMPORTANT]
> All references to an alias must resolve to the same concrete type. Resolution is deterministic and idempotent.

### Circular dependency detection

Circular alias chains are invalid. The compiler must detect cycles and reject them with an error.

**Example (invalid):**

```kintsu
type A = B;
type B = C;
type C = A;  // ERROR: circular type alias A -> B -> C -> A
```

> [!WARNING]
> The compiler must report the full cycle path (e.g., `A -> B -> C -> A`) to aid debugging.

**Multi-alias cycles are also invalid:**

```kintsu
type X = Y;
type Y = X;  // ERROR: circular type alias X -> Y -> X
```

### Target type validation

The target type of an alias must resolve to a valid type. All type references (named types, union operands, oneof variants, array elements, etc.) must exist in the type registry.

**Example (invalid):**

```kintsu
type Invalid = UnknownType;  // ERROR: type 'UnknownType' not found
```

> [!NOTE]
> Validation occurs after all type definitions are parsed but before alias resolution completes.

### Union alias struct generation

When a union is used as the target of an alias, the union is resolved into a struct definition. The generated struct uses the alias name directly.

**Example:**

```kintsu
type UserData = User & Permissions & Metadata;
```

**After union resolution:**

```kintsu
struct UserData {
    // Merged fields from User, Permissions, and Metadata
};
```

> [!IMPORTANT]
> The alias name becomes the struct name. The alias itself is replaced by a reference to the generated struct.

### Anonymous struct alias extraction

When an anonymous struct is used as the target of an alias, the struct is extracted and named using the alias name.

**Example:**

```kintsu
type Point = {
    x: i32,
    y: i32
};
```

**After extraction:**

```kintsu
struct Point {
    x: i32,
    y: i32
};
```

> [!NOTE]
> This provides a 1:1 mapping between the alias name and the generated struct name, avoiding context-based naming rules.

### Alias name uniqueness

Alias names must be unique within their namespace. Duplicate alias names are rejected with a compile error.

**Example (invalid):**

```kintsu
type UserId = i64;
type UserId = str;  // ERROR: duplicate type alias 'UserId'
```

### Dependency ordering

Aliases must be resolved in dependency order. If alias `A` references alias `B`, then `B` must be resolved before `A`.

> [!IMPORTANT]
> The compiler uses topological sorting to determine the correct resolution order. This ensures all dependencies are resolved before an alias is processed.

## Implications

**For schema authors:**

- Aliases provide semantic naming without introducing runtime overhead
- Union and anonymous struct aliases generate predictable struct definitions
- Circular aliases are caught early with clear error messages

**For code generators:**

- Alias resolution is deterministic — the same schema produces the same resolved types
- Union and anonymous struct aliases map 1:1 to struct definitions
- Topological ordering ensures dependencies are available when needed

**For tooling:**

- Alias chains can be followed to display concrete types in documentation
- Cycle detection provides actionable error messages with full cycle paths

## References

- [RFC-0006](/specs/rfc/rfc-0006) - Type alias design rationale
- [SPEC-0006](/specs/spec/spec-0006) - Type alias compilation implementation
- [TSY-0002](/specs/tsy/tsy-0002) - Struct types
- [TSY-0003](/specs/tsy/tsy-0003) - Anonymous structs
- [TSY-0007](/specs/tsy/tsy-0007) - Union types
