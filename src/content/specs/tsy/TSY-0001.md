---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 1
status: draft
title: Builtin Types
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0001: Builtin Types

## Overview

This document defines the formal type-system-level description of Kintsu builtins: syntax, categories, validation constraints, and canonical transit representation guidance. TSY documents are normative for language-level behavior; wire-level encoding choices are delegated to SPEC and wire/profile documents.

## Builtin categories and syntax

The builtin set (authoritative):

- bool
- str
- i8, i16, i32, i64
- u8, u16, u32, u64
- f16, f32, f64
- complex
- datetime
- never
- binary
- base64

Type token syntax (examples):

- `i32` — signed 32-bit integer builtin
- `u64` — unsigned 64-bit integer builtin
- `f32` — 32-bit IEEE float builtin
- `str` — UTF-8 string builtin
- `binary` — raw bytes builtin; see textual base64 representation guidance for textual transports

Notes:

- Each integer builtin implies a range; implementations MUST validate numeric literals and values against the builtin's range where applicable.
- `datetime` is a transport-level instant type; it is always carried as a string in transit using ISO-8601 formatted text (see RFC-0001). The type may map to internal representations (e.g. unix epoch seconds + nanos) for runtime efficiency, but code-generators MUST document the mapping.
- `datetime` is a transport-level instant type; it is always carried as a string in transit using ISO-8601 formatted text (see RFC-0001). This specification defines the messaging protocol (the canonical transit form); implementations may map the type to internal representations (e.g. unix epoch seconds + nanos) for runtime efficiency — those internal mappings are implementation details and MUST be documented by the implementation or code-generator output.
- `complex` is represented at the type level as a two-component numeric aggregate. The canonical transit representation is an object with named fields `real` and `imag` whose types are floating-point builtins (typically `f64` for precision-sensitive targets). Example: `complex<f64>` (note: Kintsu's builtin name is `complex`; concrete element-width is a target/annotation concern for code generation).

## Validation semantics

- `bool`: accepts `true`/`false` boolean values in wire formats that support native booleans; textual transports may use `true`/`false` tokens.
- `str`: text encoded as UTF-8; implementations must reject invalid UTF-8.
- integers (`i*`, `u*`): numeric range validation is required. Overflow or underflow must raise a validation error during parsing/decoding.
- `f*`: floating-point parsing follows IEEE-754 semantics for target widths when applicable; NaN/Infinity handling is target-dependent but must be documented by code generators.
- `f*`: floating-point parsing follows IEEE-754 semantics for target widths when applicable; NaN/Infinity handling is based on the protocol used in transit (e.g. JSON) and protocol profiles MUST document the canonical representation and parsing behaviour for these special values.
- `datetime`: parse ISO-8601 textual forms; when parsing, implementations SHOULD accept common ISO-8601 variants but MUST normalise to a canonical form when serialising for transit (see RFC-0001 test vectors).
- `binary`: raw bytes for binary transports; textual transports MUST use base64.
- `base64`: textual representation of binary data using Base64 (RFC 4648). When a field is declared `base64` the parser/validator MUST accept only valid Base64 text and convert to raw bytes for downstream processing or runtime use. This builtin is intended for textual-first APIs where a distinct textual byte container is desirable. (Implementation pending.)
- `complex`: must contain both `real` and `imag` components; missing fields or non-numeric fields are validation errors.

## Canonical transit forms (summary)

- `datetime`: string, ISO-8601 with timezone (canonical e.g. `2025-10-30T14:23:00Z`).
- `complex`: object `{ "real": <float>, "imag": <float> }`.
- integers: canonical textual representation is decimal; wire binary encoding is profile-dependent (see RFC and SPEC guidance).

## Implications

- The type system keeps a small set of builtins; complex language-specific types should be modelled as structs or annotated types built on top of these primitives. Wire-level compactness decisions are intentionally deferred to allow profiles for different transports (e.g. low-bandwidth vs high-performance RPC).

## References

- [RFC-0001: Builtin Type System Design](/specs/rfc/rfc-0001)
- [SPEC-0001: Builtin Type Resolution](/specs/spec/spec-0001)
