---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-01-19
kind: TSY
number: 13
status: draft
title: Variant Tagging Rules
updates:
  - author: joshua-auchincloss
    date: 2025-01-19
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0013: Variant Tagging Rules

## Overview

This document defines the normative type-system rules for variant tagging in Kintsu. Variant tagging controls how discriminated unions (oneof) and error types are serialized with type identifiers. This TSY specifies attribute syntax, validation rules, inheritance semantics, and type constraints for each tagging style.

## Motivation

Variant tagging requires precise rules to ensure consistent serialization across implementations. This TSY documents the exact attribute parsing, validation, and inheritance rules so schema authors and code generators can rely on deterministic tagging behavior. The rules are normative—implementations must follow these specifications to ensure interoperability.

## Design Principles

- **Explicit configuration**: Tagging style must be explicitly configurable via attributes
- **Hierarchical defaults**: Namespace-level attributes provide defaults; type-level overrides
- **Variant customization**: Individual variants support renaming
- **Type constraints**: Certain tagging styles require structural constraints on variants
- **Snake_case normalization**: All variant names normalize to snake_case in output

## Type system rules (normative)

### Attribute syntax

Tagging attributes use the metadata system defined in RFC-0012.

#### Tag attribute forms

**External tagging (default):**

```kintsu
#[tag(external)]
```

**Internal tagging:**

```kintsu
#[tag(name = "field_name")]
```

The `name` parameter specifies the tag field name. Default: `kind`.

**Adjacent tagging:**

```kintsu
#[tag(name = "tag_field", content = "content_field")]
```

Both `name` and `content` parameters are required for adjacent tagging. Defaults: `kind`, `data`.

**Untagged:**

```kintsu
#[tag(untagged)]
```

**Index-based tagging:**

```kintsu
#[tag(index)]
#[tag(index, name = "field_name")]
```

The optional `name` parameter specifies the index field name. Default: `kind`.

**Type hint (default, combinable):**

```kintsu
#[tag(type_hint)]              // Explicit type_hint (default behavior)
#[tag(type_hint = false)]      // Disable type_hint, fall back to untagged
#[tag(name = "kind", type_hint)]  // Combine with internal tagging
```

Type hint tagging is conceptually **untagged + the `@kintsu` discriminator**. With `type_hint = false`, serialization falls back to pure untagged format.

The `type_hint` modifier can combine with internal, adjacent, or index tagging to add the `@kintsu` field alongside another discriminator.

#### Rename attribute

```kintsu
#[rename("custom_name")]
```

Applies to individual oneof/error variants to override snake_case normalization.

> [!NOTE]
> Enum types do not support `#[rename(...)]`. For string enums requiring custom serialized values, use explicit string literals in the enum definition.

### Attribute placement rules

| Attribute        | Scope             | Syntax                        | Effect                                     |
| ---------------- | ----------------- | ----------------------------- | ------------------------------------------ |
| `#![tag(...)]`   | Namespace (inner) | After namespace declaration   | Default for all variant types in namespace |
| `#[tag(...)]`    | Type (outer)      | Before type definition        | Override namespace default for this type   |
| `#[rename(...)]` | Variant (outer)   | Before variant in oneof/error | Override variant name                      |

**Example:**

```kintsu
namespace api {
    #![tag(name = "kind")]  // Namespace default: internal tagging

    struct Success { message: str };
    struct Error { code: i32 };
    struct Ok { value: i64 };
    struct Err { reason: str };

    type Response = oneof Success | Error;  // Uses internal tagging

    #[tag(external)]  // Type override
    type Result = oneof Ok | Err;  // Uses external tagging
};
```

**Serialized outputs:**

```json
// Response (inherited internal tagging)
{ "kind": "success", "message": "OK" }
{ "kind": "error", "code": 500 }

// Result (type-level external override)
{ "ok": { "value": 42 } }
{ "err": { "reason": "Failed" } }
```

### Inheritance rules

1. **No attribute**: Type hint tagging (global default)
2. **Namespace inner attribute**: Applies to all variant types in namespace
3. **Type outer attribute**: Overrides namespace default
4. **Specificity wins**: Type-level overrides namespace-level

**Resolution algorithm:**

```
function resolve_tagging(type):
    if type has #[tag(...)] attribute:
        return type.tag_attribute
    if type.namespace has #![tag(...)] attribute:
        return namespace.tag_attribute
    return TagStyle::TypeHint  // global default
```

### Type applicability

Tagging attributes apply only to **variant types**:

| Type     | Tagging Applicable | Notes                               |
| -------- | ------------------ | ----------------------------------- | ----------------- |
| oneof    | Yes                | Primary use case                    |
| error    | Yes                | Struct/tuple/unit variants          |
| union_or | Yes                | Oneofs generated from `&            | ` field conflicts |
| enum     | No                 | Value enumerations, no data payload |
| struct   | No                 | Single shape, no discrimination     |
| union    | No                 | Field merging, not discriminated    |
| builtin  | No                 | Primitives serialize directly       |
| alias    | Inherited          | Resolves to underlying type         |

> [!WARNING]
> Applying `#[tag(...)]` to non-variant types is a compile error.

### Validation rules

#### Internal tagging constraints

Internal tagging inserts the tag field into the variant content. This requires:

1. **Struct variants**: Must not have a field with the same name as the tag field
2. **Tuple variants**: Content must be a struct type (field insertion possible)
3. **Unit variants**: No constraint (serializes as `{ "tag": "name" }`)

**Invalid (field collision):**

```kintsu
#[tag(name = "kind")]
type Response = oneof {
    kind: str,  // ERROR: conflicts with tag field
    data: str
} | Error;
```

**Error:** `internal tag field 'kind' conflicts with variant field of same name`

#### Adjacent tagging constraints

Adjacent tagging requires distinct tag and content field names:

```kintsu
#[tag(name = "type", content = "type")]  // ERROR: same name
```

**Error:** `adjacent tag field and content field must have different names`

#### Untagged constraints

Untagged variants require structurally distinguishable types:

1. **No duplicate types**: Each variant must have a unique type
2. **Distinguishable shapes**: Struct variants must have unique field signatures

**Invalid (duplicate types):**

```kintsu
#[tag(untagged)]
type Value = oneof str | str;  // ERROR: duplicate type
```

**Error:** `untagged oneof contains duplicate variant types`

**Invalid (indistinguishable structs):**

```kintsu
#[tag(untagged)]
type Response = oneof {
    id: i64
} | {
    id: i64  // ERROR: same shape
};
```

**Error:** `untagged oneof contains structurally indistinguishable variants`

> [!IMPORTANT]
> Untagged validation is best-effort. Some ambiguities may only manifest at runtime during deserialization.

#### Index tagging constraints

Index values are assigned by declaration order (0-indexed):

```kintsu
type Status = oneof
    Active |    // index 0
    Pending |   // index 1
    Complete;   // index 2
```

> [!WARNING]
> Reordering variants changes index values. This is a breaking change for existing serialized data.

### Union Or (`&|`) tagging

When the `&|` operator produces oneofs for conflicting fields, those oneofs inherit tagging from their containing context.

**Tagging inheritance for union_or:**

1. The generated oneof inherits the namespace's `#![tag(...)]` default
2. No direct `#[tag(...)]` can be placed on union_or conflict fields (they are generated, not authored)
3. Variant names in generated oneofs use the type names of the conflicting operands

**Schema:**

```kintsu
namespace api {
    #![tag(name = "kind")]

    struct UserProfile {
        id: i64,
        display_name: str,
        settings: str    // JSON string in UserProfile
    };

    struct AdminProfile {
        id: i64,
        display_name: str,
        settings: {      // Inline struct in AdminProfile
            permissions: str[],
            audit_log: bool
        }
    };

    // Combined type merges non-conflicting fields, creates oneof for conflicts
    type Profile = UserProfile &| AdminProfile;
    // Resulting shape:
    // struct Profile {
    //     id: i64,                    // same type, no conflict
    //     display_name: str,          // same type, no conflict
    //     settings: oneof str | {...} // different types, becomes oneof
    // }
};
```

**Serialized outputs:**

```json
// Profile with string settings (UserProfile's type)
{
  "id": 42,
  "display_name": "alice",
  "settings": "{\"theme\": \"dark\"}"
}

// Profile with struct settings (AdminProfile's type)
{
  "id": 1,
  "display_name": "admin",
  "settings": {
    "permissions": ["read", "write", "delete"],
    "audit_log": true
  }
}
```

> [!NOTE]
> Union or generated oneofs do not include nested type hints. The variant is distinguishable by its structure (primitive vs struct).
> For primitive type variants in union_or oneofs, the variant name is the builtin type name (e.g., `str`). For anonymous struct variants, the compiler generates names using the parent type and field name.

### Variant name normalization

All variant names are normalized to snake_case. The `#[rename(...)]` attribute overrides the default normalization for individual variants.

**Schema:**

```kintsu
namespace workflow {
    struct Active { started_at: datetime };
    struct InProgress { percent: i32 };
    struct Complete { finished_at: datetime };
    struct OnHold { reason: str };

    #[tag(name = "state")]
    type TaskStatus = oneof
        Active |
        InProgress |
        Complete |
        #[rename("paused")]  // Override default "on_hold"
        OnHold;
};
```

**Serialized outputs:**

```json
// Active -> "active"
{ "state": "active", "started_at": "2025-01-19T10:00:00Z" }

// InProgress -> "in_progress" (PascalCase to snake_case)
{ "state": "in_progress", "percent": 75 }

// Complete -> "complete"
{ "state": "complete", "finished_at": "2025-01-19T12:00:00Z" }

// OnHold -> "paused" (renamed, not "on_hold")
{ "state": "paused", "reason": "Waiting for approval" }
```

### Type hint format

Type hints use the format: `schema::namespace::Type::v{version}::variant`

**Components:**

- `schema`: Schema name (from namespace hierarchy root)
- `namespace`: Full namespace path (nested with `::`)
- `Type`: Type name (PascalCase preserved)
- `v{version}`: Version prefixed with `v` from `#[version(n)]` metadata
- `variant`: The active variant name (snake_case normalized)

### Type hint versioning rules (normative)

The version in a type hint represents the **versioned container** that guarantees all nested structure. This creates a contract between the compiler and consumers.

**Version resolution by type:**

| Type                | Version Source                                        | What It Guarantees                                         |
| ------------------- | ----------------------------------------------------- | ---------------------------------------------------------- |
| **oneof**           | Type's `#[version(n)]` or inherited namespace version | Variant set, variant names, and all nested payload shapes  |
| **error**           | Type's `#[version(n)]` or inherited namespace version | Variant set, variant payloads (struct fields, tuple types) |
| **variant payload** | Parent's version                                      | Fields are frozen at parent's version                      |

**Nested type omission rule:**

Type hints appear **only at the top level** of serialized objects. Once a consumer knows the top-level type and version, the specification guarantees:

1. Which variants exist
2. The exact shape of each variant's payload
3. All transitively nested types

Including hints on nested objects would be redundant—the parent's version already locks the entire structure.

**Example:**

```kintsu
namespace api {
    #![version(1)]

    struct Success { message: str };
    struct Error { code: i32 };

    // Default type_hint tagging
    type Response = oneof Success | Error;
};
```

**Type hint values:**

- Success variant: `api::api::Response::v1::success`
- Error variant: `api::api::Response::v1::error`

This hint guarantees: `Response` at version 1 has exactly the variants `Success` and `Error` with their version-1 shapes. No nested hints needed.

### Unit variant serialization

Unit variants (no payload) have special serialization rules:

| Tagging Style | Unit Variant Serialization                                                  |
| ------------- | --------------------------------------------------------------------------- |
| Type hint     | `{ "@kintsu": "schema::ns::Type::v1::variant" }`                            |
| External      | `{ "variant_name": null }`                                                  |
| Internal      | `{ "tag": "variant_name" }`                                                 |
| Adjacent      | `{ "tag": "variant_name", "content": null }` or `{ "tag": "variant_name" }` |
| Untagged      | `null`                                                                      |
| Index         | `{ "tag": N }` (index only, no content)                                     |

**Example:**

```kintsu
error ApiError {
    Unknown,  // Unit variant
    Timeout { duration_ms: i64 }  // Struct variant
};
```

With `#[tag(name = "kind")]`:

```json
{ "kind": "unknown" }
{ "kind": "timeout", "duration_ms": 5000 }
```

With `#[tag(name = "type", content = "data")]`:

```json
{ "type": "unknown", "data": null }
{ "type": "timeout", "data": { "duration_ms": 5000 } }
```

## References

- [RFC-0017](/specs/rfc/RFC-0017) - Variant Tagging Design
- [RFC-0008](/specs/rfc/RFC-0008) - OneOf Type Design
- [RFC-0005](/specs/rfc/RFC-0005) - Error Type Design
- [RFC-0012](/specs/rfc/RFC-0012) - Metadata System
- [TSY-0008](/specs/tsy/TSY-0008) - OneOf Types
- [TSY-0005](/specs/tsy/TSY-0005) - Error Types
- [SPEC-0016](/specs/spec/SPEC-0016) - Variant Tagging Compilation
