---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 12
status: draft
title: Metadata
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Enhanced code blocks with expressive-code markers
version_after: 0.1.0
version_before: null
---

# TSY-0012: Metadata

## Overview

This specification defines the normative type system rules for metadata annotations in Kintsu schemas. Metadata uses attribute syntax to annotate schema elements with version information and error type defaults. The system distinguishes between **outer attributes** (`#[...]`) that apply to specific items and **inner attributes** (`#![...]`) that apply to containing scopes and their children.

Key aspects:

- **Attribute syntax**: `#[metadata(value)]` for outer (item-level), `#![metadata(value)]` for inner (scope-level)
- **Version metadata**: Integer version tracking with `#[version(n)]`
- **Error metadata**: Default error types with `#[err(ErrorType)]`
- **Inheritance**: Namespace-level inner attributes provide defaults for child items
- **Override semantics**: Item-level outer attributes override inherited defaults

![Metadata Inheritance Flow](../../../../diagrams/metadata_inheritance.png)

## Motivation

Metadata annotations solve two critical schema evolution problems:

1. **Version tracking**: Schemas evolve over time, and both producers and consumers need explicit version information to handle compatibility and breaking changes
2. **Error defaults**: Fallible operations require error types, and namespace-level defaults reduce boilerplate while maintaining flexibility

The type system must define precise rules for metadata syntax, inheritance, validation, and conflict resolution to ensure predictable behaviour across tooling.

## Design Principles

1. **Explicit over implicit**: Metadata is visible in the schema source, not inferred
2. **Inheritance with override**: Namespace defaults reduce repetition, item-level metadata provides exceptions
3. **Lexical scoping**: Inner attributes apply to their containing scope
4. **Validation at parse time**: Invalid metadata is rejected during parsing, not at runtime
5. **Extensibility**: Attribute syntax supports future metadata types beyond version and error

## Type system rules (normative)

### Rule 1: Metadata attribute syntax

Metadata uses attribute syntax with two forms:

**Outer attributes** (`#[...]`):

```kintsu
#[version(1)]
struct User {
    id: i64,
    name: string,
}
```

**Inner attributes** (`#![...]`):

```kintsu
namespace api {
    #![version(1)]
    #![err(ApiError)]

    struct User { ... }
}
```

> [!IMPORTANT]
> Inner attributes must appear at the beginning of a namespace declaration, before any type or operation definitions.

**Syntax structure:**

- Outer: `#` + `[` + metadata name + `(` + value + `)` + `]`
- Inner: `#` + `!` + `[` + metadata name + `(` + value + `)` + `]`

### Rule 2: Version metadata syntax

Version metadata specifies schema version using positive integers.

**Syntax**: `version(n)` where `n` is a positive integer (`i32` > 0)

**Valid forms:**

```kintsu
#[version(1)]     // Outer: applies to following item
#![version(1)]    // Inner: applies to containing namespace's children
```

**Invalid forms:**

```kintsu del={1-3}
#[version(0)]     // Error: version must be positive
#[version(-1)]    // Error: version must be positive
#[version("1")]   // Error: version must be integer, not string
```

> [!WARNING]
> Version metadata accepts only positive integers. Zero and negative values are rejected at parse time.

### Rule 3: Error metadata syntax

Error metadata specifies default error types for fallible operations.

**Syntax**: `err(ErrorType)` where `ErrorType` is an identifier or path referencing an error type

**Valid forms:**

```kintsu
#[err(MyError)]              // Outer: applies to following operation
#![err(DefaultError)]        // Inner: applies to namespace's operations
#[err(schema::errors::ApiError)]  // Qualified path
```

**Invalid forms:**

```kintsu del={1-2}
#[err(1)]         // Error: error type must be identifier, not number
#[err("MyError")] // Error: error type must be identifier, not string
```

### Rule 4: Inner attribute scope

Inner attributes (`#![...]`) apply to the containing namespace and its child items.

**Scope rules:**

1. Inner attributes appear at the beginning of namespace declarations
2. Inner attributes apply to all child items (types and operations) in that namespace
3. Inner attributes do not propagate to nested child namespaces
4. Multiple inner attributes of different types can coexist

**Example:**

```kintsu
namespace api {
    #![version(1)]        // Applies to User, Account, getUser
    #![err(ApiError)]     // Applies to getUser

    struct User { ... }   // Inherits version(1)
    struct Account { ... } // Inherits version(1)

    operation getUser() -> User!;  // Inherits err(ApiError)
}
```

> [!IMPORTANT]
> Inner attributes apply only to direct children, not to nested namespaces or their contents.

### Rule 5: Outer attribute scope

Outer attributes (`#[...]`) apply only to the item they immediately precede.

**Scope rules:**

1. Outer attributes appear immediately before the item they annotate
2. Outer attributes apply only to that specific item
3. Outer attributes override any inherited metadata from namespace
4. Multiple outer attributes can precede a single item

**Example:**

```kintsu
namespace api {
    #![version(1)]
    #![err(DefaultError)]

    #[version(2)]         // Outer: overrides namespace version
    struct Account { ... } // Uses version(2), not version(1)

    #[err(SpecificError)] // Outer: overrides namespace error
    operation createUser() -> User!;  // Uses SpecificError, not DefaultError
}
```

### Rule 6: Version metadata inheritance

Version metadata can be specified at namespace level (inner) or type level (outer).

**Inheritance rules:**

1. Types without explicit version metadata inherit from namespace-level `#![version(n)]`
2. Types with explicit `#[version(n)]` override namespace-level version
3. If neither type nor namespace has version metadata, no version is assigned
4. Version metadata is not inherited by nested child namespaces

**Example:**

```kintsu
namespace api {
    #![version(1)]

    struct User { ... }        // Inherits version(1)

    #[version(2)]
    struct Account { ... }      // Uses version(2)

    struct Profile { ... }      // Inherits version(1)
}
```

> [!NOTE]
> Version inheritance follows the principle of specificity: more specific (type-level) metadata overrides less specific (namespace-level) metadata.

### Rule 7: Error metadata inheritance

Error metadata can be specified at namespace level (inner) or operation level (outer).

**Inheritance rules:**

1. Operations without explicit error metadata inherit from namespace-level `#![err(ErrorType)]`
2. Operations with explicit `#[err(ErrorType)]` override namespace-level error
3. Fallible operations (return type with `!`) without error metadata and without namespace default are invalid
4. Infallible operations (return type without `!`) ignore error metadata

**Example:**

```kintsu
namespace api {
    #![err(ApiError)]

    operation getUser() -> User!;     // Inherits err(ApiError)

    #[err(ValidationError)]
    operation createUser() -> User!;  // Uses err(ValidationError)

    operation deleteUser() -> void!;  // Inherits err(ApiError)
}
```

> [!WARNING]
> Fallible operations must have an associated error type either through inheritance or explicit annotation. Missing error metadata for fallible operations is a compilation error.

### Rule 8: Metadata override semantics

When both namespace-level (inner) and item-level (outer) metadata exist, item-level metadata takes precedence.

**Override rules:**

1. Outer attributes override inner attributes of the same type
2. Outer attributes do not affect other items in the namespace
3. Absence of outer attribute means "use inherited value if available"
4. Outer attributes can introduce metadata not present at namespace level

**Example:**

```kintsu
namespace api {
    #![version(1)]

    struct User { ... }        // Uses version(1) from namespace

    #[version(2)]
    struct Account { ... }      // Overrides to version(2)
}
```

### Rule 9: Metadata validation rules

All metadata must be validated during parsing:

1. **Version values**: Must be positive integers (`i32` > 0)
2. **Error types**: Must reference valid identifier or path
3. **Position**: Inner attributes must appear before type/operation definitions
4. **Uniqueness**: Multiple metadata of same type on same item are invalid
5. **Applicability**: Error metadata only applies to operations, version metadata only applies to types/namespaces

**Invalid examples:**

```kintsu del={1-4,9,13,17}
// Invalid: duplicate version metadata
#[version(1)]
#[version(2)]
struct User { ... }

// Invalid: inner attribute after definitions
namespace api {
    struct User { ... }
    #![version(1)]  // Error: must appear before definitions
}

// Invalid: version on operation
#[version(1)]  // Error: version only applies to types/namespaces
operation getUser() -> User;

// Invalid: error on struct
#[err(MyError)]  // Error: error only applies to operations
struct User { ... }
```

> [!IMPORTANT]
> Metadata validation occurs during parsing. Invalid metadata produces compilation errors with specific diagnostic messages.

### Rule 10: Multiple metadata on single item

Multiple metadata attributes of **different types** can be applied to the same item.

**Valid:**

```kintsu
namespace api {
    #![version(1)]
    #![err(ApiError)]  // Multiple different types: valid

    struct User { ... }
}
```

**Invalid:**

```kintsu
namespace api {
    #![version(1)]
    #![version(2)]     // Multiple same type: invalid

    struct User { ... }
}
```

> [!WARNING]
> Multiple metadata attributes of the same type on a single item are invalid and produce compilation errors.

## Implications

### For Schema Authors

- Must understand inner vs outer attribute distinction
- Should use namespace-level defaults to reduce boilerplate
- Can override defaults at item level when needed
- Must ensure fallible operations have error types (inherited or explicit)

### For Compiler Implementations

- Must parse both inner and outer attribute forms
- Must validate metadata values at parse time
- Must implement inheritance resolution algorithm
- Must produce clear error messages for invalid metadata

### For Code Generators

- Must extract metadata from AST during code generation
- Must respect inheritance rules when generating target code
- Must handle cases where metadata is absent
- Should leverage version information for compatibility features

## References

- [RFC-0012](/specs/rfc/RFC-0012) - Metadata system design
- [SPEC-0012](/specs/spec/SPEC-0012) - Metadata resolution implementation
- [TSY-0005](/specs/tsy/TSY-0005) - Error types
- [TSY-0009](/specs/tsy/TSY-0009) - Operations
- [TSY-0010](/specs/tsy/TSY-0010) - Namespace system
