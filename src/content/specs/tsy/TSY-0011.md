---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 11
status: draft
title: Imports
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0011: Imports

## Overview

This document defines the normative type-system rules for import statements in Kintsu. Imports use `use` keyword to bring types and namespaces into scope. This TSY specifies import syntax (`use` with `::` path separator), qualified imports (namespace vs specific types), multiple item syntax (braces), private vs public import visibility (namespace files vs `lib.ks`), cross-schema import requirements (dependency declarations), and import validation rules.

![Import Resolution Flow](../../../../diagrams/import_resolution_flow.png)

## Motivation

Imports enable modular schema design and code reuse. This TSY documents the exact syntax and resolution rules so schema authors know how to import types correctly and code generators can resolve dependencies reliably. The private vs public import distinction is normative â€” `lib.ks` imports are re-exported, namespace file imports are not.

## Design Principles

- **Explicit imports**: Use `use` statements to declare dependencies
- **Path-based resolution**: Use `::` separator for namespace traversal
- **Multiple item syntax**: Support braces for multiple imports from same namespace
- **Visibility control**: Private imports (namespace files) vs public imports (`lib.ks`)
- **Cross-schema dependencies**: Require dependency declarations in manifest
- **Early resolution**: Resolve imports before type processing

## Type system rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu type system.

### Import syntax and parsing

Import statements use `use` keyword followed by a path:

```kintsu
use abc::types::User;
```

**Syntax components:**

1. **`use` keyword** - Declares import statement
2. **Path** - `::` separated namespace/type path
3. **Semicolon** - Statement terminator

**Single item import:**

```kintsu
use abc::types::User;
```

**Multiple items import:**

```kintsu
use abc::types::{User, Config, Session};
```

> [!IMPORTANT]
> Import statements must appear before type definitions in the namespace.

### Qualified imports (namespace)

Import entire namespace to access types via qualified paths:

```kintsu
use abc::types;

struct Request {
    user: types::User  // Access via namespace qualifier
};
```

**Namespace import makes the namespace name available, not individual types.**

### Qualified imports (specific types)

Import specific types to access directly by name:

```kintsu
use abc::types::User;
use abc::types::Config;

struct Request {
    user: User,  // Direct access
    config: Config
};
```

**Type imports make the type name available directly.**

### Multiple item syntax (braces)

Import multiple items from same namespace using braces:

```kintsu
use abc::types::{
    User,
    Config,
    Session,
    Token
};
```

**Equivalent to four separate `use` statements.**

**Nested imports:**

```kintsu
use root::{
    sub::Type1,
    sub::Type2,
    other::Type3
};
```

> [!NOTE]
> Braces can contain simple identifiers or paths with `::`.

### Single item brace syntax (optional)

Single items can use braces (formatted without):

```kintsu
use abc::types::{User};  // Valid, but formatted as:
use abc::types::User;    // Formatter removes unnecessary braces
```

> [!NOTE]
> The formatter simplifies single-item brace imports to simple imports.

### Private imports (namespace files)

Imports in namespace `.ks` files are **private** to that namespace:

```kintsu
# api/handlers.ks
namespace api::handlers;

use abc::types::User;  // Private import

operation handle(user: User) -> bool;
```

**Visibility:** `User` is visible only within `api::handlers`. Other namespaces importing `api::handlers` cannot access `User`.

> [!IMPORTANT]
> Private imports are namespace-scoped. They are not re-exported.

### Public imports (lib.ks)

Imports in `lib.ks` are **public** and re-exported:

```kintsu
# lib.ks
namespace myschema;

use foo;
use bar;
```

**Visibility:** Consumers of `myschema` can access `foo` and `bar` namespaces. This defines the schema's public API surface.

> [!NOTE] > `lib.ks` is the schema's public API declaration. All imports in `lib.ks` are re-exported.

### Cross-schema import requirements

Cross-schema imports require dependency declarations:

```kintsu
# myapp schema
namespace myapp;

use external_pkg::types::User;  // Cross-schema import
```

**Requirements:**

1. **Dependency declaration**: `external_pkg` must be listed in schema manifest (`schema.toml`)
2. **Schema availability**: `external_pkg` schema must be available during compilation
3. **Path resolution**: Compiler resolves `external_pkg` to dependency schema, then resolves `types::User` within it

> [!WARNING]
> Importing from undeclared dependencies causes compilation errors.

### Import validation rules

The compiler validates all imports:

**Missing package:**

```kintsu
use nonexistent::Type;  // ERROR: package 'nonexistent' not found
```

**Missing namespace:**

```kintsu
use abc::nonexistent::Type;  // ERROR: namespace 'nonexistent' not found in 'abc'
```

**Missing type:**

```kintsu
use abc::types::Missing;  // ERROR: type 'Missing' not found in 'abc::types'
```

**Circular dependencies:**

```kintsu
# api.ks
use common::types::User;

# common.ks
use api::Request;  // ERROR: circular dependency
```

> [!WARNING]
> All validation failures cause compilation errors. Imports must resolve successfully.

### Import resolution order

Imports are resolved early in compilation:

**Resolution stages:**

1. **Parse phase**: Parse `use` statements during namespace loading
2. **Graph construction**: Build dependency graph based on imports
3. **Resolution phase**: Resolve each import path to namespace/type
4. **Validation phase**: Validate all imports before type processing begins

> [!NOTE]
> Import resolution happens before type resolution stages (anonymous struct extraction, union resolution, etc.).

### Import positioning

Imports must appear at specific locations in namespace files:

```kintsu
#![version(1)]        // Metadata first
namespace api;        // Namespace declaration

use abc::types::User; // Imports after namespace, before types
use abc::errors::ApiError;

struct Request {      // Type definitions after imports
    user: User
};
```

**Order:**

1. Metadata attributes (`#![...]`)
2. Namespace declaration
3. Import statements (`use ...`)
4. Type definitions

> [!IMPORTANT]
> Imports must appear before type definitions. Incorrect ordering causes parse errors.

## Implications

**For schema authors:**

- Use `use` statements to import types and namespaces
- Private imports (namespace files) are not re-exported
- Public imports (`lib.ks`) define schema's public API
- Cross-schema imports require dependency declarations
- Import statements must appear before type definitions

**For code generators:**

- Private imports are namespace-scoped (not visible to consumers)
- Public imports (from `lib.ks`) are re-exported
- All imports are resolved and validated before code generation
- Cross-schema imports require dependency schema loading

**For type system implementers:**

- Parse `use` statements during namespace loading
- Build dependency graph from import relationships
- Resolve imports before type resolution stages
- Validate namespace and type existence
- Detect circular dependencies
- Enforce import positioning rules

## References

- [RFC-0011](/rfc/rfc-0011) - Import system design rationale
- [SPEC-0011](/spec/spec-0011) - Import resolution
- [TSY-0010](/tsy/tsy-0010) - Namespace type system rules
- [RFC-0010](/rfc/rfc-0010) - Namespace system design
