---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 8
status: draft
title: OneOf Types
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0008: OneOf Types

## Overview

This document defines the normative type-system rules for oneOf types in Kintsu. OneOf types represent discriminated unions where a value can be one of several explicitly enumerated types, separated by `|`. This TSY specifies oneOf syntax, variant ordering semantics, anonymous struct variant extraction, union variant resolution, type reference validation, and variant count constraints.

![OneOf Discriminated Union Structure](../../../../diagrams/oneof_structure.png)

## Motivation

OneOf types provide type-safe discrimination for polymorphic data. This TSY documents the exact variant ordering rules and extraction semantics so schema authors and code generators can rely on consistent discriminant behavior. The variant numbering algorithm for anonymous structs is normative — implementations must generate the same names to ensure interoperability.

## Design Principles

- **Explicit discrimination:** Each variant is uniquely identifiable via a discriminant
- **Variant ordering:** Declaration order is preserved and determines discriminant values
- **Anonymous extraction:** Anonymous struct variants are extracted with sequential numbering
- **Union resolution:** Union variants are resolved before oneOf finalization
- **Type validation:** All variant types must resolve to valid registered types
- **Minimum variants:** At least two variants are required for meaningful discrimination

## Type system rules (normative)

### Syntax and parsing

OneOf type expressions use the `oneof` keyword followed by pipe-separated type expressions:

```kintsu
oneof Type1 | Type2 | Type3
```

**Variant types include:**

- Builtins: `i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `str`, `bytes`, `datetime`
- Named types: references to structs, enums, errors, or other oneOfs
- Anonymous structs: `{ field1: Type1, field2: Type2, ... }`
- Unions: `TypeA & TypeB`
- Parenthesized types: `(Type)`
- Arrays: `Type[]`, `Type[N]`
- Nested oneOfs: `(oneof A | B)`

**Examples:**

```kintsu
type Value = oneof i32 | str | bool;
type Response = oneof Success | Error;
type Complex = oneof { id: i64 } | str | i32;
type Nested = oneof i32 | (oneof str | bool);
type WithUnion = oneof (Base & Extension) | Alt;
```

> [!NOTE]
> Parentheses are required when combining oneOf with arrays: `(oneof A | B)[]`

### Variant ordering (preserved)

Variants are parsed in declaration order and this order is preserved. The order determines discriminant values assigned to variants in generated code.

**Example:**

```kintsu
type Status = oneof Active | Pending | Completed;
```

**Variant indices:**

- Variant 0: Active
- Variant 1: Pending
- Variant 2: Completed

> [!IMPORTANT]
> Variant order is significant for binary serialization and code generation. Reordering variants is a breaking change that affects discriminant values.

### Anonymous struct variant extraction

Anonymous struct definitions in oneOf variants are extracted during compilation and assigned generated names using sequential numbering.

**Naming algorithm:** ParentName + sequential index (starting at 1)

**Example:**

```kintsu
type Response = oneof {
    success: bool,
    data: str
} | {
    error: str,
    code: i32
};
```

**After extraction:**

```kintsu
struct Response1 {
    success: bool,
    data: str
};

struct Response2 {
    error: str,
    code: i32
};

type Response = oneof Response1 | Response2;
```

> [!IMPORTANT]
> Numbering is sequential based on variant position (1, 2, 3...). The generated struct names are deterministic and stable.

### Union variant resolution

When a oneOf variant is a union expression, the union is resolved before the oneOf is finalized. The resolved union generates a struct that becomes the variant type.

**Example:**

```kintsu
struct Base { x: i32 };
struct Extension { y: str };
struct Alt { z: bool };

type Data = oneof (Base & Extension) | Alt;
```

**Resolution steps:**

1. Resolve union `(Base & Extension)` → generates `Data1` (merged struct)
2. Union `Alt` is already a struct → remains `Alt`
3. Final oneOf: `oneof Data1 | Alt`

> [!NOTE]
> Union resolution follows the same rules as TSY-0007. Generated struct names for union variants use the same sequential numbering as anonymous struct variants.

### Nested oneOf handling

OneOf types can contain nested oneOf expressions in parentheses:

```kintsu
type Nested = oneof i32 | (oneof str | bool);
```

The nested oneOf is treated as a single variant. In the type system, this preserves the nested structure, though code generators may flatten the variants.

**Example:**

```kintsu
type Response = oneof Success | (oneof ClientError | ServerError);
```

This is semantically distinct from:

```kintsu
type Response = oneof Success | ClientError | ServerError;
```

The nested form groups ClientError and ServerError as a single discriminated variant.

### Type reference validation

All variant types must resolve to valid types in the type registry. During compilation, the compiler validates that each variant type exists.

**Valid:**

```kintsu
struct Foo { id: i64 };
struct Bar { name: str };
type Valid = oneof Foo | Bar;  // OK: both types exist
```

**Invalid:**

```kintsu
type Invalid = oneof Foo | UnknownType;  // ERROR: type 'UnknownType' not found
```

> [!WARNING]
> If any variant type cannot be resolved, oneOf validation fails with an error indicating the missing type.

### Variant count constraint

OneOf types must have at least two variants. Single-variant oneOf types are rejected:

```kintsu
type Invalid = oneof Foo;  // ERROR: oneOf requires at least 2 variants
```

> [!NOTE]
> This constraint enforces meaningful discrimination. A single variant provides no alternatives and should use the type directly.

### Trailing pipe restriction

Trailing pipe separators are not allowed:

```kintsu
type Invalid = oneof A | B |  // ERROR: trailing pipe not allowed
```

The parser rejects trailing pipes to prevent ambiguity.

### Primitive and named type mixing

OneOf variants can mix primitive types and named types:

```kintsu
struct CustomData {
    value: i64,
    label: str
};

type Mixed = oneof i32 | str | CustomData;  // Valid: mix primitives and custom types
```

Both primitives and custom types are valid variants.

## Implications

**For schema authors:**

- Variant order determines discriminant values (must remain stable)
- Anonymous struct variants are automatically numbered
- Union variants are resolved transparently
- Minimum 2 variants enforced

**For code generators:**

- Variant order is deterministic and stable
- Anonymous struct names follow predictable numbering (Name1, Name2, ...)
- Union variants are pre-resolved to struct types
- Discriminant strategies can vary by target language

**For tooling:**

- Variant order can be validated for backward compatibility
- Anonymous struct extraction can be traced
- Type validation ensures all variants are well-formed

## References

- [RFC-0008](/rfc/rfc-0008) - OneOf type design rationale
- [SPEC-0008](/spec/spec-0008) - OneOf type compilation implementation
- [TSY-0003](/tsy/tsy-0003) - Anonymous structs (for variant extraction)
- [TSY-0007](/tsy/tsy-0007) - Union types (for union variant resolution)
- [RFC-0007](/rfc/rfc-0007) - Union types (for comparison)
