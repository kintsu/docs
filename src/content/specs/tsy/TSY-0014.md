---
author: joshua-auchincloss
components:
  - type-system
created: 2025-12-25
kind: TSY
number: 14
status: draft
title: Type Expression Rules
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0014: Type Expression Rules

## Abstract

This specification defines the normative type system rules for type expressions. Type expressions are compile-time operators that transform, select, and project types. This document establishes the formal rules governing operator applicability, resolution semantics, validation constraints, and composition behavior.

## Scope

This specification covers:

- Type expression operator definitions
- Resolution semantics and ordering
- Validation rules and constraints
- Composition rules
- Error conditions and diagnostics

## Terminology

**Type Expression**: A compile-time construct that derives a new type from one or more source types using transformation operators.

**Operator**: A built-in type-level function that transforms or projects types (e.g., `Pick`, `Omit`, `Partial`).

**Target Type**: The source type an operator is applied to.

**Selector**: A field name, variant name, or expression that identifies which elements of a type to operate on.

**Resolved Type**: The resulting type after a type expression has been fully evaluated.

## Type Expression Operators

### Operator Classification

Operators are classified by their target type:

| Class                | Operators                             | Target Type                |
| -------------------- | ------------------------------------- | -------------------------- |
| Struct Operators     | `Pick`, `Omit`, `Partial`, `Required` | Struct types               |
| OneOf Operators      | `Exclude`, `Extract`                  | OneOf types                |
| Array Operators      | `ArrayItem`                           | Array types                |
| Projection Operators | `::`                                  | Struct, OneOf, Error types |

### Struct Operators

#### Pick

**Signature:** `Pick[S, f1 | f2 | ... | fn]`

**Requirements:**

- `S` MUST resolve to a struct type
- Each `f[i]` MUST be an identifier
- Each `f[i]` MUST name a field that exists in `S`
- `n` MUST be at least 1 (non-empty selector list)

**Resolution:**

1. Resolve `S` to its underlying struct type
2. Create new struct type containing only fields `f1, f2, ..., fn`
3. Preserve field order from original struct
4. Preserve field optionality from original struct
5. Preserve field metadata from original struct

**Result Type:** Struct type with fields `f1, f2, ..., fn`

#### Omit

**Signature:** `Omit[S, f1 | f2 | ... | fn]`

**Requirements:**

- `S` MUST resolve to a struct type
- Each `f[i]` MUST be an identifier
- Each `f[i]` MUST name a field that exists in `S`
- After omission, at least one field MUST remain

**Resolution:**

1. Resolve `S` to its underlying struct type
2. Create new struct type containing all fields except `f1, f2, ..., fn`
3. Preserve field order from original struct
4. Preserve field optionality for remaining fields
5. Preserve field metadata for remaining fields

**Result Type:** Struct type without fields `f1, f2, ..., fn`

#### Partial

**Signature:** `Partial[S]` or `Partial[S, f1 | f2 | ... | fn]`

**Requirements:**

- `S` MUST resolve to a struct type
- When selectors are provided:
  - Each `f[i]` MUST be an identifier
  - Each `f[i]` MUST name a field that exists in `S`

**Resolution (all fields):**

1. Resolve `S` to its underlying struct type
2. Create new struct type with all fields marked optional
3. Preserve field order and metadata

**Resolution (specific fields):**

1. Resolve `S` to its underlying struct type
2. Create new struct type with specified fields marked optional
3. Fields not in selector list retain original optionality
4. Preserve field order and metadata

**Result Type:** Struct type with specified fields (or all fields) made optional

**Idempotency:** Applying `Partial` to already-optional fields has no effect.

#### Required

**Signature:** `Required[S]` or `Required[S, f1 | f2 | ... | fn]`

**Requirements:**

- `S` MUST resolve to a struct type
- When selectors are provided:
  - Each `f[i]` MUST be an identifier
  - Each `f[i]` MUST name a field that exists in `S`

**Resolution (all fields):**

1. Resolve `S` to its underlying struct type
2. Create new struct type with all fields marked required
3. Preserve field order and metadata

**Resolution (specific fields):**

1. Resolve `S` to its underlying struct type
2. Create new struct type with specified fields marked required
3. Fields not in selector list retain original optionality
4. Preserve field order and metadata

**Result Type:** Struct type with specified fields (or all fields) made required

**Idempotency:** Applying `Required` to already-required fields has no effect.

### OneOf Operators

#### Exclude

**Signature:** `Exclude[U, V1 | V2 | ... | Vn]`

**Requirements:**

- `U` MUST resolve to a oneof type
- Each `V[i]` MUST be a type identifier
- Each `V[i]` MUST name a variant that exists in `U`
- After exclusion, at least one variant MUST remain

**Resolution:**

1. Resolve `U` to its underlying oneof type
2. Create new oneof type containing all variants except `V1, V2, ..., Vn`
3. Preserve variant order from original oneof
4. Preserve variant tagging configuration

**Result Type:** OneOf type without variants `V1, V2, ..., Vn`

**Single Variant:** If exactly one variant remains, the result type MAY be simplified to that variant's type directly.

#### Extract

**Signature:** `Extract[U, V1 | V2 | ... | Vn]`

**Requirements:**

- `U` MUST resolve to a oneof type
- Each `V[i]` MUST be a type identifier
- Each `V[i]` MUST name a variant that exists in `U`
- `n` MUST be at least 1 (non-empty selector list)

**Resolution:**

1. Resolve `U` to its underlying oneof type
2. Create new oneof type containing only variants `V1, V2, ..., Vn`
3. Preserve variant order from original oneof
4. Preserve variant tagging configuration

**Result Type:** OneOf type with only variants `V1, V2, ..., Vn`

**Single Variant:** If exactly one variant is extracted, the result type MAY be simplified to that variant's type directly.

### Array Operators

#### ArrayItem

**Signature:** `ArrayItem[A]`

**Requirements:**

- `A` MUST resolve to an array type (`T[]` or `T[N]`)

**Resolution:**

1. Resolve `A` to its underlying array type
2. Extract the element type `T` from the array type

**Result Type:** The element type `T`

### Projection Operators

#### Field/Variant Access (`::`)

**Signature:** `T::name` or `T::name1::name2::...::nameN`

**Requirements:**

- `T` MUST resolve to a struct, oneof, or error type
- Each `name[i]` MUST be an identifier
- Each `name[i]` MUST:
  - For struct types: name a field that exists in the struct
  - For oneof types: name a variant that exists in the oneof
  - For error types: name a variant that exists in the error

**Resolution (single access):**

1. Resolve `T` to its underlying type
2. Look up `name` in the type:
   - Struct: Return the field's type, preserving optionality
   - OneOf: Return the variant's type
   - Error: Return the variant's payload type

**Resolution (chained access):**

1. Resolve `T::name1` to intermediate type `T1`
2. Resolve `T1::name2` to intermediate type `T2`
3. Continue until `T[n-1]::nameN` resolves to final type

**Result Type:** The type of the accessed field or variant

**Array Fields:** Accessing an array field returns the array type. Use `ArrayItem` to extract the element type:

```kintsu
// User::tags returns str[], not str
type TagArray = User::tags;     // str[]
type Tag = ArrayItem[User::tags]; // str
```

**Optional Fields:** Accessing an optional field preserves optionality:

```kintsu
struct User { email?: str };
type Email = User::email;  // str? (optional)
```

## Resolution Semantics

### Resolution Order

Type expressions are resolved during the type alias resolution phase, before standard type resolution:

1. Parse type expression syntax
2. Resolve all type references within the expression
3. Evaluate operators from innermost to outermost
4. Produce resolved type
5. Register resolved type as a type alias
6. Continue with standard alias resolution

### Alias Transparency

Type expressions operate on the resolved types of their targets, not the alias names:

```kintsu
struct User { id: i64, name: str, email: str };
type UserAlias = User;

// These are equivalent:
type A = Pick[User, id];
type B = Pick[UserAlias, id];
```

### Evaluation Order

Nested type expressions evaluate from innermost to outermost:

```kintsu
type Result = Partial[Pick[User, id | name]];
// 1. Pick[User, id | name] => { id: i64, name: str }
// 2. Partial[{ id: i64, name: str }] => { id?: i64, name?: str }
```

### Caching and Deduplication

Compilers MAY cache resolved type expressions to avoid redundant computation. Structurally equivalent type expressions SHOULD resolve to the same type.

## Validation Rules

### Type Mismatch Errors

**EXPR000: Invalid target type for struct operator**

```
Pick[i32, x]
     ^^^ expected struct type, found scalar type 'i32'
```

**EXPR001: Invalid target type for oneof operator**

```
Exclude[User, Admin]
        ^^^^ expected oneof type, found struct type 'User'
```

**EXPR002: Invalid target type for array operator**

```
ArrayItem[User]
          ^^^^ expected array type, found struct type 'User'
```

**EXPR003: Invalid target type for field access**

```
i32::field
^^^ cannot access fields on scalar type 'i32'
```

### Field/Variant Resolution Errors

**EXPR004: Unknown field in selector**

```
Pick[User, nonexistent]
           ^^^^^^^^^^^ field 'nonexistent' not found in struct 'User'
```

**EXPR005: Unknown variant in selector**

```
Exclude[Response, UnknownError]
                  ^^^^^^^^^^^^ variant 'UnknownError' not found in oneof 'Response'
```

**EXPR006: Unknown field in projection**

```
User::nonexistent
      ^^^^^^^^^^^ field 'nonexistent' not found in struct 'User'
```

### Empty Result Errors

**EXPR007: Empty selector list**

```
Pick[User, ]
          ^ expected at least one field selector
```

**EXPR008: No fields remain after Omit**

```
Omit[User, id | name | email]
^^^^^^^^^^^^^^^^^^^^^^^^^^ no fields remain after omitting all fields
```

**EXPR009: No variants remain after Exclude**

```
Exclude[Response, Success | Error]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no variants remain after excluding all variants
```

### Chaining Errors

**EXPR010: Cannot access field on intermediate result**

```
Pick[Omit[User, id], id]
                     ^^ field 'id' not found (was omitted)
```

### Duplicate Selector Warning

**EXPR011: Duplicate selector ignored** (warning)

```
Pick[User, id | name | id]
                       ^^ duplicate selector 'id' ignored
```

## Composition Rules

### Type Expression Nesting

Type expressions nest arbitrarily:

```kintsu
// All valid:
Partial[Pick[User, id | name]]
Pick[Partial[User], id | name]
Required[Omit[Partial[User], password_hash]]
ArrayItem[Pick[User, tags]::tags]
```

**Evaluation:** Inner expressions evaluate before outer expressions.

### Composition with Union (`&`)

Type expressions compose with struct union:

```kintsu
type Extended = Pick[User, id] & Timestamps;
// Pick resolves first, then union applies
```

**Precedence:** Type expressions have higher precedence than union operators.

### Composition with OneOf (`|`)

Type expressions compose with oneof:

```kintsu
type Result = Extract[Response, Success] | DefaultSuccess;
// Extract resolves first, then oneof applies
```

### Composition with Union Or (`&|`)

Type expressions compose with union or:

```kintsu
type Merged = Partial[A] &| Partial[B];
// Both Partial resolve first, then union or applies
```

### Operator Precedence

From highest to lowest:

1. `::` (field access)
2. Type expression operators (`Pick`, `Omit`, etc.)
3. `&` (union)
4. `|` (oneof)
5. `&|` (union or)

**Explicit Grouping:** Use nested expressions for explicit precedence.

## Versioning Rules

Type expressions inherit versioning from their context:

1. Type expressions in type aliases inherit the alias's version scope
2. Versioned field removal affects type expressions:
   - `Pick[User@1.0, deprecated_field]` errors if field removed
   - `Omit[User@2.0, old_field]` errors if field doesn't exist in 2.0
3. No version expression syntax within type expressions themselves

## Implementation Notes

### Parser Requirements

Parsers MUST:

- Recognize all operator keywords in type expression context
- Parse bracket-delimited operator arguments
- Parse pipe-separated selector lists
- Parse chained `::` projections
- Handle nested type expressions

### Type Checker Requirements

Type checkers MUST:

- Resolve target types before applying operators
- Validate selector existence on resolved types
- Check for empty results
- Track optionality through transformations
- Preserve metadata through transformations

### Compiler Requirements

Compilers MUST:

- Fully resolve type expressions before code generation
- Generate the same code for manually-defined and expression-derived types
- Report clear errors with source locations for invalid expressions

## References

- [RFC-0018](/specs/rfc/RFC-0018) - Type Expression Design
- [TSY-0006](/specs/tsy/TSY-0006) - Type Aliases
- [TSY-0007](/specs/tsy/TSY-0007) - Union Types
- [TSY-0008](/specs/tsy/TSY-0008) - OneOf Types
- [TSY-0013](/specs/tsy/TSY-0013) - Union Or Types
- [SPEC-0017](/specs/spec/SPEC-0017) - Type Expression Compilation
