---
author: joshua-auchincloss
components:
  - compiler
created: 2025-10-30
kind: AD
number: 1
status: draft
title: Type Resolution Architecture
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
  - author: joshua-auchincloss
    date: 2025-12-24
    description: Updated specification
version_after: 0.1.0
version_before: null
---

# AD-0001: Type Resolution Architecture

## Overview

This architecture document defines the high-level design of the type resolution system in Kintsu compilers. The system implements an eight-phase resolution pipeline that transforms raw parsed AST types into fully resolved, validated type definitions ready for code generation. The architecture emphasizes deterministic execution, clear phase boundaries, and structured output aggregation.

## Motivation

Compilers must resolve complex type interdependencies in a predictable, maintainable way. Key architectural requirements:

1. **Deterministic resolution**: Same input always produces same output
2. **Clear phase boundaries**: Each phase has well-defined responsibilities
3. **Structured output**: Results organized for easy consumption by codegen
4. **Error isolation**: Failures traced to specific phases
5. **Parallel-friendly**: Per-namespace isolation enables concurrent resolution

## Architecture

### Core Components

#### TypeResolver

The `TypeResolver` is the main orchestrator that executes all eight phases sequentially:

**Structure** (from `parser/src/ctx/resolve/mod.rs`):

```rust
pub struct TypeResolver {
    namespace: Arc<Mutex<NamespaceCtx>>,
    resolution: NamespaceResolution,
}

impl TypeResolver {
    pub fn new(namespace: Arc<Mutex<NamespaceCtx>>) -> Self {
        Self {
            namespace,
            resolution: NamespaceResolution::new(),
        }
    }

    pub async fn resolve(mut self) -> Result<NamespaceResolution> {
        self.anonymous_structs().await?;    // Phase 1
        self.identify_unions().await?;      // Phase 2
        self.resolve_type_aliases().await?; // Phase 3
        self.validate_unions().await?;      // Phase 4
        self.merge_unions().await?;         // Phase 5
        self.resolve_versions().await?;     // Phase 6
        self.resolve_error_types().await?;  // Phase 7
        self.validate_all_references().await?; // Phase 8

        Ok(self.resolution)
    }
}
```

**Responsibilities**:

- Execute eight phases in order
- Accumulate results in `NamespaceResolution`
- Propagate errors with phase context
- Provide access to namespace context

#### NamespaceResolution

Output aggregation structure that collects artifacts from each phase:

**Structure** (from `parser/src/ctx/resolve/mod.rs`):

```rust
#[derive(Default)]
pub struct NamespaceResolution {
    pub anonymous_structs: Vec<SourceSpanned<StructDef>>,    // Phase 1 output
    pub identified_unions: Vec<Spanned<UnionRecord>>,        // Phase 2 output
    pub union_structs: Vec<SourceSpanned<StructDef>>,        // Phase 5 output
    pub resolved_aliases: BTreeMap<String, Spanned<Type>>,   // Phase 3 output
    pub versions: BTreeMap<String, Spanned<u32>>,            // Phase 6 output
    pub errors: BTreeMap<String, Spanned<String>>,           // Phase 7 output
    // Phases 4 and 8 are validation-only (no outputs)
}
```

**Purpose**:

- Centralized storage for phase outputs
- Provides artifacts to code generators
- Enables inspection of resolution results
- Supports incremental resolution (future)

#### NamespaceCtx

Input context containing parsed namespace with types, operations, and metadata:

**Structure** (from `parser/src/ctx/namespace.rs`):

```rust
pub struct NamespaceCtx {
    pub ctx: RefContext,
    pub sources: BTreeMap<PathBuf, Arc<String>>,
    pub comments: Vec<FromNamedSource<CommentStream>>,
    pub error: Option<FromNamedSource<ErrorMeta>>,
    pub version: Option<FromNamedSource<VersionMeta>>,
    pub namespace: FromNamedSource<NamespaceDef>,
    pub imports: Vec<FromNamedSource<RefOrItemContext>>,
    pub children: BTreeMap<NamedItemContext, FromNamedSource<NamespaceChild>>,
    pub(crate) registry: TypeRegistry,
    pub resolved_versions: BTreeMap<String, Spanned<u32>>,
    pub resolved_errors: BTreeMap<String, Spanned<String>>,
}

pub enum NamespaceChild {
    Struct(StructItem),
    Enum(EnumItem),
    OneOf(OneOfItem),
    Type(TypeAliasItem),
    Error(ErrorItem),
    Operation(OperationItem),
    Namespace(NamespaceItem),
}
```

**Purpose**:

- Provides raw parsed types to phases
- Contains namespace-level metadata
- Exposes type registry for lookups
- Represents hierarchical namespace structure

### Phase Pipeline

The eight phases form a sequential pipeline with strict dependencies:

![Type Resolution Architecture](../../../../diagrams/type_resolution_architecture.png)

![Phase Ordering](../../../../diagrams/phase_ordering.png)

### Module Organization

Resolution logic is organized into focused modules:

**Module structure** (in `parser/src/ctx/resolve/`):

- `mod.rs` - TypeResolver orchestration, phase execution
- `anonymous.rs` - Phase 1: Anonymous struct extraction
- `unions.rs` - Phases 2, 4, 5: Union identification, validation, merging
- `aliases.rs` - Phase 3: Type alias resolution
- `metadata.rs` - Phases 6, 7: Version and error metadata resolution
- `validation.rs` - Phase 8: Type reference validation
- `helpers.rs` - Shared utilities (NameContext, UnionRecord, etc.)

Each module encapsulates one or more related phases, keeping phase logic isolated and testable.

Note: All resolve submodules use `pub(super)` visibility. Only `UnionRecord` is re-exported at the crate level.

#### Helper Structures

**ResolvedTypeRef** (from `parser/src/ctx/resolve/mod.rs`):

Tracks type references through resolution, preserving both original and resolved forms:

```rust
pub struct ResolvedTypeRef {
    pub original: Arc<Spanned<Type>>,
    pub resolved: Arc<Spanned<Type>>,
    pub path: NamedItemContext,
}
```

**UnionRecord** (from `parser/src/ctx/resolve/helpers.rs`):

Tracks union definitions during identification and merging:

```rust
pub struct UnionRecord {
    pub union_ref: Arc<Spanned<Union>>,
    pub context_stack: Vec<String>,
    pub in_oneof: bool,
    pub variant_index: Option<usize>,
}
```

**AliasEntry** (from `parser/src/ctx/resolve/helpers.rs`):

Tracks alias definitions for dependency resolution and cycle detection:

```rust
pub struct AliasEntry {
    pub target_type: Spanned<Type>,
    pub source: PathBuf,
    pub dependencies: Vec<String>,
}
```

**UnionWorkingSet** (from `parser/src/ctx/resolve/helpers.rs`):

Accumulates merged fields during union struct generation:

```rust
pub struct UnionWorkingSet {
    fields: BTreeMap<String, (SourceSpanned<Arg>, Option<Spanned<Token![,]>>)>,
}
```

**NameContext** (from `parser/src/ctx/resolve/helpers.rs`):

Tracks hierarchical name context for generated type naming:

```rust
pub struct NameContext {
    pub stack: Vec<String>,
}
```

### Error Handling

Errors are reported with phase context and source locations:

**Error propagation**:

- Each phase returns `Result<T, Error>`
- Errors include source spans from original code
- Phase failures stop pipeline immediately (fail-fast)
- Error messages reference specific phase for debugging

**Example error flow**:

```
Phase 4 validation fails
    ↓
Union validation error
    ↓
"Union members must be struct types"
    ↓
Stop pipeline, return error with span
```

### Concurrency Model

**Per-namespace sequential**: Each namespace executes all eight phases sequentially

**Cross-namespace parallel**: Different namespaces resolve concurrently

```
Namespace A: Phase 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8
Namespace B: Phase 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8  (parallel)
Namespace C: Phase 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8  (parallel)
```

**Synchronization**: No shared mutable state between namespaces during resolution (each has isolated `TypeResolver`).

## Design Principles

1. **Phase isolation**: Each phase has single responsibility, operates on well-defined inputs
2. **Sequential correctness**: Phase ordering guarantees correctness by construction
3. **Explicit dependencies**: Phase inputs/outputs make dependencies visible
4. **Fail-fast validation**: Validation phases detect errors early
5. **Output aggregation**: All results collected in `NamespaceResolution` for unified access
6. **Error attribution**: Errors traced to specific phases for clear diagnostics

## Implications

### For Compiler Implementers

- Must implement all eight phases in order
- Must use `TypeResolver::resolve()` to execute pipeline
- Must handle `NamespaceResolution` output structure
- Can parallelize across namespaces, not within

### For Code Generators

- Receive fully resolved types via `NamespaceResolution`
- Can assume all references validated (Phase 8)
- Can access generated types (anonymous structs, unions)
- Can retrieve metadata (versions, errors)

### For Debugging

- Phase boundaries provide checkpoints
- Can inspect `NamespaceResolution` after each phase
- Errors reference specific phases
- Can add logging at phase transitions

### For Testing

- Each phase testable in isolation
- Can verify phase outputs independently
- Integration tests verify full pipeline
- Can mock `NamespaceCtx` for phase testing

### For Future Extensions

- New phases can be inserted at appropriate points
- Phase outputs extensible via `NamespaceResolution`
- Can add parallel sub-phases within phases
- Can optimize individual phases independently

## References

- [RFC-0013](/specs/rfc/rfc-0013) - Type Resolution Design
- [SPEC-0013](/specs/spec/spec-0013) - Type Resolution Phases (detailed implementation)
- [RFC-0003](/specs/rfc/rfc-0003) - Anonymous Structs
- [RFC-0007](/specs/rfc/rfc-0007) - Union Types
- [RFC-0006](/specs/rfc/rfc-0006) - Type Aliases
- [RFC-0012](/specs/rfc/rfc-0012) - Metadata System
