---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: SPEC
number: 18
status: draft
title: Package Manifest Implementation
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0018: Package Manifest Implementation

## Overview

This specification defines the compiler implementation for parsing and validating package manifests (`schema.toml`) as specified in [RFC-0019](/specs/rfc/RFC-0019).

## Motivation

The package manifest is the entry point for schema compilation. Correct parsing and validation ensures:

- Clear error messages for malformed manifests
- Consistent dependency resolution behavior
- Forward-compatible version handling

## Architecture

### Versioned Envelope

The manifest uses a tagged enum pattern for version discrimination. The root-level `version` field determines which inner structure to deserialize. Currently only `v1` is defined.

This pattern enables schema evolution: new versions can introduce breaking changes while older compilers gracefully handle unknown versions.

### Core Data Model

The manifest contains three top-level sections:

**PackageManifest** is the root structure containing:

- `package` - Package metadata (required)
- `dependencies` - Map of dependency name to dependency specification (optional, defaults to empty)
- `files` - File configuration (optional, defaults to empty)

**PackageMeta** contains identity and descriptive fields:

- `name` - Package name (required, validated)
- `version` - Semantic version (required, validated)
- `description` - Package description (optional)
- `authors` - Array of author objects with `name` and `email` fields (optional)
- `repository`, `homepage` - URL strings (optional)
- `keywords` - Array of keyword strings (optional)
- `license` - SPDX license identifier (optional)
- `license_text` - Full license text or expanded identifier (optional)
- `readme` - Inline content string or file path (optional)

**FileConfig** contains compilation settings:

- `exclude` - Array of glob patterns relative to `schema/` directory

### Package Name Validation

Package names are validated during deserialization with these rules:

- Minimum length of 2 characters
- Must match the pattern: starts with lowercase letter, followed by lowercase letters, digits, or hyphens, ends with lowercase letter or digit
- Pattern expressed as regex: `[a-z]([a-z0-9\-]*)[a-z0-9]`

Names are converted to snake_case by compilers for namespace matching by replacing hyphens with underscores.

### Dependency Resolution

Dependencies support four source types, determined by which fields are present:

**Path dependency**: Only `path` field present. Resolved relative to manifest location.

**Git dependency**: Has `git` field with optional `branch`, `tag`, or `rev`. Only one reference type allowed. If none specified, uses default branch.

**Registry dependency**: Has `version` field with optional `registry`. If registry omitted, uses default registry from user config.

**Path with remote fallback**: Has both `path` and `version` fields. Uses path for local development, version constraint for registry resolution.

The simple string syntax (e.g., `dep = "^1.0"`) is shorthand for registry dependency with version requirement.

### Validation Requirements

**At parse time:**

- TOML syntax must be valid
- Version field must be present and known (or emit warning for unknown)
- Required fields must be present

**During deserialization:**

- Package name must pass regex validation
- Version must be valid semver
- URL fields must be parseable
- Version requirements must follow semver syntax

**During dependency resolution:**

- Each dependency must have exactly one source type (path, git, or registry)
- Git dependencies cannot have multiple reference types (branch/tag/rev)
- Path dependencies must point to existing directories

### Version Handling

When the version field is unknown:

1. Emit a warning with the unknown version value
2. Attempt to parse as the latest known version (v1)
3. If parsing fails, report error with the unknown version

This enables forward compatibility: older compilers can attempt to read newer manifests.

### Schema Context Integration

The manifest is the first artifact loaded during compilation. After successful parsing:

1. Extract expected root namespace name from package name (converted to snake_case)
2. Load `schema/lib.ks` entry point
3. Verify the declared namespace matches the package name
4. Process `use` statements to discover additional namespaces

## Design Principles

### Strict Validation

All fields are validated during deserialization. Invalid data fails early with clear error messages rather than propagating through the system.

### Graceful Degradation

Unknown fields are silently ignored, enabling forward compatibility. Newer manifests with additional fields remain readable by older compilers.

### Clear Error Messages

Validation errors should include:

- File path where the error occurred
- Expected vs actual values where applicable
- Suggestions for common mistakes

## Implications

### Performance

Manifest parsing is synchronous and happens once per compilation. The small file size makes this negligible.

### Security

URL validation prevents injection attacks. Path traversal is checked during dependency resolution to prevent escaping the project directory.

### Extensibility

The version envelope pattern allows breaking changes in future versions. New optional fields can be added to v1 without version bump.

## References

- [RFC-0019](/specs/rfc/RFC-0019) - Package Manifest Format
- [SPEC-0019](/specs/spec/SPEC-0019) - Lockfile Implementation
