---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: SPEC
number: 16
status: draft
title: Variant Tagging Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Enhanced code blocks with expressive-code markers
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0016: Variant Tagging Compilation

## Overview

This SPEC documents the compiler's deterministic behavior for parsing, validating, and applying variant tagging attributes. It specifies attribute parsing, validation phases, inheritance resolution, name normalization, and metadata propagation to code generators. This SPEC is normative for implementers who must reproduce the compiler's tagging behavior.

## Motivation

Code generators rely on consistent tagging metadata to produce correct serialization code. This SPEC records the precise algorithms for attribute parsing, validation ordering, and metadata propagation so implementations produce identical outputs for the same source schemas. The validation phases and error messages are critical for developer experience.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

### Compilation phases

Tagging compilation occurs across multiple phases:

| Phase | Name                   | Tagging Actions                                     |
| ----- | ---------------------- | --------------------------------------------------- |
| 1     | Parsing                | Parse `#[tag(...)]` and `#[rename(...)]` attributes |
| 2     | Attribute validation   | Validate attribute syntax and parameter types       |
| 3     | Type resolution        | Resolve type references in variant types            |
| 4     | Inheritance resolution | Resolve namespace-to-type inheritance               |
| 5     | Constraint validation  | Validate tagging constraints per style              |
| 6     | Metadata propagation   | Attach resolved tagging to type metadata            |

### Phase 1: Attribute parsing

The parser recognizes tagging attributes on namespaces, types, and variants.

**Grammar (EBNF):**

```ebnf
tag_attribute    = "#[" "tag" "(" tag_params ")" "]" ;
inner_tag_attr   = "#![" "tag" "(" tag_params ")" "]" ;
rename_attribute = "#[" "rename" "(" string_literal ")" "]" ;

tag_params       = tag_style | tag_style "," tag_modifiers | type_hint_param ;
tag_style        = "external"
                 | "untagged"
                 | "index"
                 | named_params ;
named_params     = "name" "=" string_literal [ "," "content" "=" string_literal ] ;
tag_modifiers    = "type_hint" [ "=" boolean ] ;
type_hint_param  = "type_hint" "=" boolean ;
boolean          = "true" | "false" ;
```

**Parsed AST representation:**

```rust
pub enum TagStyle {
    #[default]
    TypeHint,       // Default: untagged + @kintsu field
    External,
    Internal { name: String },
    Adjacent { name: String, content: String },
    Untagged,       // Also reached via type_hint = false
    Index { name: Option<String> },
}

pub struct TagAttribute {
    pub style: TagStyle,
    pub type_hint: bool,  // false when type_hint = false is specified
}

pub struct RenameAttribute {
    pub name: String;
}
```

> [!NOTE]
> When `type_hint = false` is specified without another style, the resolved style is `Untagged`. Type hint tagging is conceptually untagged + the `@kintsu` discriminator.

### Phase 2: Attribute validation

Validate attribute syntax and parameter correctness.

**Validation rules:**

1. **Parameter types**: `name` and `content` must be string literals
2. **Required parameters**: Adjacent tagging requires both `name` and `content`
3. **Exclusive styles**: Only one tagging style per attribute
4. **Placement**: `#[tag(...)]` only on variant types; `#[rename(...)]` only on variants

**Error examples:**

```kintsu del={1}
#[tag(name = 42)]  // ERROR: expected string literal
```

**Error:** `attribute 'tag' parameter 'name' must be a string literal`

```kintsu del={1}
#[tag(external, internal)]  // ERROR: multiple styles
```

**Error:** `attribute 'tag' specifies multiple tagging styles`

```kintsu del={2}
#[tag(name = "kind")]
struct User { ... }  // ERROR: not a variant type
```

**Error:** `attribute 'tag' can only be applied to oneof or error types`

### Phase 3: Type resolution

Resolve type references within variant types. This phase is prerequisite to constraint validation.

**For each variant type:**

1. If named type, resolve to registered type definition
2. If anonymous struct, mark for extraction (Phase 1 of standard compilation)
3. If builtin, mark as primitive variant
4. If array, recursively resolve element type

### Phase 4: Inheritance resolution

Resolve tagging attributes from namespace to type level.

**Resolution order:**

1. Check for a `#[tag(...)]` attribute directly on the type
2. Walk up the namespace hierarchy looking for `#![tag(...)]` inner attributes
3. If no attribute found, use the global default (type_hint tagging)

The first matching attribute wins—type-level attributes override namespace-level, and closer namespaces override parent namespaces.

**Inheritance example:**

```kintsu
namespace api {
    #![tag(name = "kind")]  // Namespace default: internal tagging

    struct X { value: i32 };
    struct Y { message: str };
    struct P { count: i64 };
    struct Q { items: str[] };

    type A = oneof X | Y;   // Inherits: internal, name="kind"

    #[tag(external)]        // Type override
    type B = oneof P | Q;   // Uses: external
};
```

**Resolved attributes:**

- `A`: `TagAttribute { style: Internal("kind"), type_hint: false }`
- `B`: `TagAttribute { style: External, type_hint: false }`

**Serialized outputs:**

```json
// Type A (inherited internal tagging)
{ "kind": "x", "value": 42 }
{ "kind": "y", "message": "hello" }

// Type B (type-level external override)
{ "p": { "count": 100 } }
{ "q": { "items": ["a", "b", "c"] } }
```

### Phase 5: Constraint validation

Validate tagging constraints based on resolved style.

#### Internal tagging validation

Internal tagging requires that the tag field can be inserted into the variant content. The compiler validates:

1. **Struct variants**: No field may have the same name as the tag field
2. **Tuple variants**: The referenced type must be a struct (to allow field insertion)
3. **Unit variants**: Always valid (serializes as just the tag field)

**Error cases:**

```kintsu
#[tag(name = "type")]
type Response = oneof {
    type: str,  // Conflict
    data: str
} | Error;
```

**Error:** `internal tag field 'type' conflicts with variant field of same name at variant 0`

#### Adjacent tagging validation

Adjacent tagging requires that the tag field name and content field name are different. The compiler rejects configurations where both parameters have the same value.

#### Untagged validation

Untagged oneofs require that variants can be distinguished by their structure alone. The compiler validates:

1. **No duplicate types**: The same type cannot appear as multiple variants
2. **Struct distinguishability**: Struct variants must have different field signatures (at least one required field must differ in name or type)

**Distinguishability criteria:**

Two struct variants are distinguishable if they differ in at least one required field. The compiler compares the set of required field names and types—if they match exactly, the variants are indistinguishable.

> [!WARNING]
> Struct distinguishability validation is conservative. Some schemas may pass compile-time validation but cause runtime ambiguity during deserialization.

### Phase 6: Metadata propagation

Attach resolved tagging metadata to type definitions for code generators.

**Metadata structure:**

```rust
pub struct VariantTaggingMetadata {
    pub style: TagStyle,
    pub type_hint: bool,
    pub type_hint_path: Option<String>,  // Computed if type_hint=true
    pub variant_names: Vec<VariantNameInfo>,
}

pub struct VariantNameInfo {
    pub source_name: String,      // Original name from source
    pub serialized_name: String,  // After normalization/rename
    pub index: usize,             // Declaration order index
}
```

**Type hint path construction:**

The type hint path is constructed as: `schema::namespace_path::TypeName::v{version}::variant`

1. **Schema name**: The root namespace/schema identifier
2. **Namespace path**: Full path from root to the type's containing namespace, joined with `::`
3. **Type name**: The type's declared name (PascalCase preserved)
4. **Version**: The resolved version prefixed with `v` (from type's `#[version(n)]` or inherited from namespace)
5. **Variant**: The active variant's serialized name (snake_case normalized)

**Version resolution for type hints:**

The version attached to a type hint is resolved through metadata inheritance:

1. If the type has an explicit `#[version(n)]` attribute, use that version
2. Otherwise, inherit from the containing namespace's `#![version(n)]`
3. If no version is specified, default to version `1`

**Versioning guarantees:**

The type hint version establishes a contract: all nested structure within that type is guaranteed by that version. Consumers can rely on:

- The exact set of variants (for oneof/error types)
- The exact shape of each variant's payload
- All transitively referenced types

This is why nested objects do not include their own type hints—the parent's version already guarantees their structure.

### Variant name normalization

The compiler normalizes variant names to snake_case unless a `#[rename(...)]` attribute provides an explicit override.

**Normalization behavior:**

1. If the variant has a `#[rename("...")]` attribute, use the provided string verbatim
2. Otherwise, convert the PascalCase variant name to snake_case

### Index assignment

For index-based tagging, indices are assigned sequentially by declaration order (0-indexed). The first variant is index 0, second is index 1, etc.

> [!IMPORTANT]
> The source declaration order is authoritative. Reordering variants in source changes their indices, which is a breaking change.

### Error type tagging

Error types follow the same tagging rules as oneof types.

**Variant classification:**

| Error Variant  | Tagging Behavior                                         |
| -------------- | -------------------------------------------------------- |
| Struct variant | Fields inlined (internal) or wrapped (adjacent/external) |
| Tuple variant  | Referenced type as content                               |
| Unit variant   | No content; tag only                                     |

**Example:**

```kintsu
namespace api {
    struct DbError {
        code: i32,
        message: str
    };

    #[tag(name = "error")]
    error ApiError {
        Timeout { duration_ms: i64 },  // Struct variant
        Database(DbError),              // Tuple variant
        Unknown                         // Unit variant
    };
};
```

**Serialized outputs (internal tagging):**

```json
// ApiError::Timeout - struct fields inlined with tag
{ "error": "timeout", "duration_ms": 5000 }

// ApiError::Database - DbError fields inlined with tag
{ "error": "database", "code": 1001, "message": "Connection failed" }

// ApiError::Unknown - unit variant, tag only
{ "error": "unknown" }
```

**With type_hint tagging (default):**

```json
// ApiError::Timeout
{
  "@kintsu": "api::api::ApiError::v1::timeout",
  "duration_ms": 5000
}

// ApiError::Database
{
  "@kintsu": "api::api::ApiError::v1::database",
  "code": 1001,
  "message": "Connection failed"
}

// ApiError::Unknown
{
  "@kintsu": "api::api::ApiError::v1::unknown"
}
```

**With external tagging `#[tag(external)]`:**

```json
// ApiError::Timeout
{ "timeout": { "duration_ms": 5000 } }

// ApiError::Database
{ "database": { "code": 1001, "message": "Connection failed" } }

// ApiError::Unknown
{ "unknown": null }
```

**With adjacent tagging `#[tag(tag = "type", content = "data")]`:**

```json
// ApiError::Timeout
{ "type": "timeout", "data": { "duration_ms": 5000 } }

// ApiError::Database
{ "type": "database", "data": { "code": 1001, "message": "Connection failed" } }

// ApiError::Unknown
{ "type": "unknown" }
```

### Union Or (`&|`) tagging compilation

When processing `&|` expressions, the compiler generates oneof types for conflicting fields. These generated oneofs receive tagging metadata through inheritance.

**Compilation flow:**

1. During `&|` resolution, identify conflicting fields
2. For each conflict, create an anonymous oneof with the distinct types as variants
3. Resolve tagging for the generated oneof using the standard inheritance rules (namespace default or global default)
4. Assign variant names from the operand type names

**Variant naming for generated oneofs:**

| Operand Type             | Variant Name                                 |
| ------------------------ | -------------------------------------------- |
| Builtin (i32, str, etc.) | The type name itself (`i32`, `str`)          |
| Named struct             | The struct name in snake_case                |
| Anonymous struct         | Generated name per TSY-0008 extraction rules |

**Example compilation:**

```kintsu
namespace api {
    #![tag(name = "t")]

    struct Foo { val: i32, name: str };
    struct Bar { val: str, name: str };

    type Combined = Foo &| Bar;
};
```

The compiler generates a union struct with an anonymous oneof for the conflicting `val` field:

```kintsu
// Compiler-generated intermediate representation
struct Combined {
    val: oneof i32 | str,  // Conflict resolution
    name: str              // Unified non-conflicting field
};
```

**Serialized outputs:**

```json
// Combined with val: i32 (from Foo-like source)
{
    "val": { "t": "i32", "value": 42 },
    "name": "example"
}

// Combined with val: str (from Bar-like source)
{
    "val": { "t": "str", "value": "hello" },
    "name": "example"
}
```

**With type_hint tagging (global default):**

```kintsu
namespace api {
    // No #![tag(...)] attribute - type_hint is default

    struct Foo { val: i32, active: bool };
    struct Bar { val: str, active: bool };

    type Combined = Foo &| Bar;
};
```

```json
// Combined with val: i32 - no nested type hints for union_or fields
{
    "@kintsu": "api::api::Combined::v1",
    "val": 42,
    "active": true
}

// Combined with val: str
{
    "@kintsu": "api::api::Combined::v1",
    "val": "hello",
    "active": true
}
```

> [!NOTE]
> Union or generated oneofs do not include nested type hints. The variant is distinguishable by its structure.

### Code generator interface

Code generators receive resolved tagging metadata via the type registry.

**Query interface:**

```rust
impl TypeRegistry {
    pub fn get_tagging(&self, type_id: TypeId) -> Option<&VariantTaggingMetadata>;
    pub fn get_variant_name(&self, type_id: TypeId, variant_idx: usize) -> &str;
    pub fn get_variant_index(&self, type_id: TypeId, variant_name: &str) -> Option<usize>;
}
```

**Generator responsibilities:**

1. Query tagging metadata for each variant type
2. Generate serialization code matching the tagging style
3. Generate deserialization code with appropriate discriminant handling
4. Include type hint field if `type_hint` is enabled

### Diagnostic messages

The compiler emits specific error messages for tagging issues.

| Error Code | Message                                                           | Phase |
| ---------- | ----------------------------------------------------------------- | ----- |
| E0401      | `attribute 'tag' parameter 'name' must be a string literal`       | 2     |
| E0402      | `attribute 'tag' specifies multiple tagging styles`               | 2     |
| E0403      | `attribute 'tag' can only be applied to oneof or error types`     | 2     |
| E0404      | `internal tag field '{name}' conflicts with variant field`        | 5     |
| E0405      | `adjacent tag field and content field must have different names`  | 5     |
| E0406      | `untagged oneof contains duplicate variant types`                 | 5     |
| E0407      | `untagged oneof contains structurally indistinguishable variants` | 5     |
| E0408      | `internal tagging requires struct content, found {kind}`          | 5     |

## References

- [RFC-0017](/specs/rfc/RFC-0017) - Variant Tagging Design
- [TSY-0013](/specs/tsy/TSY-0013) - Variant Tagging Rules
- [RFC-0008](/specs/rfc/RFC-0008) - OneOf Type Design
- [RFC-0005](/specs/rfc/RFC-0005) - Error Type Design
- [RFC-0012](/specs/rfc/RFC-0012) - Metadata System
- [SPEC-0008](/specs/spec/SPEC-0008) - OneOf Compilation
- [SPEC-0005](/specs/spec/SPEC-0005) - Error Compilation
