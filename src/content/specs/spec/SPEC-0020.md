---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: SPEC
number: 20
status: draft
title: Declaration Bundle Implementation
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0020: Declaration Bundle Implementation

## Overview

This specification defines the compiler implementation for generating and consuming declaration bundles as specified in [RFC-0021](/specs/rfc/RFC-0021).

## Motivation

The declaration bundle is the interchange format between:

- Compiler and registry (publishing)
- Registry and consumers (downloading)
- Compiler and code generators (output)

Correct implementation ensures type fidelity across the toolchain.

## Architecture

### Versioned Envelope

The declaration bundle uses a versioned wrapper with adjacently-tagged serialization. The `version` field contains the version identifier and the `declarations` field contains the bundle content. Currently only `v1` is defined.

### Core Data Model

**DeclarationBundle** is the top-level structure:

- `root` - The type registry declaration for this package
- `dependencies` - Map of dependency names to their type registry declarations (optional, for bundled dependencies)

**TypeRegistryDeclaration** represents a package's type information:

- `package` - Package name
- `namespaces` - Map of qualified namespace names to namespace declarations
- `external_refs` - Array of external type references (enables dependency tracking)

**DeclNamespace** represents a single namespace:

- `version` - Namespace version number (from source)
- `error` - Optional namespace-level error type name
- `types` - Array of type definitions

### Type Definitions

Type definitions use a `definition_type` field to indicate the kind. The type-specific data is nested under a wrapper field (`struct_def`, `enum_def`, etc.):

**Struct** (`definition_type: "struct"`): Named product type with fields. The `struct_def` object contains name, optional doc, attributes array, and fields array. Each field has name, structured `ty` reference (with `path`, `is_array`, `is_optional`), and `optional` flag.

**Enum** (`definition_type: "enum"`): Discriminated value type. The `enum_def` object contains name, optional doc, and variants array. Each variant has name and value. The repr (representation type) is inferred from variant values.

**Oneof** (`definition_type: "oneof"`): Sum type with variants. The `oneof_def` object contains name, optional doc, attributes array, and variants array. Each variant has name, kind (unit/struct/tuple), optional fields array for struct variants, and optional elements array for tuple variants.

**Error** (`definition_type: "error"`): Error type similar to oneof. The `error_def` object contains name, optional doc, and variants array where each variant has name, kind, and optional fields.

**Operation** (`definition_type: "operation"`): RPC-style operation. The `operation_def` object contains name, optional doc, attributes array, params array, and returns structure. The returns structure has ok type and optional err type.

**Alias** (`definition_type: "alias"`): Type alias. The `alias_def` object contains name, optional doc, and target type reference.

### Type Reference Structure

Type references use a structured object rather than strings:

- `path` - The type path (e.g., `"str"`, `"SomeType"`, `"dep::ns::Type"`)
- `is_array` - Boolean indicating if this is an array type
- `is_optional` - Boolean indicating if this is an optional type

This explicit structure avoids ambiguity in parsing complex type annotations.

### Generation Process

Bundle generation proceeds through these stages:

**Span stripping**: Source location information (line/column/file) is removed from the AST. The bundle contains only semantic information, not source structure.

**Definition collection**: Each namespace's type definitions are converted from AST nodes to declaration structures. The conversion preserves name, documentation, attributes, and type information while discarding spans. Types are collected into the `types` array.

**External tracking**: When a type references a type from another package, that path is recorded in the `external_refs` array. This enables consumers to know what dependencies are required.

**Bundle assembly**: The namespace declarations are collected into a type registry declaration (with `package` field), which is wrapped in the versioned envelope with `meta` containing the format version.

### JSON Serialization

Bundles are serialized as JSON. For checksum computation, canonical JSON is used:

- Object keys are sorted alphabetically (use ordered maps internally)
- No extraneous whitespace
- Consistent number formatting

This ensures identical content produces identical checksums regardless of how the JSON was originally formatted.

### Bundle Loading

Loading a bundle:

1. Read JSON file content
2. Deserialize the versioned envelope
3. Extract version and dispatch to appropriate handler
4. Unwrap to get the inner DeclarationBundle

Unknown versions should produce an error indicating the version is not supported.

### Type Resolution

Given a type reference object, resolution proceeds:

1. Parse the `path` field by splitting on `::`
2. Extract package name (first component if multi-part, convert underscores to hyphens for matching)
3. Extract type name (last component)
4. Extract namespace path (middle components if present)
5. Look up the package: root if it matches root `package` name, otherwise search dependencies
6. Look up the namespace in that package
7. Search `types` array for matching type name by inspecting the type-specific definition object

### Validation Requirements

**During generation:**

- No duplicate type names within a namespace
- All type references must resolve (either local or declared external)
- Alias chains must not be circular

**During loading:**

- JSON must be syntactically valid
- Version field must be present and known
- Required fields must be present in all structures

**During consumption:**

- External types must be resolvable in dependency bundles
- Type reference strings must be parseable

## Design Principles

### No Source Information

Bundles contain only type information. No file paths, line/column numbers, or source text. This ensures smaller file sizes, stable checksums across reformats, and no internal structure leakage.

### Complete Type Information

All semantic information is preserved: documentation comments, attributes and metadata, type relationships, and namespace structure. Consumers have everything needed for code generation without accessing source files.

### Deterministic Output

Generation is deterministic. Ordered maps produce sorted keys. JSON formatting is consistent. Type reference strings follow stable patterns. This enables reliable checksums and diff-friendly output.

## Implications

### Code Generation

Code generators consume bundles directly. They have no parser dependency, receive language-agnostic input, and work through a consistent interface regardless of source language features.

### Registry Integration

Bundles are the registry's native format. Packages are published as bundles. The registry can index by type names and provide searchable metadata.

### Tooling Ecosystem

IDEs and tools use bundles for type completion, documentation lookup, and dependency analysis without needing to parse Kintsu source.

## References

- [RFC-0021](/specs/rfc/RFC-0021) - Declaration Bundle Format
- [SPEC-0018](/specs/spec/SPEC-0018) - Package Manifest Implementation
- [SPEC-0019](/specs/spec/SPEC-0019) - Lockfile Implementation
