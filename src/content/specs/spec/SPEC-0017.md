---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: SPEC
number: 17
status: draft
title: Type Expression Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0017: Type Expression Compilation

## Abstract

This specification defines the compiler implementation for type expressions in Kintsu. It covers parsing grammar, AST representation, semantic analysis, resolution algorithms, and error handling. Type expressions are compile-time constructs that derive new types from existing types through transformation operators.

## Scope

This specification covers:

- Lexical tokens for type expressions
- Grammar productions
- AST node definitions
- Resolution algorithm
- Validation passes
- Error message catalog

## Lexical Elements

### Reserved Keywords

The following identifiers are reserved as type expression operators:

```
Pick
Omit
Partial
Required
Exclude
Extract
ArrayItem
```

These keywords are reserved only in type expression context. Outside type expressions, they remain valid identifiers.

### Tokens

| Token          | Pattern             | Description                        |
| -------------- | ------------------- | ---------------------------------- |
| `LBRACKET`     | `[`                 | Left bracket                       |
| `RBRACKET`     | `]`                 | Right bracket                      |
| `PIPE`         | `\|`                | Pipe separator                     |
| `DOUBLE_COLON` | `::`                | Field access operator              |
| `IDENT`        | `[a-z][a-z0-9_]*`   | Lower-case identifier (field name) |
| `TYPE_IDENT`   | `[A-Z][a-zA-Z0-9]*` | Upper-case identifier (type name)  |

## Grammar

### EBNF Productions

```ebnf
(* Type expression entry point *)
type_expr       = base_type_expr { "::" IDENT } ;

base_type_expr  = struct_op
                | oneof_op
                | array_op
                | type_reference ;

(* Struct operators *)
struct_op       = "Pick" "[" type_expr "," selector_list "]"
                | "Omit" "[" type_expr "," selector_list "]"
                | "Partial" "[" type_expr [ "," selector_list ] "]"
                | "Required" "[" type_expr [ "," selector_list ] "]" ;

(* OneOf operators *)
oneof_op        = "Exclude" "[" type_expr "," variant_list "]"
                | "Extract" "[" type_expr "," variant_list "]" ;

(* Array operators *)
array_op        = "ArrayItem" "[" type_expr "]" ;

(* Selector lists *)
selector_list   = IDENT { "|" IDENT } ;
variant_list    = TYPE_IDENT { "|" TYPE_IDENT } ;

(* Base type reference *)
type_reference  = TYPE_IDENT [ version_suffix ] ;
version_suffix  = "@" VERSION ;
```

### Precedence

The `::` operator binds tighter than any binary type operator:

```
User::profile::avatar       =>  ((User :: profile) :: avatar)
Pick[User, id]::id          =>  (Pick[User, id]) :: id
```

### Associativity

- `::` is left-associative
- Type expression operators are not associative (fully bracketed)

## Abstract Syntax Tree

### Node Definitions

```rust
/// Type expression AST node
enum TypeExpr {
    /// Reference to a named type
    TypeRef {
        name: String,
        version: Option<Version>,
        span: Span,
    },

    /// Field access: T::field
    FieldAccess {
        base: Box<TypeExpr>,
        field: String,
        span: Span,
    },

    /// Pick operator: Pick[T, f1 | f2 | ...]
    Pick {
        target: Box<TypeExpr>,
        fields: Vec<String>,
        span: Span,
    },

    /// Omit operator: Omit[T, f1 | f2 | ...]
    Omit {
        target: Box<TypeExpr>,
        fields: Vec<String>,
        span: Span,
    },

    /// Partial operator: Partial[T] or Partial[T, f1 | f2 | ...]
    Partial {
        target: Box<TypeExpr>,
        fields: Option<Vec<String>>,
        span: Span,
    },

    /// Required operator: Required[T] or Required[T, f1 | f2 | ...]
    Required {
        target: Box<TypeExpr>,
        fields: Option<Vec<String>>,
        span: Span,
    },

    /// Exclude operator: Exclude[T, V1 | V2 | ...]
    Exclude {
        target: Box<TypeExpr>,
        variants: Vec<String>,
        span: Span,
    },

    /// Extract operator: Extract[T, V1 | V2 | ...]
    Extract {
        target: Box<TypeExpr>,
        variants: Vec<String>,
        span: Span,
    },

    /// ArrayItem operator: ArrayItem[T]
    ArrayItem {
        target: Box<TypeExpr>,
        span: Span,
    },
}

/// Source span for error reporting
struct Span {
    file: FileId,
    start: usize,
    end: usize,
}
```

### Parse Tree Construction

The parser constructs AST nodes bottom-up:

1. Parse atomic type references
2. Parse operator brackets if present
3. Parse trailing `::` chains
4. Construct nested `FieldAccess` nodes for chains

**Example:**

Input: `Pick[User, id | name]::id`

AST:

```
FieldAccess {
    base: Pick {
        target: TypeRef { name: "User" },
        fields: ["id", "name"],
    },
    field: "id",
}
```

## Resolution Algorithm

### Overview

Type expression resolution occurs after name resolution but before type checking:

```
Parse -> Name Resolution -> Type Expression Resolution -> Type Checking -> Code Gen
```

### Resolution Context

```rust
struct ResolutionContext {
    /// All defined types in scope
    type_registry: TypeRegistry,

    /// Cache of resolved type expressions
    resolution_cache: HashMap<TypeExprId, ResolvedType>,

    /// Current resolution stack (for cycle detection)
    resolution_stack: Vec<TypeExprId>,

    /// Accumulated errors
    errors: Vec<TypeError>,
}
```

### Resolution Procedure

```rust
fn resolve_type_expr(
    ctx: &mut ResolutionContext,
    expr: &TypeExpr,
) -> Result<ResolvedType, TypeError> {
    // Check cache first
    if let Some(resolved) = ctx.resolution_cache.get(&expr.id()) {
        return Ok(resolved.clone());
    }

    // Check for cycles
    if ctx.resolution_stack.contains(&expr.id()) {
        return Err(TypeError::CyclicTypeExpression(expr.span()));
    }
    ctx.resolution_stack.push(expr.id());

    let result = match expr {
        TypeExpr::TypeRef { name, version, .. } => {
            resolve_type_ref(ctx, name, version)
        }
        TypeExpr::FieldAccess { base, field, .. } => {
            resolve_field_access(ctx, base, field)
        }
        TypeExpr::Pick { target, fields, .. } => {
            resolve_pick(ctx, target, fields)
        }
        TypeExpr::Omit { target, fields, .. } => {
            resolve_omit(ctx, target, fields)
        }
        TypeExpr::Partial { target, fields, .. } => {
            resolve_partial(ctx, target, fields)
        }
        TypeExpr::Required { target, fields, .. } => {
            resolve_required(ctx, target, fields)
        }
        TypeExpr::Exclude { target, variants, .. } => {
            resolve_exclude(ctx, target, variants)
        }
        TypeExpr::Extract { target, variants, .. } => {
            resolve_extract(ctx, target, variants)
        }
        TypeExpr::ArrayItem { target, .. } => {
            resolve_array_item(ctx, target)
        }
    };

    ctx.resolution_stack.pop();

    if let Ok(ref resolved) = result {
        ctx.resolution_cache.insert(expr.id(), resolved.clone());
    }

    result
}
```

### Operator Resolution

#### Pick Resolution

```rust
fn resolve_pick(
    ctx: &mut ResolutionContext,
    target: &TypeExpr,
    fields: &[String],
) -> Result<ResolvedType, TypeError> {
    let resolved_target = resolve_type_expr(ctx, target)?;

    // Validate target is struct
    let struct_type = match resolved_target {
        ResolvedType::Struct(s) => s,
        other => {
            return Err(TypeError::ExpectedStruct {
                found: other.type_name(),
                span: target.span(),
            });
        }
    };

    // Validate all fields exist
    let mut picked_fields = Vec::new();
    let mut seen = HashSet::new();

    for field_name in fields {
        // Check for duplicates
        if !seen.insert(field_name) {
            ctx.warnings.push(Warning::DuplicateSelector {
                name: field_name.clone(),
                span: /* field span */,
            });
            continue;
        }

        // Look up field
        let field = struct_type.fields.get(field_name)
            .ok_or_else(|| TypeError::UnknownField {
                name: field_name.clone(),
                struct_name: struct_type.name.clone(),
                span: /* field span */,
            })?;

        picked_fields.push(field.clone());
    }

    // Validate non-empty
    if picked_fields.is_empty() {
        return Err(TypeError::EmptySelectorList {
            span: /* selector list span */,
        });
    }

    Ok(ResolvedType::Struct(StructType {
        name: generate_anonymous_name(),
        fields: picked_fields,
        metadata: struct_type.metadata.clone(),
    }))
}
```

#### Omit Resolution

```rust
fn resolve_omit(
    ctx: &mut ResolutionContext,
    target: &TypeExpr,
    fields: &[String],
) -> Result<ResolvedType, TypeError> {
    let resolved_target = resolve_type_expr(ctx, target)?;

    let struct_type = match resolved_target {
        ResolvedType::Struct(s) => s,
        other => {
            return Err(TypeError::ExpectedStruct {
                found: other.type_name(),
                span: target.span(),
            });
        }
    };

    // Validate all fields exist
    let omit_set: HashSet<_> = fields.iter().cloned().collect();
    for field_name in &omit_set {
        if !struct_type.fields.contains_key(field_name) {
            return Err(TypeError::UnknownField {
                name: field_name.clone(),
                struct_name: struct_type.name.clone(),
                span: /* field span */,
            });
        }
    }

    // Collect remaining fields
    let remaining_fields: Vec<_> = struct_type.fields.iter()
        .filter(|(name, _)| !omit_set.contains(*name))
        .map(|(_, field)| field.clone())
        .collect();

    // Validate non-empty result
    if remaining_fields.is_empty() {
        return Err(TypeError::NoFieldsRemain {
            struct_name: struct_type.name.clone(),
            span: target.span(),
        });
    }

    Ok(ResolvedType::Struct(StructType {
        name: generate_anonymous_name(),
        fields: remaining_fields,
        metadata: struct_type.metadata.clone(),
    }))
}
```

#### Partial Resolution

```rust
fn resolve_partial(
    ctx: &mut ResolutionContext,
    target: &TypeExpr,
    fields: &Option<Vec<String>>,
) -> Result<ResolvedType, TypeError> {
    let resolved_target = resolve_type_expr(ctx, target)?;

    let struct_type = match resolved_target {
        ResolvedType::Struct(s) => s,
        other => {
            return Err(TypeError::ExpectedStruct {
                found: other.type_name(),
                span: target.span(),
            });
        }
    };

    let make_optional: HashSet<_> = match fields {
        Some(f) => {
            // Validate specified fields exist
            for field_name in f {
                if !struct_type.fields.contains_key(field_name) {
                    return Err(TypeError::UnknownField {
                        name: field_name.clone(),
                        struct_name: struct_type.name.clone(),
                        span: /* field span */,
                    });
                }
            }
            f.iter().cloned().collect()
        }
        None => {
            // All fields
            struct_type.fields.keys().cloned().collect()
        }
    };

    // Transform fields
    let transformed_fields: Vec<_> = struct_type.fields.iter()
        .map(|(name, field)| {
            let mut new_field = field.clone();
            if make_optional.contains(name) {
                new_field.optional = true;
            }
            new_field
        })
        .collect();

    Ok(ResolvedType::Struct(StructType {
        name: generate_anonymous_name(),
        fields: transformed_fields,
        metadata: struct_type.metadata.clone(),
    }))
}
```

#### Required Resolution

```rust
fn resolve_required(
    ctx: &mut ResolutionContext,
    target: &TypeExpr,
    fields: &Option<Vec<String>>,
) -> Result<ResolvedType, TypeError> {
    let resolved_target = resolve_type_expr(ctx, target)?;

    let struct_type = match resolved_target {
        ResolvedType::Struct(s) => s,
        other => {
            return Err(TypeError::ExpectedStruct {
                found: other.type_name(),
                span: target.span(),
            });
        }
    };

    let make_required: HashSet<_> = match fields {
        Some(f) => {
            for field_name in f {
                if !struct_type.fields.contains_key(field_name) {
                    return Err(TypeError::UnknownField {
                        name: field_name.clone(),
                        struct_name: struct_type.name.clone(),
                        span: /* field span */,
                    });
                }
            }
            f.iter().cloned().collect()
        }
        None => {
            struct_type.fields.keys().cloned().collect()
        }
    };

    let transformed_fields: Vec<_> = struct_type.fields.iter()
        .map(|(name, field)| {
            let mut new_field = field.clone();
            if make_required.contains(name) {
                new_field.optional = false;
            }
            new_field
        })
        .collect();

    Ok(ResolvedType::Struct(StructType {
        name: generate_anonymous_name(),
        fields: transformed_fields,
        metadata: struct_type.metadata.clone(),
    }))
}
```

#### Exclude Resolution

```rust
fn resolve_exclude(
    ctx: &mut ResolutionContext,
    target: &TypeExpr,
    variants: &[String],
) -> Result<ResolvedType, TypeError> {
    let resolved_target = resolve_type_expr(ctx, target)?;

    let oneof_type = match resolved_target {
        ResolvedType::OneOf(o) => o,
        other => {
            return Err(TypeError::ExpectedOneOf {
                found: other.type_name(),
                span: target.span(),
            });
        }
    };

    // Validate all variants exist
    let exclude_set: HashSet<_> = variants.iter().cloned().collect();
    for variant_name in &exclude_set {
        if !oneof_type.variants.iter().any(|v| &v.name == variant_name) {
            return Err(TypeError::UnknownVariant {
                name: variant_name.clone(),
                oneof_name: oneof_type.name.clone(),
                span: /* variant span */,
            });
        }
    }

    // Collect remaining variants
    let remaining_variants: Vec<_> = oneof_type.variants.iter()
        .filter(|v| !exclude_set.contains(&v.name))
        .cloned()
        .collect();

    // Validate non-empty result
    if remaining_variants.is_empty() {
        return Err(TypeError::NoVariantsRemain {
            oneof_name: oneof_type.name.clone(),
            span: target.span(),
        });
    }

    // Single variant optimization
    if remaining_variants.len() == 1 {
        return Ok(remaining_variants[0].payload.clone());
    }

    Ok(ResolvedType::OneOf(OneOfType {
        name: generate_anonymous_name(),
        variants: remaining_variants,
        tagging: oneof_type.tagging.clone(),
    }))
}
```

#### Extract Resolution

```rust
fn resolve_extract(
    ctx: &mut ResolutionContext,
    target: &TypeExpr,
    variants: &[String],
) -> Result<ResolvedType, TypeError> {
    let resolved_target = resolve_type_expr(ctx, target)?;

    let oneof_type = match resolved_target {
        ResolvedType::OneOf(o) => o,
        other => {
            return Err(TypeError::ExpectedOneOf {
                found: other.type_name(),
                span: target.span(),
            });
        }
    };

    // Validate and collect specified variants
    let mut extracted_variants = Vec::new();
    let mut seen = HashSet::new();

    for variant_name in variants {
        if !seen.insert(variant_name) {
            ctx.warnings.push(Warning::DuplicateSelector {
                name: variant_name.clone(),
                span: /* variant span */,
            });
            continue;
        }

        let variant = oneof_type.variants.iter()
            .find(|v| &v.name == variant_name)
            .ok_or_else(|| TypeError::UnknownVariant {
                name: variant_name.clone(),
                oneof_name: oneof_type.name.clone(),
                span: /* variant span */,
            })?;

        extracted_variants.push(variant.clone());
    }

    // Single variant optimization
    if extracted_variants.len() == 1 {
        return Ok(extracted_variants[0].payload.clone());
    }

    Ok(ResolvedType::OneOf(OneOfType {
        name: generate_anonymous_name(),
        variants: extracted_variants,
        tagging: oneof_type.tagging.clone(),
    }))
}
```

#### ArrayItem Resolution

```rust
fn resolve_array_item(
    ctx: &mut ResolutionContext,
    target: &TypeExpr,
) -> Result<ResolvedType, TypeError> {
    let resolved_target = resolve_type_expr(ctx, target)?;

    match resolved_target {
        ResolvedType::Array { element, .. } => Ok(*element),
        other => Err(TypeError::ExpectedArray {
            found: other.type_name(),
            span: target.span(),
        }),
    }
}
```

#### Field Access Resolution

```rust
fn resolve_field_access(
    ctx: &mut ResolutionContext,
    base: &TypeExpr,
    field: &str,
) -> Result<ResolvedType, TypeError> {
    let resolved_base = resolve_type_expr(ctx, base)?;

    match resolved_base {
        ResolvedType::Struct(s) => {
            let field_def = s.fields.get(field)
                .ok_or_else(|| TypeError::UnknownField {
                    name: field.to_string(),
                    struct_name: s.name.clone(),
                    span: /* field span */,
                })?;

            // Preserve optionality in the result
            if field_def.optional {
                Ok(ResolvedType::Optional(Box::new(field_def.ty.clone())))
            } else {
                Ok(field_def.ty.clone())
            }
        }

        ResolvedType::OneOf(o) => {
            let variant = o.variants.iter()
                .find(|v| v.name == field)
                .ok_or_else(|| TypeError::UnknownVariant {
                    name: field.to_string(),
                    oneof_name: o.name.clone(),
                    span: /* field span */,
                })?;

            Ok(variant.payload.clone())
        }

        ResolvedType::Error(e) => {
            let variant = e.variants.iter()
                .find(|v| v.name == field)
                .ok_or_else(|| TypeError::UnknownVariant {
                    name: field.to_string(),
                    oneof_name: e.name.clone(),
                    span: /* field span */,
                })?;

            Ok(variant.payload.clone())
        }

        other => Err(TypeError::CannotAccessField {
            found: other.type_name(),
            span: base.span(),
        }),
    }
}
```

## Validation Passes

### Pass 1: Syntactic Validation

During parsing:

- Validate bracket matching
- Validate selector syntax
- Validate identifier casing (fields lowercase, types PascalCase)

### Pass 2: Name Resolution

After parsing, before type expression resolution:

- Resolve all type references
- Report undefined types
- Build dependency graph

### Pass 3: Type Expression Resolution

- Resolve all type expressions
- Validate operator applicability
- Validate selector existence
- Check for empty results
- Detect cycles

### Pass 4: Type Checking

- Verify resolved types are well-formed
- Check composition compatibility
- Propagate metadata

## Error Catalog

### Syntax Errors

| Code    | Message                                     | Cause            |
| ------- | ------------------------------------------- | ---------------- |
| EXPR000 | `expected '[' after operator name`          | Missing bracket  |
| EXPR001 | `expected ']' to close operator`            | Unclosed bracket |
| EXPR002 | `expected identifier in selector list`      | Invalid selector |
| EXPR003 | `expected ',' between target and selectors` | Missing comma    |

### Type Errors

| Code    | Message                              | Cause                      |
| ------- | ------------------------------------ | -------------------------- |
| EXPR004 | `expected struct type, found {type}` | Wrong target for struct op |
| EXPR005 | `expected oneof type, found {type}`  | Wrong target for oneof op  |
| EXPR006 | `expected array type, found {type}`  | Wrong target for ArrayItem |
| EXPR007 | `cannot access fields on {type}`     | Field access on scalar     |

### Resolution Errors

| Code    | Message                                           | Cause                  |
| ------- | ------------------------------------------------- | ---------------------- |
| EXPR008 | `field '{name}' not found in struct '{struct}'`   | Unknown field          |
| EXPR009 | `variant '{name}' not found in oneof '{oneof}'`   | Unknown variant        |
| EXPR010 | `empty selector list not allowed`                 | Empty Pick/Extract     |
| EXPR011 | `no fields remain after omitting all fields`      | Omit leaves nothing    |
| EXPR012 | `no variants remain after excluding all variants` | Exclude leaves nothing |
| EXPR013 | `cyclic type expression detected`                 | Self-referential expr  |

### Warnings

| Code    | Message                                                     | Cause                  |
| ------- | ----------------------------------------------------------- | ---------------------- |
| EXPR014 | `duplicate selector '{name}' ignored`                       | Repeated field/variant |
| EXPR015 | `Partial has no effect on already-optional field '{name}'`  | Redundant Partial      |
| EXPR016 | `Required has no effect on already-required field '{name}'` | Redundant Required     |

## Code Generation

### Generated Type Names

Anonymous types generated by type expressions receive compiler-generated names:

```
__TypeExpr_{hash}
```

Where `{hash}` is a deterministic hash of the type expression's structure and location.

### Structural Equivalence

Structurally equivalent type expressions SHOULD generate the same code:

```kintsu
type A = Pick[User, id | name];
type B = Pick[User, name | id];  // Same fields, different order

// A and B may share the same generated type
```

### Metadata Preservation

Generated types preserve metadata from their source:

- Documentation comments (if applicable)
- Validation attributes on fields
- Serialization hints

## Test Vectors

### Valid Expressions

```kintsu
// Pick with multiple fields
type Test1 = Pick[User, id | name | email];

// Omit single field
type Test2 = Omit[User, password_hash];

// Partial all fields
type Test3 = Partial[User];

// Partial specific fields
type Test4 = Partial[User, email | bio];

// Required all fields
type Test5 = Required[UserInput];

// Required specific fields
type Test6 = Required[UserInput, id];

// Exclude variants
type Test7 = Exclude[ApiResponse, Error];

// Extract variants
type Test8 = Extract[ApiResponse, Success | Pending];

// ArrayItem
type Test9 = ArrayItem[User::tags];

// Field access
type Test10 = User::email;

// Nested field access
type Test11 = User::profile::avatar;

// Nested operators
type Test12 = Partial[Pick[User, name | email]];

// Chained field access after operator
type Test13 = Pick[User, profile]::profile::avatar;
```

### Invalid Expressions (Expected Errors)

```kintsu
// EXPR004: Pick on scalar
type Err1 = Pick[i32, x];

// EXPR005: Exclude on struct
type Err2 = Exclude[User, Admin];

// EXPR006: ArrayItem on non-array
type Err3 = ArrayItem[User];

// EXPR008: Unknown field
type Err4 = Pick[User, nonexistent];

// EXPR010: Empty selector
type Err5 = Pick[User, ];

// EXPR011: No fields remain
type Err6 = Omit[SingleField, only_field];

// EXPR012: No variants remain
type Err7 = Exclude[BinaryChoice, A | B];
```

## References

- [RFC-0018](/specs/rfc/RFC-0018) - Type Expression Design
- [TSY-0014](/specs/tsy/TSY-0014) - Type Expression Rules
- [SPEC-0006](/specs/spec/SPEC-0006) - Type Alias Compilation
- [SPEC-0007](/specs/spec/SPEC-0007) - Union Type Compilation
- [SPEC-0008](/specs/spec/SPEC-0008) - OneOf Type Compilation
