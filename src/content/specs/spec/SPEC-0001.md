---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 1
status: draft
title: Builtin Type Resolution
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0001: Builtin Type Resolution

## Overview

This SPEC defines the deterministic lookup and resolution algorithm the compiler uses to recognise builtin types, the validation expectations during decoding, and the canonical transit parsing requirements for certain builtins (notably `datetime`, `complex`, and `binary`). This document is normative for compiler behaviour. It defines the messaging protocol and compiler resolution behaviour; it does not mandate internal code-generator or runtime representations beyond the canonical transit forms.

## Resolution algorithm (deterministic)

When resolving a type token during parsing/compilation, Kintsu's compiler MUST follow the order below to guarantee deterministic results:

1. If the token is fully-qualified (contains a namespace), resolve against the explicit namespace and its imports.
2. If the token is unqualified (bare name), consult the builtin table first. If the builtin table contains the token, the token resolves to the builtin type and resolution terminates.
3. If not found in builtins, consult the local namespace symbols (types declared in the current file/module).
4. If not found locally, consult imported namespaces in the order they were declared. The first successful match wins.
5. If resolution fails at all levels, emit a `UndefinedType` diagnostic with candidate suggestions (closest lexical matches and imported namespaces where the name appears).

Notes:

- Builtin recognition takes precedence over aliases and imported types to prevent accidental shadowing of primitives.
- The builtin table is authoritative and shipped with the compiler; it can be extended only by changes to the language spec.

## Validation and parsing rules for special builtins

- `datetime`:
  - On ingress (parsing/decoding), the compiler/runtime MUST accept ISO-8601 textual forms with timezone designator. Implementations SHOULD accept common ISO-8601 variants but MUST normalise to a canonical ISO-8601 form when serialising.
  - On transit the `datetime` value is a string. Parsers that receive non-string values for `datetime` MUST emit a `TypeMismatch` diagnostic.

- `complex`:
  - Resolution yields a composite type; the decoder MUST expect an object with numeric fields `real` and `imag`.
  - Missing components or non-numeric fields are `DecodeError` diagnostics.

- `binary`:
  - For binary transports the compiler treats `binary` as raw bytes. For textual transports, `binary` MUST be encoded as Base64; the compiler's textual decoder MUST decode base64 and validate byte sequences.

- `base64`:
  - `base64` is a textual builtin representing raw bytes encoded with Base64 (RFC 4648). On ingress the decoder MUST accept only valid Base64 text and decode to a byte array; invalid base64 must emit `DecodeError`.
  - `base64` resolves as a builtin in step 2 of the resolution algorithm and thus is not shadowable by imports or local aliases.

## Integer wire encoding guidance

The type system permits multiple wire encodings. The SPEC recommends the following:

- For deterministic, simple encodings prefer fixed-size binary encodings (explicit 8/16/32/64-bit widths) and document endianness in the wire/profile.
- For compact encodings, varints or other length-encoded representations are allowed but are considered a wire/profile decision and must be documented and tested. This SPEC requires that wire/profile documentation describe encoding choices; implementations (code generators, runtimes) must not change the canonical transit protocol defined here without corresponding changes to the profile and accompanying migration guidance.

## Examples

1. Resolving `datetime` in an unqualified context binds to builtin `datetime` (step 2 above), not to an imported symbol named `datetime`.

2. An alias named `str` in a local namespace does not shadow the builtin `str` â€” the builtin is selected.

## Backwards compatibility and migration

Changing the builtin table is a breaking change. Any change MUST be accompanied by an AD and migration guidance. Compiler implementations should log a clear warning if a future extension adds new builtins that collide with previously used identifiers.

## References

- [RFC-0001: Builtin Type System Design](/rfc/rfc-0001)
- [TSY-0001: Builtin Types](/tsy/tsy-0001)
