---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 12
status: draft
title: Metadata Resolution
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0012: Metadata Resolution

## Overview

This specification defines the deterministic compilation rules for metadata resolution in Kintsu compilers. Metadata resolution determines the effective metadata (version, error type) for each schema item by:

1. **Parsing metadata** from AST nodes (inner and outer attributes)
2. **Resolving inheritance** from namespace-level to item-level metadata
3. **Validating metadata** for correctness (positive versions, valid error references)
4. **Associating metadata** with types and operations in the compiled schema

The implementation must produce consistent results across all compiler implementations.

![Metadata Inheritance Flow](../../../../diagrams/metadata_inheritance.png)

## Motivation

Compilers must resolve metadata consistently to ensure:

- **Predictable inheritance**: Same schema produces same effective metadata in all compilers
- **Clear error messages**: Invalid metadata is detected and reported with precise locations
- **Type safety**: Error type references are validated against declared error types
- **Version tracking**: Every type has a known version (explicit or inherited)

Deterministic rules eliminate ambiguity in metadata resolution behavior.

## Architecture

Metadata resolution operates in phases:

1. **Parse phase**: Extract metadata from AST during parsing
2. **Registration phase**: Register namespace-level inner attributes
3. **Resolution phase**: Resolve effective metadata for each item by checking item-level then namespace-level
4. **Validation phase**: Validate metadata values and references

![Metadata AST Hierarchy](../../../../diagrams/metadata_ast_hierarchy.png)

## Design Principles

1. **Specificity precedence**: Item-level metadata overrides namespace-level
2. **Explicit inheritance**: Inheritance is explicit through inner attributes, not implicit
3. **Early validation**: Reject invalid metadata during parsing, not during code generation
4. **Clear diagnostics**: Error messages include source locations and suggest fixes
5. **No silent defaults**: Missing required metadata is an error, not a silent default

## Deterministic compilation rules (normative)

### Rule 1: Metadata parsing from AST

The compiler must parse metadata from AST nodes using the `ItemMeta` structure.

**AST structure** (from `parser/src/ast/meta.rs`):

```rust
pub struct Meta<Value: Parse> {
    pub open: Spanned<HashToken>,        // '#'
    pub inner: Option<Spanned<BangToken>>, // optional '!'
    pub bracket: Bracket,                 // '[...]'
    pub name: Spanned<IdentToken>,        // "version" or "err"
    pub paren: Paren,                     // '(...)'
    pub value: Spanned<Value>,            // version number or error identifier
}

pub enum ItemMetaItem {
    Version(VersionMeta),  // #[version(n)] or #![version(n)]
    Error(ErrorMeta),      // #[err(Type)] or #![err(Type)]
}

pub struct ItemMeta {
    pub meta: Vec<ItemMetaItem>,
}
```

**Parsing algorithm:**

1. Parse `#` token
2. Check for optional `!` token (determines inner vs outer)
3. Parse `[name(value)]` structure
4. Validate `name` is "version" or "err"
5. Parse and validate `value` based on metadata type
6. Store in `ItemMeta` structure

**Example:**

```kintsu
#![version(1)]
```

Parsed as:

- `open`: `#` at position
- `inner`: Some(`!`) at position
- `name`: "version"
- `value`: IntToken(1)

### Rule 2: Inner vs outer attribute detection

The compiler must distinguish inner (`#![...]`) from outer (`#[...]`) based on the presence of `!` token.

**Detection algorithm:**

```rust
fn is_inner_attribute(meta: &Meta) -> bool {
    meta.inner.is_some()
}
```

**Implications:**

- Inner attributes: `meta.inner == Some(BangToken)` -> applies to namespace children
- Outer attributes: `meta.inner == None` -> applies to following item

### Rule 3: Namespace-level metadata registration

The compiler must register namespace-level inner attributes before processing child items.

**Registration algorithm:**

1. Parse namespace declaration
2. Extract all inner attributes (`#![...]`) from beginning of namespace
3. Store in namespace context:
   - `namespace_version: Option<u32>` for `#![version(n)]`
   - `namespace_error: Option<PathOrIdent>` for `#![err(Type)]`
4. Validate no duplicate metadata of same type

**Example:**

```kintsu
namespace api {
    #![version(1)]
    #![err(ApiError)]

    struct User { ... }
}
```

Registered context:

- `namespace_version = Some(1)`
- `namespace_error = Some(PathOrIdent::Ident("ApiError"))`

**Error cases:**

```kintsu
namespace api {
    #![version(1)]
    #![version(2)]  // Error: duplicate version metadata
}
```

Error message:

```text
Error: duplicate metadata attribute 'version' at namespace level
  --> schema.ks:3:5
   |
 3 |     #![version(2)]
   |     ^^^^^^^^^^^^^^ duplicate 'version' metadata
   |
 note: previous 'version' metadata defined here
  --> schema.ks:2:5
   |
 2 |     #![version(1)]
   |     ^^^^^^^^^^^^^^
```

### Rule 4: Item-level metadata extraction

The compiler must extract outer attributes (`#[...]`) that precede each item.

**Extraction algorithm:**

1. Parse item (struct, enum, operation, etc.)
2. Extract all outer attributes preceding the item
3. Store in item context:
   - `item_version: Option<u32>` for `#[version(n)]`
   - `item_error: Option<PathOrIdent>` for `#[err(Type)]`
4. Validate no duplicate metadata of same type

### Rule 5: Version metadata resolution

The compiler must resolve the effective version for each type using inheritance.

**Resolution algorithm:**

```rust
fn resolve_version(
    item_version: Option<u32>,
    namespace_version: Option<u32>
) -> Option<u32> {
    item_version.or(namespace_version)
}
```

**Precedence:**

1. Item-level `#[version(n)]` (highest priority)
2. Namespace-level `#![version(n)]` (fallback)
3. None (no version assigned)

**Example:**

```kintsu
namespace api {
    #![version(1)]

    struct User { ... }        // Effective version: 1 (inherited)

    #[version(2)]
    struct Account { ... }      // Effective version: 2 (explicit)

    struct Profile { ... }      // Effective version: 1 (inherited)
}
```

### Rule 6: Error metadata resolution

The compiler must resolve the effective error type for each fallible operation.

**Resolution algorithm:**

```rust
fn resolve_error(
    operation: &Operation,
    item_error: Option<PathOrIdent>,
    namespace_error: Option<PathOrIdent>
) -> Result<Option<PathOrIdent>, Error> {
    let is_fallible = operation.return_type.is_fallible();

    match (is_fallible, item_error, namespace_error) {
        (true, Some(err), _) => Ok(Some(err)),         // Operation-level
        (true, None, Some(err)) => Ok(Some(err)),      // Namespace-level
        (true, None, None) => Err(missing_error()),    // Error: required
        (false, _, _) => Ok(None),                     // Infallible: ignore
    }
}
```

**Precedence:**

1. Operation-level `#[err(Type)]` (highest priority)
2. Namespace-level `#![err(Type)]` (fallback)
3. Error if fallible and no error metadata

**Example:**

```kintsu
namespace api {
    #![err(ApiError)]

    operation getUser() -> User!;     // Effective error: ApiError (inherited)

    #[err(ValidationError)]
    operation createUser() -> User!;  // Effective error: ValidationError (explicit)

    operation listUsers() -> User[];  // Effective error: None (infallible)
}
```

**Error case:**

```kintsu
namespace api {
    // No namespace-level error

    operation getUser() -> User!;  // Error: missing error type
}
```

Error message:

```text
Error: fallible operation requires error type
  --> schema.ks:4:5
   |
 4 |     operation getUser() -> User!;
   |                                ^ fallible return type requires error metadata
   |
help: add error metadata at operation level
   |
 4 |     #[err(ErrorType)]
   |     operation getUser() -> User!;
   |
help: or add default error at namespace level
   |
 2 |     #![err(DefaultErrorType)]
   |     namespace api {
```

### Rule 7: Metadata validation

The compiler must validate all metadata values during resolution.

**Validation rules:**

1. **Version values**: Must be positive integers (`value > 0`)
2. **Error type references**: Must reference declared error types
3. **Uniqueness**: No duplicate metadata of same type on same item
4. **Applicability**: Version only on types/namespaces, error only on operations

**Version validation:**

```rust
fn validate_version(version: i32, span: &Span) -> Result<u32, Error> {
    if version <= 0 {
        return Err(Error::new(
            span,
            format!("version must be positive, found {}", version)
        ));
    }
    Ok(version as u32)
}
```

**Error type validation:**

```rust
fn validate_error_type(
    error_ref: &PathOrIdent,
    available_errors: &[ErrorType],
    span: &Span
) -> Result<(), Error> {
    if !available_errors.iter().any(|e| e.name() == error_ref) {
        return Err(Error::new(
            span,
            format!("error type '{}' not found", error_ref)
        ));
    }
    Ok(())
}
```

### Rule 8: Error message format for invalid metadata

The compiler must produce clear, actionable error messages for invalid metadata.

**Format requirements:**

1. Error message with clear description
2. Source location (file, line, column)
3. Span highlighting the problematic metadata
4. Help messages suggesting fixes
5. Note with related context when applicable

**Example: Invalid version**

```text
Error: version must be positive integer
  --> schema.ks:2:5
   |
 2 |     #[version(0)]
   |               ^ version must be greater than 0
   |
help: use a positive integer
   |
 2 |     #[version(1)]
```

**Example: Missing error type**

```text
Error: fallible operation requires error type
  --> schema.ks:5:28
   |
 5 |     operation getUser() -> User!;
   |                                ^ fallible return type requires error metadata
   |
help: add error metadata
   |
 5 |     #[err(ErrorType)]
   |     operation getUser() -> User!;
```

**Example: Duplicate metadata**

```text
Error: duplicate metadata attribute 'version'
  --> schema.ks:4:5
   |
 4 |     #[version(2)]
   |     ^^^^^^^^^^^^^ duplicate 'version' metadata
   |
note: previous 'version' metadata defined here
  --> schema.ks:3:5
   |
 3 |     #[version(1)]
   |     ^^^^^^^^^^^^^
```

### Rule 9: Metadata inheritance non-transitivity

The compiler must not propagate namespace-level metadata to nested child namespaces.

**Non-transitivity rule:**

```rust
fn inherit_metadata(
    parent_namespace: &Namespace,
    child_item: &Item
) -> Metadata {
    // Only direct children inherit, not nested namespaces
    match child_item {
        Item::Namespace(_) => Metadata::empty(),  // No inheritance
        _ => parent_namespace.metadata.clone(),   // Inherit
    }
}
```

**Example:**

```kintsu
namespace api {
    #![version(1)]

    struct User { ... }        // Inherits version(1)

    namespace admin {
        // Does NOT inherit version(1) from parent

        struct Admin { ... }    // No inherited version
    }
}
```

> [!IMPORTANT]
> Nested namespaces must declare their own inner attributes; they do not inherit from parent namespaces.

### Rule 10: Metadata access in compiler phases

The compiler must make resolved metadata available to subsequent compilation phases.

**Access interface:**

```rust
impl Type {
    fn version(&self) -> Option<u32> {
        // Returns effective version after resolution
    }
}

impl Operation {
    fn error_type(&self) -> Option<&PathOrIdent> {
        // Returns effective error type after resolution
    }
}
```

**Usage in codegen:**

```rust
fn generate_type_metadata(ty: &Type) -> Metadata {
    if let Some(version) = ty.version() {
        // Include version in generated code
    }
}

fn generate_operation_error(op: &Operation) -> ErrorHandling {
    if let Some(error_ty) = op.error_type() {
        // Generate error handling code
    }
}
```

## Acceptance Criteria

- [ ] The compiler parses both inner (`#![...]`) and outer (`#[...]`) metadata attributes.
- [ ] The compiler registers namespace-level inner attributes before processing child items.
- [ ] The compiler extracts item-level outer attributes for each type and operation.
- [ ] Version resolution follows the precedence: item-level > namespace-level > none.
- [ ] Error resolution follows the precedence: operation-level > namespace-level > error (if fallible).
- [ ] The compiler validates version values are positive integers.
- [ ] The compiler validates error type references against declared error types.
- [ ] The compiler produces clear error messages with source locations for invalid metadata.
- [ ] Nested namespaces do not inherit metadata from parent namespaces.
- [ ] Resolved metadata is accessible to subsequent compiler phases (codegen, validation, etc.).

## Implications

### For Compiler Maintainers

- Must implement metadata parsing in AST construction
- Must implement inheritance resolution algorithm
- Must validate metadata during resolution phase
- Must produce helpful error messages with suggestions

### For Tooling Developers

- Can extract metadata from compiled schemas
- Can use version information for compatibility checks
- Can leverage error metadata for documentation generation
- Can validate schemas against metadata requirements

### For Schema Evolution

- Version metadata enables breaking change detection
- Error metadata enables consistent error handling
- Inheritance reduces boilerplate in large schemas
- Override capability provides flexibility when needed

## References

- [RFC-0012](/specs/rfc/rfc-0012) - Metadata system design
- [TSY-0012](/specs/tsy/tsy-0012) - Metadata type system rules
- [SPEC-0005](SPEC-0005) - Error types resolution
- [SPEC-0009](SPEC-0009) - Operations resolution
- [SPEC-0010](SPEC-0010) - Namespace resolution
