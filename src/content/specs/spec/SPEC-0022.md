---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: SPEC
number: 22
status: draft
title: Error System Architecture
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0022: Error System Architecture

## Overview

This specification defines the implementation architecture for Kintsu's error handling system, including the miette diagnostic integration, span decoration patterns, and error propagation mechanisms. It establishes the technical requirements for implementing the error taxonomy defined in [RFC-0023](/specs/rfc/rfc-0023).

## Motivation

Kintsu requires a robust diagnostic system that:

1. Provides rich, contextual error messages with source code highlighting
2. Supports multiple severity levels with appropriate output behaviour
3. Enables consistent error formatting across all compiler phases
4. Integrates with IDEs through structured diagnostic output
5. Supports related spans for complex multi-location errors

## Architecture

### Error Type Hierarchy

```
kintsu::Error
 |--- WithSpan { inner, start, end }      // Span decoration wrapper
 |--- WithSource { inner, path, source }  // Source file wrapper
 |--- Domain-specific variants            // KLX, KPR, KNS, etc.
 |--- Compound variants                   // Multiple errors
```

### Diagnostic Components

Each error produces a `miette::Diagnostic` with these components:

| Component     | Type              | Required | Description                                 |
| ------------- | ----------------- | -------- | ------------------------------------------- |
| `code`        | `String`          | Yes      | Error code (e.g., `KTR1001`)                |
| `message`     | `String`          | Yes      | Human-readable error description            |
| `severity`    | `Severity`        | Yes      | Error, Warning, Info, or Hint               |
| `source_code` | `NamedSource`     | Yes\*    | Source file content (\*when span available) |
| `labels`      | `Vec<Label>`      | Yes\*    | Source spans with descriptions              |
| `help`        | `Option<String>`  | Yes      | Actionable resolution guidance              |
| `related`     | `Vec<Diagnostic>` | No       | Related diagnostic information              |

### Span Decoration

Errors acquire source location through wrapper types:

```rust
// Attach byte offset span
error.with_span(start, end) -> Error::WithSpan { inner, start, end }

// Attach source file context
error.with_source(path, source) -> Error::WithSource { inner, path, source }

// Chained decoration
Error::UndefinedType { name }
    .with_span(145, 148)
    .with_source(path, source)
```

### Span Extraction

The `to_report()` method recursively extracts the deepest span:

```rust
fn extract_deepest_span(&self) -> Option<(usize, usize)> {
    match self {
        Error::WithSpan { inner, start, end } => {
            inner.extract_deepest_span().or(Some((*start, *end)))
        }
        Error::WithSource { inner, .. } => inner.extract_deepest_span(),
        _ => None,
    }
}
```

### Diagnostic Generation

```rust
pub fn to_diagnostic(&self) -> impl miette::Diagnostic {
    SpanDiagnostic {
        code: self.error_code(),           // K[XX][C][NNN]
        message: self.message(),           // Formatted message
        severity: self.severity(),         // Error level
        src: self.named_source(),          // NamedSource
        span: self.primary_span(),         // Primary highlight
        labels: self.labels(),             // All labels
        help: self.help_text(),            // Resolution guidance
        related: self.related_diagnostics(),
    }
}
```

## Design Principles

### Span Attachment Requirements

| Error Domain          | Span Required | Span Type                 |
| --------------------- | ------------- | ------------------------- |
| Lexical (KLX)         | Yes           | Character position        |
| Parsing (KPR)         | Yes           | Token/AST span            |
| Namespace (KNS)       | Partial       | File-level or declaration |
| Type Definition (KTY) | Yes           | Definition span           |
| Type Resolution (KTR) | Yes           | Reference location        |
| Union (KUN)           | Yes           | Operand location          |
| Metadata (KMT)        | Yes           | Attribute location        |
| Tagging (KTG)         | Yes           | Attribute/field span      |
| Type Expression (KTE) | Yes           | Expression span           |
| Package (KPK)         | No            | N/A (separate file)       |
| Registry (KRG)        | No            | N/A (runtime)             |
| Filesystem (KFS)      | No            | N/A (OS operation)        |
| Internal (KIN)        | No            | N/A (debug only)          |

### Multi-Span Errors

Errors involving multiple locations use related diagnostics:

```rust
// Duplicate definition error
Error::IdentConflict { namespace, ident, tag }
    .with_span(second_definition_span)      // Primary: the duplicate
    .with_related(first_definition_span)    // Related: original
```

**Output:**

```
error[KTY3001]: duplicate struct 'User' in namespace 'api'
  --> schema/models.ks:25:1
   |
25 | struct User {
   | ^^^^^^^^^^^^ duplicate definition
   |
note: first defined here
  --> schema/types.ks:10:1
   |
10 | struct User {
   | ^^^^^^^^^^^^
```

### Help Text Guidelines

Help text must be:

1. **Actionable**: Tell the user what to do, not just what's wrong
2. **Specific**: Reference the actual code elements involved
3. **Concise**: One or two sentences maximum

**Good:**

```
help: did you mean 'User'? (defined in api::types)
```

**Bad:**

```
help: the type you referenced does not exist in the current scope or any imported namespaces
```

### Suggestion Generation

For resolution errors, generate suggestions using:

1. **Levenshtein distance**: Candidates with distance â‰¤ 2
2. **Scope proximity**: Prefer local namespace, then imports
3. **Type compatibility**: Prefer same kind (struct for struct reference)

```rust
fn generate_suggestions(name: &str, context: &ResolutionContext) -> Vec<String> {
    let mut candidates = Vec::new();

    // Local namespace first
    for item in context.local_items() {
        if levenshtein(name, item.name()) <= 2 {
            candidates.push(item.qualified_name());
        }
    }

    // Then imports
    for import in context.imports() {
        for item in import.exported_items() {
            if levenshtein(name, item.name()) <= 2 {
                candidates.push(item.qualified_name());
            }
        }
    }

    // Sort by distance, take top 3
    candidates.sort_by_key(|c| levenshtein(name, c));
    candidates.truncate(3);
    candidates
}
```

### Severity Propagation

When multiple errors occur, the overall compilation result uses the highest severity:

| Highest Error | Compilation Result                  |
| ------------- | ----------------------------------- |
| Error         | Failure (exit code 1)               |
| Warning       | Success with warnings (exit code 0) |
| Info          | Success (exit code 0)               |
| Hint          | Success (exit code 0)               |

### CLI Output Format

**Default mode:**

```
error[KTR1001]: type 'Usr' not found
  --> schema/api.ks:15:12
   |
15 |     user: Usr,
   |           ^^^ type not found
   |
   = help: did you mean 'User'?

warning[KTY8001]: field 'created_at' shadows inherited field
  --> schema/models.ks:8:5
   |
 8 |     created_at: datetime,
   |     ^^^^^^^^^^ shadows field from 'BaseModel'
```

**JSON mode (`--format=json`):**

```json
{
  "diagnostics": [
    {
      "code": "KTR1001",
      "severity": "error",
      "message": "type 'Usr' not found",
      "spans": [
        {
          "file": "schema/api.ks",
          "start": { "line": 15, "column": 12 },
          "end": { "line": 15, "column": 15 },
          "label": "type not found"
        }
      ],
      "help": "did you mean 'User'?"
    }
  ]
}
```

### Registry Error Propagation

When the registry server returns compilation errors (e.g., during publish validation), the response includes structured error data that clients can reconstruct as local diagnostics:

```json
{
  "error": "compile-error",
  "code": "KTR1001",
  "message": "type 'Usr' not found",
  "source": {
    "path": "schema/types.ks",
    "span": { "start": 145, "end": 148 }
  },
  "suggestions": ["User", "Users"]
}
```

The client reconstructs the miette diagnostic using the provided span and source file from the local package.

## Implications

### Implementation Requirements

1. All error variants must implement `error_code() -> String`
2. Span-requiring errors must validate span presence before `to_diagnostic()`
3. Help text must be computed lazily (suggestions may be expensive)
4. JSON output format must be stable for tooling integration

### Performance Considerations

1. Suggestion generation should be bounded (max 100 candidates)
2. Source file content should be shared via `Arc<String>`
3. Multiple errors should be collected before reporting (not fail-fast for non-fatal)

### Testing Requirements

1. Each error code must have a test case producing that specific error
2. Diagnostic output must be snapshot-tested for format stability
3. Suggestion algorithms must be tested for accuracy

## References

- [RFC-0023](/specs/rfc/rfc-0023) - Error Handling Design
- [ERR-0001](/specs/err/err-0001) - Error System Overview
