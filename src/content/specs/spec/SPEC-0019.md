---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: SPEC
number: 19
status: draft
title: Lockfile Implementation
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0019: Lockfile Implementation

## Overview

This specification defines the compiler implementation for parsing, validating, and generating lockfiles (`schema.lock.toml`) as specified in [RFC-0020](/specs/rfc/RFC-0020).

## Motivation

Correct lockfile handling ensures:

- Reproducible builds across environments
- Integrity verification via checksums
- Clear dependency provenance tracking

## Architecture

### Versioned Envelope

Like the package manifest, the lockfile uses a tagged enum pattern for version discrimination. The root-level `version` field determines which inner structure to deserialize. Currently only `v1` is defined.

### Core Data Model

The lockfile has two main sections:

**Root section** (`[root]`) contains the root package's resolved state:

- `name` - Root package name
- `version` - Root package version
- `checksum` - Content hash in `sha256:hex` format
- `source` - Source table with `type` and location fields
- `dependencies` - Map of dependency namespace names to dependency info

**Packages section** (`[packages."name@version"]`) contains each locked dependency:

- `name` - Package name (kebab-case)
- `version` - Resolved semantic version
- `checksum` - Content hash in `sha256:hex` format
- `source` - Source table with `type` field and location
- `dependencies` - Map of its own dependencies

**Source table** uses a `type` field to indicate source kind:

- `type = "path"` with `path` field
- `type = "registry"` with `url` field
- `type = "git"` with `url` and `rev` fields

**Dependency entry** (under `[*.dependencies.dep_name]`):

- `version` - Resolved version of the dependency
- `provides` - Array of namespace names this dependency exports that are used
- `chain` - Array showing the dependency path (e.g., `["root-pkg", "dep_name"]`)

### Checksum Format

Checksums follow the format `algorithm:hex` where algorithm is currently always `sha256`. The hex portion is the lowercase hexadecimal encoding of the hash digest.

Checksum computation uses canonical JSON serialization of the declaration bundle. This ensures consistent hashes across platforms regardless of field ordering in the original source.

### Loading and Parsing

Loading follows these steps:

1. Check if lockfile exists at `schema.lock.toml`. If not, return none (lockfile is optional).
2. Read file content as TOML.
3. Extract version field and dispatch to appropriate deserializer.
4. Validate all checksum strings are well-formed.

### Validation Against Manifest

When a lockfile exists, it must be validated against the current manifest:

**Missing package check**: Every dependency declared in the manifest must have a corresponding locked package entry. If a manifest dependency has no locked entry, the lockfile is stale and must be regenerated.

**Orphaned package check**: Every locked package must either be declared in the manifest or be a transitive dependency. Packages that are neither are orphaned and indicate the lockfile needs cleanup.

### Checksum Verification

Before using a cached package, verify its checksum:

1. Parse the stored checksum string into algorithm and expected digest.
2. Serialize the declaration bundle to canonical JSON.
3. Compute the hash of the JSON bytes using the specified algorithm.
4. Compare computed digest to expected digest. If they differ, the package content has changed.

Checksum mismatches indicate either tampering or an incorrectly cached artifact. The compiler should refetch and regenerate the entry.

### Lockfile Generation

When generating a new lockfile:

1. Create `[root]` section with root package name, version, checksum, source, and dependencies.
2. For each resolved dependency, create a `[packages."name@version"]` table.
3. Populate each package's dependencies as `[packages."name@version".dependencies.dep_name]` sub-tables.
4. Sort package tables alphabetically by their keys for deterministic output.
5. Serialize to TOML and write to `schema.lock.toml`.

### Provides and Chain Tracking

The `provides` field records which namespaces from a dependency are actually used. This enables:

- Detecting unused dependencies (provides array is empty)
- Understanding namespace provenance
- Optimizing what gets loaded

The `chain` field records the import path for transitive dependencies:

- Direct dependencies have an empty chain
- Transitive dependencies list the packages that led to their inclusion
- The chain enables answering "why is this dependency included?"

### Update Modes

Three update modes are supported:

**Strict mode**: Use lockfile as-is. Fail if any manifest dependency is missing from lockfile. This is the default for CI builds.

**Full mode**: Regenerate the entire lockfile from the manifest. All dependencies are re-resolved. Use when intentionally updating dependencies.

**Selective mode**: Update only specified packages. Other locked entries are preserved. Use when updating a single dependency.

### Validation Requirements

**At parse time:**

- TOML syntax must be valid
- Version field must be present and known
- All checksum strings must match the `algorithm:hex` format

**During validation:**

- Every manifest dependency must have a locked entry (or lockfile is stale)
- Every locked entry must be reachable from manifest (or entry is orphaned)
- Checksum algorithm must be recognized

**During use:**

- Checksum must match computed hash of bundle content
- Source information must be sufficient to refetch if needed

## Design Principles

### Deterministic Output

Lockfile generation produces identical output for identical inputs. Packages are sorted by name. Dependencies within each package are sorted. TOML formatting is canonical.

### Minimal Changes

Updates only modify necessary entries. Unchanged packages keep their entries. Transitive dependencies are updated as needed. Checksums are recalculated only when content changes.

### Audit Trail

The chain field provides full dependency provenance. The root package is always first in the chain. Intermediate dependencies appear in order. This enables "why is this included" queries.

## Implications

### Performance

The lockfile is loaded once per build. Checksum verification can be parallelized across packages. Unchanged packages skip refetching.

### Security

SHA-256 checksums prevent tampering. Registry packages are verified on fetch. Chain tracking aids security audits by showing the full dependency path.

### Git Integration

The lockfile should be committed to version control. Merge conflicts are typically resolved by regeneration. When merging, prefer the merge-base lockfile and regenerate.

## References

- [RFC-0020](/specs/rfc/RFC-0020) - Lockfile Format
- [SPEC-0018](/specs/spec/SPEC-0018) - Package Manifest Implementation
- [SPEC-0020](/specs/spec/SPEC-0020) - Declaration Bundle Implementation
