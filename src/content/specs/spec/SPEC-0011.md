---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 11
status: draft
title: Import Resolution
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0011: Import Resolution

## Overview

This SPEC documents the compiler's deterministic behavior for parsing and resolving import statements. It specifies the import resolution algorithm (parse `use` statements, resolve paths via `::` traversal, validate existence), namespace lookup process (path segment traversal through namespace hierarchy), cross-schema import handling (dependency manifest checking, schema loading), and error handling (missing package/namespace/type, circular dependency detection). This SPEC is normative for implementers who must reproduce the compiler's import resolution behavior.

![Import Resolution Flow](../../../../diagrams/import_resolution_flow.png)

## Motivation

Deterministic import resolution is critical for reproducible builds and dependency management. This SPEC records the precise algorithms for parsing import paths, resolving namespaces across schemas, validating existence, and detecting circular dependencies so implementations produce identical results and provide clear error messages for resolution failures.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

### Import statement parsing

The compiler parses `use` statements during namespace loading:

**Parsing algorithm:**

1. Detect `use` keyword at start of statement
2. Parse import path:
   - If path followed by `::{ ... }`: parse multiple items (UseWithItems)
   - If path alone: parse single item (PathOrIdent)
3. For multiple items, recursively parse nested paths
4. Construct UsePath AST node
5. Register import in namespace

**AST structures:**

- **UsePath**: Top-level import with optional items
- **UseWithItems**: Brace-enclosed item list with `::` prefix
- **FinalOrNested**: Terminal item (type/namespace) or nested path

**Example parsing:**

```kintsu
use abc::types::{User, Config};
```

**AST:** UsePath { leading: `abc::types`, items: UseWithItems { inner: [User, Config] } }

> [!IMPORTANT]
> Import parsing happens during namespace file loading, before type resolution.

### Path resolution with `::` traversal

Import paths are resolved by traversing namespace hierarchy using `::` separator:

**Resolution algorithm:**

1. Extract path segments split by `::`
   - Example: `abc::types::User` → [`abc`, `types`, `User`]
2. Start with root segment (`abc`):
   - Check if schema name → cross-schema import
   - Check if namespace name → within-schema import
3. For each subsequent segment:
   - Enter child namespace or
   - Resolve to type (if final segment)
4. Validate each segment exists during traversal

**Example resolution:**

```kintsu
use abc::types::User;
```

**Steps:**

1. `abc` → resolve to schema or namespace
2. `types` → enter child namespace `types` of `abc`
3. `User` → resolve to type `User` in `abc::types`

> [!NOTE]
> Path traversal follows namespace parent-child relationships.

### Namespace lookup process

For each path segment, the compiler performs namespace lookup:

**Lookup algorithm:**

1. **Root segment lookup:**
   - Search in dependency schemas (if cross-schema)
   - Search in current schema's root namespaces (if within-schema)
2. **Child segment lookup:**
   - Search in current namespace's children
   - If namespace found, enter it
   - If type found (final segment), resolve import
3. **Type lookup:**
   - Check namespace's children map for type
   - Validate type exists

**Example:**

```kintsu
# In schema 'myapp'
use common::types::User;
```

**Lookup:**

1. `common` → search current schema's root namespaces → find `common`
2. `types` → search `common`'s children → find `types` namespace
3. `User` → search `common::types`'s children → find `User` type

> [!IMPORTANT]
> Each segment must resolve successfully or import fails.

### Cross-schema import handling

Cross-schema imports reference types from dependency schemas:

**Handling algorithm:**

1. **Dependency check:**
   - Extract root segment (schema name)
   - Check if listed in schema manifest dependencies
   - If not found, error: "package not found"
2. **Schema loading:**
   - Load dependency schema if not already loaded
   - Parse dependency's namespaces and types
3. **Path resolution:**
   - Resolve remaining path segments within dependency schema
   - Follow same namespace traversal rules

**Example:**

```kintsu
# myapp schema.toml
[dependencies]
external_pkg = "1.0.0"

# myapp/api.ks
use external_pkg::types::User;
```

**Resolution:**

1. Check `external_pkg` in dependencies → found ✓
2. Load `external_pkg` schema
3. Resolve `types::User` within `external_pkg`

> [!WARNING]
> Cross-schema imports require dependency declarations. Missing dependencies cause compilation errors.

### Dependency manifest checking

The compiler validates dependency declarations before resolving cross-schema imports:

**Validation algorithm:**

1. Parse schema manifest (`schema.toml`)
2. Extract `[dependencies]` section
3. Build dependency map: schema name → version
4. For each cross-schema import:
   - Extract root segment (schema name)
   - Check if in dependency map
   - If not found, error: "package '{name}' not found in dependencies"

**Error example:**

```kintsu
use undeclared::types::User;
```

**Error:** `package 'undeclared' not found. Add to [dependencies] in schema.toml`

> [!NOTE]
> Dependency validation happens before import resolution to fail fast.

### Missing package error handling

If imported schema/package not found:

**Error detection:**

1. Extract root segment from import path
2. Check local namespaces (within-schema check)
3. Check dependency schemas (cross-schema check)
4. If neither found, error: "package not found"

**Error message:**

```text
Error: package 'nonexistent' not found
  --> api.ks:3:5
   |
 3 | use nonexistent::types::User;
   |     ^^^^^^^^^^^ not found in dependencies or local namespaces
```

### Missing namespace error handling

If namespace segment not found during traversal:

**Error detection:**

1. During path traversal, attempt to enter child namespace
2. Check current namespace's children for segment
3. If not found, error: "namespace not found"

**Error message:**

```text
Error: namespace 'missing' not found in 'abc'
  --> api.ks:3:5
   |
 3 | use abc::missing::User;
   |          ^^^^^^^ namespace 'missing' not found
```

### Missing type error handling

If type not found in final namespace:

**Error detection:**

1. After traversing to final namespace
2. Extract final path segment (type name)
3. Check namespace's children for type
4. If not found, error: "type not found"

**Error message:**

```text
Error: type 'MissingType' not found in 'abc::types'
  --> api.ks:3:5
   |
 3 | use abc::types::MissingType;
   |                 ^^^^^^^^^^^ type not found
```

> [!WARNING]
> All resolution failures stop compilation and report detailed error messages with source locations.

### Circular dependency detection

The compiler detects circular import dependencies:

**Detection algorithm:**

1. Build dependency graph: namespace → imported namespaces
2. Perform depth-first search (DFS) on graph
3. Track visited nodes and recursion stack
4. If node already in recursion stack, cycle detected

**Example (invalid):**

```kintsu
# api.ks
namespace api;
use common::types::User;

# common.ks
namespace common;
use api::Request;  // ERROR: creates cycle
```

**Error:** `Circular dependency detected: api → common → api`

> [!IMPORTANT]
> Circular dependencies prevent proper compilation ordering and are compilation errors.

### Public vs private import handling

The compiler tracks import visibility based on file location:

**Visibility rules:**

1. **Imports in namespace `.ks` files:**
   - Mark as private (namespace-scoped)
   - Do not add to namespace's re-export list
2. **Imports in `lib.ks`:**
   - Mark as public (re-exported)
   - Add to schema's public API list

**Example:**

```kintsu
# api/handlers.ks (private)
use abc::types::User;  // Not re-exported

# lib.ks (public)
use abc::types;  // Re-exported to schema consumers
```

> [!NOTE]
> Only `lib.ks` imports are re-exported. Namespace file imports are private.

## Acceptance Criteria

- **AC-1:** Import statements are parsed during namespace loading
- **AC-2:** Paths are resolved by traversing namespaces using `::` separator
- **AC-3:** Each path segment is validated during traversal
- **AC-4:** Cross-schema imports require dependency declarations in manifest
- **AC-5:** Missing packages cause "package not found" errors
- **AC-6:** Missing namespaces cause "namespace not found" errors
- **AC-7:** Missing types cause "type not found" errors
- **AC-8:** Circular dependencies are detected via DFS and cause compilation errors
- **AC-9:** Private imports (namespace files) are not re-exported
- **AC-10:** Public imports (`lib.ks`) are re-exported

## Design Principles

- **Path-based resolution**: Use `::` separator for namespace traversal
- **Early validation**: Resolve and validate imports before type processing
- **Clear error messages**: Provide detailed errors with source locations
- **Dependency checking**: Validate manifest declarations before loading schemas
- **Circular detection**: Use DFS to detect import cycles
- **Visibility tracking**: Distinguish private (namespace) vs public (`lib.ks`) imports

## Implications

**For implementers:**

- Import parsing uses UsePath, UseWithItems, FinalOrNested AST nodes
- Path resolution requires namespace hierarchy traversal
- Cross-schema imports require dependency schema loading
- Circular dependency detection uses DFS on import graph
- Private vs public imports tracked by file location

**For code generators:**

- All imports are resolved and validated before code generation
- Cross-schema imports have loaded dependency schemas
- Private imports are namespace-scoped (not accessible to consumers)
- Public imports (`lib.ks`) define schema's API surface

**For tooling:**

- Import resolution errors include source locations
- Dependency graph reveals namespace relationships
- Circular dependencies detected and reported clearly
- Import visibility affects schema API surface

## References

- [RFC-0011](/rfc/rfc-0011) - Import system design rationale
- [TSY-0011](/tsy/tsy-0011) - Import type system rules
- [SPEC-0010](/spec/spec-0010) - Namespace compilation
- [RFC-0010](/rfc/rfc-0010) - Namespace system design
