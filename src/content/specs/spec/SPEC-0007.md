---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 7
status: draft
title: Union Type Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0007: Union Type Compilation

## Overview

This SPEC documents the compiler's deterministic behaviour for identifying, validating, and resolving union types. It specifies the union identification algorithm (scanning type positions), operand validation (struct-only enforcement), field merging algorithm (left-to-right precedence with conflict detection), struct synthesis, and context-based name generation. This SPEC is normative for implementers who must reproduce the compiler's union resolution behaviour.

## Motivation

Code generators and downstream tooling rely on consistent union field merging. This SPEC records the precise algorithms for union identification, validation, and merging so implementations produce identical outputs for the same source schemas. The left-to-right field merging algorithm and struct-only validation are critical for type safety and determinism.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

The following diagram illustrates the complete union compilation pipeline from identification through validation, field merging, and struct generation:

![Union Compilation Flow](../../../../diagrams/union_compilation_flow.png)

### Union identification

The compiler identifies all union type expressions during resolution Phase 4 by scanning type positions in:

- Type alias targets
- Struct field types
- Operation parameter types
- Operation return types
- Oneof variant types
- Array element types (recursively)
- Parenthesized types (recursively)
- Anonymous struct field types (recursively)

**For each union found:**

1. Record the union reference (AST node)
2. Capture context stack (namespace path, parent names, field names)
3. Track oneof context (true if in oneof variant, with variant index)
4. Store union record for later processing

**Example:**

```kintsu
struct Request {
    auth: User & Permissions  // Union in struct field type
};
```

**Recorded context:** `[namespace_name, Request, auth]`

> [!IMPORTANT]
> Union identification occurs before validation and merging. All unions are collected first to enable topological processing if needed.

### Operand validation (struct-only enforcement)

Before field merging, the compiler validates that all union operands resolve to struct types. For each operand:

1. If operand is an identifier, look up in type registry:
   - If resolved alias, recursively validate the resolved type
   - If namespace child, check type:
     - **Struct:** Valid âœ“
     - **Enum:** Error - "union operand must be struct, found enum"
     - **Error:** Error - "union operand must be struct, found error"
     - **OneOf:** Error - "union operand must be struct, found oneof"
     - **Operation/Namespace:** Error - "union operand must be struct"
   - If not found, error - "undefined type"
2. If operand is anonymous struct, valid (extracted in Phase 1)
3. If operand is parenthesized union, recursively validate inner operands

**Example validation:**

```kintsu
enum Status { Active, Inactive }
struct User { id: i64 }
type Invalid = User & Status;
```

**Error:** `union operand 'Status' must be struct, found enum`

> [!WARNING]
> Validation must occur before merging. If any operand is invalid, union resolution fails immediately.

### Field merging algorithm (left-to-right with conflicts)

The compiler merges fields from union operands using a working set that tracks field names:

**Algorithm:**

1. Initialize empty working set (map: field name -> first occurrence)
2. For each operand (left to right):
   - Extract fields from operand (look up struct definition or use anonymous fields)
   - For each field in operand:
     - If field name **not in working set**, add field
     - If field name **already in working set**, skip (leftmost wins)
3. Generate StructDef from working set fields

**Example:**

```kintsu
struct Base {
    id: i64,
    version: i32,
    name: str
};

struct Extended {
    version: i32,  // Conflict
    description: str
};

type Merged = Base & Extended;
```

**Merge steps:**

1. Process Base -> add `id`, `version`, `name` to working set
2. Process Extended:
   - Check `version` -> already in working set -> skip
   - Check `description` -> not in working set -> add

**Result:** `{ id, version, name, description }` (version from Base)

> [!IMPORTANT]
> The working set preserves insertion order to maintain field order from the source schema. Field order matches the order of first occurrence across operands.

### Nested union resolution

Parenthesized unions are resolved recursively before merging with outer operands:

**Algorithm:**

1. When processing operand:
   - If operand is `IdentOrUnion::Union { inner }`, recursively merge inner operands
   - Treat merged result as a single operand with the combined field set
2. Continue merging outer operands

**Example:**

```kintsu
type Combined = A & (B & C);
```

**Resolution:**

1. Identify inner union `(B & C)`
2. Merge B and C -> intermediate field set
3. Merge A with intermediate field set

> [!NOTE]
> Recursive resolution ensures nested unions are flattened before outer merging.

### Context-based name generation

The generated struct name is determined from the union's usage context:

**Type alias:** Use alias name

```kintsu
type UserData = User & Permissions;
// Generated name: UserData
```

**Struct field:** Concatenate parent struct name + field name (PascalCase)

```kintsu
struct Request {
    auth: User & Permissions
};
// Context stack: [namespace, Request, auth]
// Generated name: RequestAuth
```

**Oneof variant:** Use parent name + variant index (1-indexed)

```kintsu
type Response = oneof (A & B) | (C & D);
// Context stacks: [namespace, Response] + variant_index
// Generated names: Response1, Response2
```

**Name generation algorithm:**

1. If union is in type alias target, use alias name
2. Otherwise, join context stack with PascalCase conversion:
   - For oneof variants, append variant index
   - Filter out "Result" markers for operation return types

> [!IMPORTANT]
> Name generation follows the same rules as anonymous structs (SPEC-0003) to ensure consistency.

### Struct synthesis and registration

After field merging, the compiler synthesizes a StructDef and registers it:

**Synthesis:**

1. Create StructDef with:
   - Name: generated from context
   - Fields: merged field list from working set
   - Metadata: empty (unions inherit no metadata)
   - Source: union source file path
2. Add StructDef to namespace children
3. Mark as available for type resolution

**Example:**

```kintsu
type AuthUser = User & Permissions;
```

**Synthesized struct:**

```rust
StructDef {
    name: "AuthUser",
    fields: [/* merged from User and Permissions */],
    metadata: [],
    source: "path/to/schema.ks"
}
```

> [!NOTE]
> The synthesized struct is indistinguishable from explicitly declared structs in subsequent compilation phases.

## Acceptance Criteria

- **AC-1:** Union identification scans all type positions and records context
- **AC-2:** Operand validation enforces struct-only restriction before merging
- **AC-3:** Field merging uses left-to-right precedence with leftmost field winning conflicts
- **AC-4:** Nested unions are resolved recursively before outer merging
- **AC-5:** Context-based name generation produces predictable struct names
- **AC-6:** Synthesized structs are registered and available for type resolution
- **AC-7:** Field order in merged structs matches first occurrence order across operands

## Design Principles

- **Scan all positions:** Identify unions in all type expression contexts
- **Validate early:** Reject non-struct operands before attempting merging
- **Left-to-right merging:** Process operands in order with deterministic conflict resolution
- **Context-aware naming:** Generate meaningful struct names from usage context
- **Struct equivalence:** Merged structs behave identically to explicit structs

## Implications

**For implementers:**

- Union identification must scan all type positions (struct fields, operations, oneofs, arrays, etc.)
- Struct-only validation is critical for type safety
- Left-to-right merging algorithm is normative and deterministic
- Working set must preserve field insertion order

**For code generators:**

- Merged structs have predictable names based on context
- Field conflicts are resolved deterministically (leftmost wins)
- All union operands can be validated before code generation

**For tooling:**

- Union merging can be traced step-by-step for debugging
- Field conflicts can be reported with the winning operand
- Context stacks provide full path information for error messages

## References

- [RFC-0007](/specs/rfc/rfc-0007) - Union type design rationale
- [TSY-0007](/specs/tsy/tsy-0007) - Union type type-system rules
- [SPEC-0002](/specs/spec/spec-0002) - Struct compilation
- [SPEC-0003](/specs/spec/spec-0003) - Anonymous struct compilation
- [SPEC-0006](/specs/spec/spec-0006) - Type alias compilation
