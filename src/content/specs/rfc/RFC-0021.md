---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: RFC
number: 21
status: draft
title: Declaration Bundle Format
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0021: Declaration Bundle Format

## Abstract

This RFC specifies the Declaration Bundle format, the JSON serialization of compiled Kintsu schemas for registry distribution and tooling integration. The format captures type definitions without source spans, suitable for consumption by code generators and other downstream tools.

## Motivation

Compiled schemas need a standardized interchange format for:

1. **Registry Storage** - Publish packages to schema registries
2. **Code Generation** - Feed type definitions to language-specific generators
3. **Tooling Integration** - IDE support, documentation generators, analyzers
4. **Cross-Platform Distribution** - Share compiled schemas without source

The declaration bundle is a "binary" output format (JSON) that strips source locations while preserving all type information needed for consumption.

## Specification

### Output Format

Declaration bundles are JSON files with the `.kintsu.json` extension:

```
my-package-1.0.0.kintsu.json
```

### Version Envelope

The bundle uses a versioned envelope with tagged content:

```json
{
  "version": "v1",
  "declarations": {
    "root": { ... },
    "dependencies": { ... }
  }
}
```

The outer structure is `DeclarationVersion`, which wraps the inner `DeclarationBundle`.

### DeclarationBundle Structure

```json
{
  "version": "v1",
  "declarations": {
    "root": {
      "package": "my-package",
      "namespaces": { ... },
      "external_refs": [ ... ]
    },
    "dependencies": {
      "dep_a": { ... },
      "dep_b": { ... }
    }
  }
}
```

| Field          | Type                                 | Description                                     |
| -------------- | ------------------------------------ | ----------------------------------------------- |
| `root`         | TypeRegistryDeclaration              | The compiled package                            |
| `dependencies` | Map<String, TypeRegistryDeclaration> | Compiled dependencies (keyed by namespace name) |

### TypeRegistryDeclaration

Each package (root or dependency) is represented as:

```json
{
  "package": "my-package",
  "namespaces": {
    "types": { ... },
    "api": { ... }
  },
  "external_refs": [
    {
      "context": { "package": "dep_a", "namespace": ["types"] },
      "name": "User"
    }
  ]
}
```

| Field           | Type                   | Description                                             |
| --------------- | ---------------------- | ------------------------------------------------------- |
| `package`       | String                 | Package name (kebab-case)                               |
| `namespaces`    | Map<String, Namespace> | Namespace names (without package prefix) to definitions |
| `external_refs` | Array of TypeRef       | External type references used by this package           |

### Namespace Structure

Each namespace contains its name and type definitions:

```json
{
  "types": {
    "name": "types",
    "types": [
      { "definition_type": "struct", ... },
      { "definition_type": "enum", ... },
      { "definition_type": "type_alias", ... }
    ]
  }
}
```

| Field   | Type                    | Description                        |
| ------- | ----------------------- | ---------------------------------- |
| `name`  | String                  | Namespace name                     |
| `types` | Array of TypeDefinition | Type definitions in this namespace |

### Type Definitions

Type definitions use a `definition_type` field to indicate the kind:

#### Struct

```json
{
  "definition_type": "struct",
  "name": "User",
  "fields": [
    {
      "name": "id",
      "ty": { "type": "builtin", "ty": "u64" },
      "optional": false
    },
    {
      "name": "email",
      "ty": { "type": "builtin", "ty": "str" },
      "optional": true
    }
  ],
  "meta": { "version": 1 }
}
```

#### Enum (Value)

```json
{
  "definition_type": "enum",
  "name": "Status",
  "enum_def": {
    "enum_type": "int",
    "variants": [
      { "name": "Active", "value": 0 },
      { "name": "Inactive", "value": 1 },
      { "name": "Pending", "value": 2 }
    ]
  },
  "meta": { "version": 1 }
}
```

The `enum_type` can be `"int"` for integer values or `"str"` for string values.

#### Type Alias

```json
{
  "definition_type": "type_alias",
  "name": "UserId",
  "target": { "type": "builtin", "ty": "u64" },
  "meta": { "version": 1 }
}
```

Aliases can target builtin types or named types:

````json
{
  "definition_type": "type_alias",
  "name": "UserRef",
  "target": {
    "type": "named",
    "reference": {
      "context": { "package": "other_pkg", "namespace": ["types"] },
      "name": "User"
    }
  },
  "meta": { "version": 1 }
}

### Type References

Types are referenced using structured objects:

#### Builtin Types

```json
{ "type": "builtin", "ty": "u64" }
{ "type": "builtin", "ty": "str" }
{ "type": "builtin", "ty": "bool" }
{ "type": "builtin", "ty": "datetime" }
````

#### Named Types (Same Package)

```json
{
  "type": "named",
  "reference": {
    "context": { "package": "my_pkg", "namespace": ["types"] },
    "name": "User"
  }
}
```

#### Named Types (External Package)

```json
{
  "type": "named",
  "reference": {
    "context": { "package": "other_pkg", "namespace": ["types"] },
    "name": "ExternalType"
  }
}
```

The `context` object contains:

- `package`: The package namespace name (snake_case)
- `namespace`: Array of namespace path segments

### Complete Example

```json
{
  "version": "v1",
  "declarations": {
    "root": {
      "package": "root-pkg",
      "namespaces": {
        "types": {
          "name": "types",
          "types": [
            {
              "definition_type": "struct",
              "name": "RootPkgData",
              "fields": [
                {
                  "name": "id",
                  "ty": { "type": "builtin", "ty": "u64" },
                  "optional": false
                },
                {
                  "name": "status",
                  "ty": {
                    "type": "named",
                    "reference": {
                      "context": {
                        "package": "root_pkg",
                        "namespace": ["types"]
                      },
                      "name": "RootPkgStatus"
                    }
                  },
                  "optional": false
                }
              ],
              "meta": { "version": 1 }
            },
            {
              "definition_type": "enum",
              "name": "RootPkgStatus",
              "enum_def": {
                "enum_type": "int",
                "variants": [
                  { "name": "Active", "value": 0 },
                  { "name": "Inactive", "value": 1 },
                  { "name": "Pending", "value": 2 }
                ]
              },
              "meta": { "version": 1 }
            },
            {
              "definition_type": "type_alias",
              "name": "PkgRef",
              "target": {
                "type": "named",
                "reference": {
                  "context": { "package": "dep_pkg", "namespace": ["types"] },
                  "name": "DepData"
                }
              },
              "meta": { "version": 1 }
            }
          ]
        }
      },
      "external_refs": [
        {
          "context": { "package": "dep_pkg", "namespace": ["types"] },
          "name": "DepData"
        }
      ]
    },
    "dependencies": {
      "dep_pkg": {
        "package": "dep-pkg",
        "namespaces": {
          "types": {
            "name": "types",
            "types": [
              {
                "definition_type": "struct",
                "name": "DepData",
                "fields": [
                  {
                    "name": "value",
                    "ty": { "type": "builtin", "ty": "str" },
                    "optional": false
                  }
                ],
                "meta": { "version": 1 }
              }
            ]
          }
        },
        "external_refs": []
      }
    }
  }
}
```

### Checksum Computation

The declaration bundle checksum (used in lockfiles) is computed as:

1. Serialize the `DeclarationBundle` to canonical JSON (sorted keys, no extra whitespace)
2. Compute SHA-256 hash of the UTF-8 bytes
3. Encode as `sha256:{hex}`

## Rationale

### JSON Format

JSON was chosen for declaration bundles because:

- Universal parsing support across languages
- Human-readable for debugging
- Efficient tooling ecosystem
- Suitable for HTTP API responses (registries)

### Stripped Spans

Source spans are stripped because:

- Not needed for code generation
- Reduces file size significantly
- Avoids leaking internal source structure
- Checksums remain stable across reformats

### Inline Dependencies

Including compiled dependencies in the bundle:

- Enables offline code generation
- Single file contains everything needed
- Simplifies tooling integration
- Dependencies are immutable once locked

### TypeRegistryDeclaration Name

The "TypeRegistry" name reflects:

- Designed for registry storage/retrieval
- Contains only type information (no source)
- "Declaration" indicates these are declarations, not implementations

## Acceptance Criteria

- [ ] AC-1: Compiler outputs valid JSON matching this specification
- [ ] AC-2: All type definitions serialize correctly
- [ ] AC-3: External references are tracked in the `external` array
- [ ] AC-4: Checksum computation is deterministic
- [ ] AC-5: Bundle can be deserialized and used for code generation
- [ ] AC-6: Dependencies are included when specified

## Backwards Compatibility

This is the initial specification of the declaration bundle format. The version envelope ensures future versions can extend without breaking existing parsers.

Consumers encountering unknown versions SHOULD:

1. Check if `declarations` key exists (v1+ structure)
2. Attempt to parse as latest known version
3. Report clear errors for incompatible formats

## References

- [RFC-0019](/specs/rfc/RFC-0019) - Package Manifest Format
- [RFC-0020](/specs/rfc/RFC-0020) - Lockfile Format
- [SPEC-0020](/specs/spec/SPEC-0020) - Declaration Bundle Implementation
