---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: RFC
number: 18
status: draft
title: Type Expression Design
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Enhanced code blocks with expressive-code markers
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0018: Type Expression Design

## Abstract

This RFC defines type expressions: compile-time operators that transform, select, and project types in Kintsu. Type expressions enable schema authors to derive new types from existing ones without manual duplication—selecting fields, marking optionality, extracting array elements, and narrowing oneof variants. The feature uses a bracket-based syntax (`Operator[Target, selectors]`) that composes with existing type system features.

## Motivation

### The Type Derivation Problem

Schema authors frequently need types that are variations of existing types:

- A `UserPatch` type with all fields optional for PATCH operations
- A `UserSummary` type with only `id` and `name` fields
- An `InfallibleResponse` type excluding error variants
- The element type of an array field for validation schemas

Without type expressions, authors must manually define these derived types:

```kintsu
// Manual derivation - tedious and error-prone
struct User {
    id: i64,
    name: str,
    email: str,
    password_hash: str,
    created_at: datetime
};

// Must manually keep in sync with User
struct UserSummary {
    id: i64,
    name: str
};

// Must manually keep in sync with User
struct UserPatch {
    id?: i64,
    name?: str,
    email?: str,
    password_hash?: str,
    created_at?: datetime
};
```

This approach is:

- **Error-prone**: Changes to `User` require manual updates to derived types
- **Verbose**: Simple derivations require full type definitions
- **Non-compositional**: Cannot express complex derivations concisely

### Design Goals

1. **Declarative derivation**: Express type transformations as operations on source types
2. **Compile-time resolution**: All expressions resolve during compilation with no runtime cost
3. **Compositional**: Expressions compose with each other and existing operators (`&`, `|`, `&|`)
4. **Intuitive syntax**: Bracket-based syntax parallel to existing Kintsu patterns
5. **Type-safe**: Invalid expressions produce clear compile-time errors

### Scope

Type expressions operate on:

- **Struct types**: Field selection, optionality, omission
- **OneOf types**: Variant extraction and exclusion
- **Array types**: Element type extraction
- **Field access**: Direct type projection via `::`

**Excluded** (future consideration):

- Conditional types
- Mapped types (beyond built-in operators)
- Template literal types
- Deep recursive transformations

## Specification

### Type Expression Operators

Kintsu provides eight type expression operators:

| Operator    | Syntax                                 | Purpose                      | Applies To   |
| ----------- | -------------------------------------- | ---------------------------- | ------------ |
| `Pick`      | `Pick[T, a \| b]`                      | Select only specified fields | Struct       |
| `Omit`      | `Omit[T, a \| b]`                      | Remove specified fields      | Struct       |
| `Partial`   | `Partial[T]` or `Partial[T, a \| b]`   | Make fields optional         | Struct       |
| `Required`  | `Required[T]` or `Required[T, a \| b]` | Make fields required         | Struct       |
| `Exclude`   | `Exclude[T, V1 \| V2]`                 | Remove variants from oneof   | OneOf        |
| `Extract`   | `Extract[T, V1 \| V2]`                 | Keep only specified variants | OneOf        |
| `ArrayItem` | `ArrayItem[T]`                         | Get element type from array  | Array        |
| `::`        | `T::field`                             | Access field/variant type    | Struct/OneOf |

### Struct Operators

#### Pick

Selects only the specified fields from a struct type.

**Syntax:** `Pick[StructType, field1 | field2 | ...]`

**Schema:**

```kintsu
struct User {
    id: i64,
    name: str,
    email: str,
    password_hash: str,
    created_at: datetime
};

type UserSummary = Pick[User, id | name];
```

**Resolved type:**

```kintsu
// UserSummary resolves to:
struct UserSummary {
    id: i64,
    name: str
};
```

**Constraints:**

- All specified fields must exist on the source struct
- At least one field must be specified
- Field optionality is preserved from the source

#### Omit

Removes the specified fields from a struct type.

**Syntax:** `Omit[StructType, field1 | field2 | ...]`

**Schema:**

```kintsu
struct User {
    id: i64,
    name: str,
    email: str,
    password_hash: str
};

type PublicUser = Omit[User, password_hash];
```

**Resolved type:**

```kintsu
// PublicUser resolves to:
struct PublicUser {
    id: i64,
    name: str,
    email: str
};
```

**Constraints:**

- All specified fields must exist on the source struct
- At least one field must remain after omission
- Field optionality is preserved for remaining fields

#### Partial

Makes fields optional. Can apply to all fields or specific fields.

**Syntax:** `Partial[StructType]` or `Partial[StructType, field1 | field2 | ...]`

**Schema (all fields):**

```kintsu
struct User {
    id: i64,
    name: str,
    email: str
};

type UserPatch = Partial[User];
```

**Resolved type:**

```kintsu
// UserPatch resolves to:
struct UserPatch {
    id?: i64,
    name?: str,
    email?: str
};
```

**Schema (specific fields):**

```kintsu
struct CreateUser {
    id: i64,
    name: str,
    email?: str,
    bio?: str
};

type FlexibleCreate = Partial[CreateUser, name];
```

**Resolved type:**

```kintsu
// FlexibleCreate resolves to:
struct FlexibleCreate {
    id: i64,
    name?: str,      // Made optional
    email?: str,     // Already optional
    bio?: str        // Already optional
};
```

**Constraints:**

- Source must be a struct type
- When specifying fields, all must exist on the source
- Applying `Partial` to already-optional fields is a no-op (idempotent)

#### Required

Makes fields required. Can apply to all fields or specific fields.

**Syntax:** `Required[StructType]` or `Required[StructType, field1 | field2 | ...]`

**Schema (all fields):**

```kintsu
struct UserInput {
    id?: i64,
    name?: str,
    email?: str
};

type ValidatedUser = Required[UserInput];
```

**Resolved type:**

```kintsu
// ValidatedUser resolves to:
struct ValidatedUser {
    id: i64,
    name: str,
    email: str
};
```

**Schema (specific fields):**

```kintsu
struct UserInput {
    id?: i64,
    name?: str,
    email?: str,
    bio?: str
};

type UserWithId = Required[UserInput, id | name];
```

**Resolved type:**

```kintsu
// UserWithId resolves to:
struct UserWithId {
    id: i64,       // Made required
    name: str,     // Made required
    email?: str,   // Unchanged
    bio?: str      // Unchanged
};
```

**Constraints:**

- Source must be a struct type
- When specifying fields, all must exist on the source
- Applying `Required` to already-required fields is a no-op (idempotent)

### OneOf Operators

#### Exclude

Removes specified variants from a oneof type.

**Syntax:** `Exclude[OneOfType, Variant1 | Variant2 | ...]`

**Schema:**

```kintsu
struct Success { data: str };
struct NotFound { resource: str };
struct Unauthorized { reason: str };
struct ServerError { code: i32 };

type ApiResponse = oneof Success | NotFound | Unauthorized | ServerError;

type SuccessfulResponse = Exclude[ApiResponse, NotFound | Unauthorized | ServerError];
```

**Resolved type:**

```kintsu
// SuccessfulResponse resolves to:
type SuccessfulResponse = oneof Success;
// Or simplified to just Success since single-variant
```

> [!NOTE]
> When exclusion results in a single variant, the type may simplify to that variant's type directly, depending on context.

**Constraints:**

- Source must be a oneof type
- All specified variants must exist in the source
- At least one variant must remain after exclusion

#### Extract

Keeps only the specified variants from a oneof type.

**Syntax:** `Extract[OneOfType, Variant1 | Variant2 | ...]`

**Schema:**

```kintsu
type ApiResponse = oneof Success | NotFound | Unauthorized | ServerError;

type ClientErrors = Extract[ApiResponse, NotFound | Unauthorized];
```

**Resolved type:**

```kintsu
// ClientErrors resolves to:
type ClientErrors = oneof NotFound | Unauthorized;
```

**Constraints:**

- Source must be a oneof type
- All specified variants must exist in the source
- At least one variant must be specified

### Array Operators

#### ArrayItem

Extracts the element type from an array type.

**Syntax:** `ArrayItem[ArrayType]`

**Schema:**

```kintsu
struct User {
    id: i64,
    tags: str[],
    friends: User[]
};

type Tag = ArrayItem[User::tags];      // str
type Friend = ArrayItem[User::friends]; // User
```

**Constraints:**

- Source must be an array type
- Works with both sized (`T[N]`) and unsized (`T[]`) arrays

### Field Access Operator

#### `::` (Type Projection)

Accesses the type of a field or variant directly.

**Syntax:** `Type::field` or `Type::Variant`

**Schema (struct field access):**

```kintsu
struct User {
    id: i64,
    name: str,
    email?: str,
    profile: {
        avatar: str,
        bio?: str
    },
    tags: str[]
};

type UserId = User::id;           // i64
type UserName = User::name;       // str
type UserEmail = User::email;     // str? (preserves optionality)
type UserProfile = User::profile; // Profile struct type
type UserTags = User::tags;       // str[]
```

**Nested field access:**

```kintsu
type Avatar = User::profile::avatar;  // str
type Bio = User::profile::bio;        // str? (preserves optionality)
```

**Schema (oneof variant access):**

```kintsu
type Response = oneof Success | Error;

type SuccessType = Response::Success;  // Success struct
type ErrorType = Response::Error;      // Error struct
```

**Schema (error variant access):**

```kintsu
error ApiError {
    NotFound { resource: str },
    Timeout(i64),
    Unknown
};

type NotFoundError = ApiError::NotFound;  // struct { resource: str }
type TimeoutValue = ApiError::Timeout;    // i64
```

**Constraints:**

- Field/variant must exist on the source type
- Cannot access through non-object types (scalars, enums)
- Array access returns the array type; use `ArrayItem` for element type
- Optionality is preserved in the result type

### Composition

Type expressions compose with each other and existing type operators.

#### Nesting Type Expressions

Type expressions can be nested:

```kintsu
struct User {
    id: i64,
    name: str,
    email: str,
    password_hash: str,
    created_at: datetime,
    updated_at?: datetime
};

// Pick then Partial
type UserPatchFields = Partial[Pick[User, name | email]];
// Result: { name?: str, email?: str }

// Omit then Required
type StrictUser = Required[Omit[User, password_hash]];
// Result: { id: i64, name: str, email: str, created_at: datetime, updated_at: datetime }
```

#### Composition with Union (`&`)

Type expressions compose with union operators:

```kintsu
struct User { id: i64, name: str };
struct Timestamps { created_at: datetime, updated_at: datetime };

type UserWithTimestamps = Pick[User, id | name] & Timestamps;
// Result: { id: i64, name: str, created_at: datetime, updated_at: datetime }
```

#### Composition with OneOf (`|`)

Type expressions compose with oneof:

```kintsu
type SafeResponse = oneof Extract[ApiResponse, Success] | FallbackSuccess;
```

#### Composition with Union Or (`&|`)

Type expressions compose with union or:

```kintsu
struct A { foo: i32, bar: str };
struct B { foo: str, baz: bool };

type Merged = Pick[A, foo] &| Pick[B, foo];
// Result: { foo: oneof i32 | str }
```

### Invalid Compositions

Certain compositions are invalid and produce compile errors:

**Scalar types:**

```kintsu del={1,2}
type Invalid = Pick[i32, x];  // ERROR: Pick requires struct type
type Invalid = Partial[str];  // ERROR: Partial requires struct type
```

**Empty results:**

```kintsu del={1-3}
type Invalid = Pick[User, ];                    // ERROR: empty field list
type Invalid = Omit[User, id | name | email];   // ERROR: no fields remain (if User has exactly these fields)
type Invalid = Exclude[Response, Success | Error]; // ERROR: no variants remain
```

**Non-existent fields/variants:**

```kintsu del={1,2}
type Invalid = Pick[User, nonexistent];         // ERROR: field 'nonexistent' not found
type Invalid = Exclude[Response, Unknown];      // ERROR: variant 'Unknown' not found
```

**Type mismatch:**

```kintsu del={1,2}
type Invalid = ArrayItem[User];                 // ERROR: ArrayItem requires array type
type Invalid = Exclude[User, id];               // ERROR: Exclude requires oneof type
```

**Cancelling operations:**

```kintsu del={2}
type Invalid = Required[Partial[User]];         // Valid, but consider if this is intentional
type Invalid = Pick[Omit[User, id], id];        // ERROR: field 'id' not found (was omitted)
```

## Rationale

### Bracket Syntax

The bracket syntax `Operator[Target, selectors]` was chosen for several reasons:

1. **Parallel to TypeScript**: Familiar to developers from TypeScript's utility types
2. **Distinct from generics**: Kintsu doesn't have generics yet; brackets signal "compile-time operation"
3. **Composable**: Easy to nest and chain operations
4. **Identifier selectors**: Using bare identifiers (not strings) enables IDE support and refactoring

### Pipe-Separated Selectors

The pipe `|` character separates selectors to parallel oneof syntax:

```kintsu
type Response = oneof Success | Error;           // Variant alternatives
type Summary = Pick[User, id | name | email];    // Field selection
type Errors = Extract[Response, NotFound | Unauthorized]; // Variant selection
```

This creates intuitive symmetry: `|` means "or" / "alternatives" throughout the language.

### Field Access via `::`

The `::` operator was chosen over alternatives:

- `User.id` — Could conflict with potential namespace syntax
- `User["id"]` — String-based, less IDE-friendly
- `User::id` — Clear, distinct, mirrors Rust's path separator

The double-colon also chains naturally: `User::profile::avatar`.

### Resolution as Type Alias

Type expressions resolve to type aliases before standard alias resolution. This means:

1. No new compilation infrastructure required
2. Inherits all existing alias semantics (versioning, naming, etc.)
3. Generated types behave identically to hand-written types

### Compile-Time Only

Type expressions are purely compile-time. They:

- Have no runtime representation
- Don't affect serialization or tagging
- Cannot appear in metadata/attributes
- Resolve completely before code generation

This keeps the feature simple and predictable.

## Future Considerations

### Deep Transformations

`DeepPartial` and `DeepRequired` variants could recursively apply optionality:

```kintsu
// Future syntax (not in v1)
type DeepPatch = DeepPartial[User];
// Makes all fields optional, recursively through nested structs
```

**Challenges:**

- Selector syntax for deep paths is complex
- Circular references require careful handling
- May significantly increase type complexity

### Conditional Types

Future versions could support conditional type logic:

```kintsu
// Future syntax (not in v1)
type Result = T extends Error ? Failure : Success;
```

Requires generics infrastructure first.

### Mapped Types

Future versions could support type-level mapping:

```kintsu
// Future syntax (not in v1)
type Nullable[T] = { [K in keyof T]: T[K] | null };
```

Requires generics and keyof-like introspection.

## Backwards Compatibility

Type expressions are purely additive. Existing schemas remain valid. The new operators (`Pick`, `Omit`, etc.) are reserved keywords in type expression context only—existing identifiers with these names in other contexts remain valid.

## References

- [RFC-0006](/specs/rfc/RFC-0006) - Type Alias Design
- [RFC-0007](/specs/rfc/RFC-0007) - Union Type Support
- [RFC-0008](/specs/rfc/RFC-0008) - OneOf Type Design
- [RFC-0016](/specs/rfc/RFC-0016) - Union Or (`&|`)
- [TSY-0006](/specs/tsy/TSY-0006) - Type Aliases
- [TSY-0014](/specs/tsy/TSY-0014) - Type Expression Rules
- [SPEC-0017](/specs/spec/SPEC-0017) - Type Expression Compilation
