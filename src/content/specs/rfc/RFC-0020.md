---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: RFC
number: 20
status: draft
title: Lockfile Format
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0020: Lockfile Format

## Abstract

This RFC specifies the format and semantics of the Kintsu lockfile (`schema.lock.toml`). The lockfile records the exact resolved versions of all dependencies for reproducible builds.

## Motivation

Lockfiles serve critical functions in package management:

1. **Reproducibility** - Ensure identical dependency trees across builds
2. **Auditability** - Track exactly which versions are in use
3. **Security** - Verify package integrity via checksums
4. **Performance** - Skip resolution when dependencies haven't changed

The lockfile captures the result of dependency resolution, freezing the dependency graph until explicitly updated.

## Specification

### File Location and Name

The lockfile MUST be named `schema.lock.toml` and placed alongside `schema.toml` at the package root.

```text title="Package structure"
my-package/
  schema.toml           # Package manifest
  schema.lock.toml      # Lockfile (this spec)
  schema/
    lib.ks
```

The lockfile SHOULD be committed to version control.

### Version Envelope

Like the manifest, the lockfile uses a versioned envelope:

```toml title="schema.lock.toml"
version = "v1"

[root]
name = "my-package"
# ...

[packages."dep-a@1.2.3"]
name = "dep-a"
# ...
```

### Root Package

The `[root]` section records the root package's resolved state:

```toml title="schema.lock.toml"
version = "v1"

[root]
name = "my-package"
version = "1.0.0"
checksum = "sha256:abc123..."

[root.source]
type = "path"
path = "."

[root.dependencies.dep_a]
version = "1.2.3"
provides = ["types"]
chain = ["my-package", "dep_a"]
```

### Locked Packages

Each dependency is recorded under `[packages."name@version"]`:

```toml title="schema.lock.toml"
[packages."dep-a@1.2.3"]
name = "dep-a"
version = "1.2.3"
checksum = "sha256:def456..."

[packages."dep-a@1.2.3".source]
type = "registry"
url = "https://registry.kintsu.dev"

[packages."dep-a@1.2.3".dependencies.dep_b]
version = "2.0.0"
provides = ["utils"]
chain = ["dep_a", "dep_b"]
```

### Locked Package

Each `[[packages]]` entry represents a resolved dependency:

| Field          | Type            | Required | Description                     |
| -------------- | --------------- | -------- | ------------------------------- |
| `name`         | String          | Yes      | Package name                    |
| `version`      | String (semver) | Yes      | Resolved version                |
| `checksum`     | String          | Yes      | Content hash (see Checksums)    |
| `source`       | LockedSource    | Yes      | Where package was resolved from |
| `dependencies` | Array           | No       | Transitive dependencies         |

### Locked Source

The `source` table indicates where the package was resolved from, using a `type` field:

#### Registry Source

```toml title="schema.lock.toml"
[packages."pkg@1.0.0".source]
type = "registry"
url = "https://registry.kintsu.dev"
```

#### Git Source

```toml title="schema.lock.toml"
[packages."pkg@1.0.0".source]
type = "git"
url = "https://github.com/org/repo"
rev = "abc123def456"
```

Git sources MUST include the resolved commit hash (`rev`), even if the manifest specified a branch or tag.

#### Path Source

```toml title="schema.lock.toml"
[packages."pkg@1.0.0".source]
type = "path"
path = "../local-package"
```

Path sources record the relative path from the root package.

### Locked Dependencies

Dependencies are recorded as sub-tables under the package, keyed by the dependency's namespace name (snake_case):

```toml title="schema.lock.toml"
[root.dependencies.std_types]
version = "1.0.0"
provides = ["types", "errors"]
chain = ["my-package", "std_types"]
```

Each dependency entry contains:

| Field      | Type            | Description                                 |
| ---------- | --------------- | ------------------------------------------- |
| `version`  | String          | Resolved version of the dependency          |
| `provides` | Array of String | Namespace names exported by this dependency |
| `chain`    | Array of String | Path through the dependency graph           |

#### The `provides` Field

Lists the namespace names that this dependency exports and the current package uses:

```toml title="schema.lock.toml"
[root.dependencies.std_types]
version = "1.0.0"
provides = ["types", "errors"]
chain = ["my-package", "std_types"]
```

This means `std-types` exports namespaces `std_types::types` and `std_types::errors` which are used by `my-package`.

#### The `chain` Field

Records the dependency path including the dependent and the dependency:

```toml title="schema.lock.toml"
# Direct dependency of root
[root.dependencies.dep_a]
version = "1.0.0"
provides = ["api"]
chain = ["root-pkg", "dep_a"]

# Transitive: dep-a depends on dep-b
[packages."dep-a@1.0.0".dependencies.dep_b]
version = "2.0.0"
provides = ["utils"]
chain = ["dep_a", "dep_b"]
```

The chain enables:

- Cycle detection
- Understanding why a package is included
- Debugging dependency conflicts

### Checksums

Checksums use the format `algorithm:hex-digest`:

```toml title="schema.lock.toml"
checksum = "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
```

The checksum covers the declaration bundle content (see RFC-0021).

Currently only SHA-256 is supported. The algorithm prefix enables future hash upgrades.

### Complete Example

```toml title="schema.lock.toml" collapse={21-40}
version = "v1"

[root]
name = "acme-api"
version = "2.1.0"
checksum = "sha256:e14f33782fbb7531abc123..."

[root.source]
type = "path"
path = "."

[root.dependencies.kintsu_std]
version = "1.0.0"
provides = ["types"]
chain = ["acme-api", "kintsu_std"]

[root.dependencies.corp_common]
version = "2.1.0"
provides = ["models"]
chain = ["acme-api", "corp_common"]

[packages."kintsu-std@1.0.0"]
name = "kintsu-std"
version = "1.0.0"
checksum = "sha256:abc123def456..."

[packages."kintsu-std@1.0.0".source]
type = "registry"
url = "https://registry.kintsu.dev"

[packages."corp-common@2.1.0"]
name = "corp-common"
version = "2.1.0"
checksum = "sha256:789xyz..."

[packages."corp-common@2.1.0".source]
type = "registry"
url = "https://registry.acme.internal"

[packages."corp-common@2.1.0".dependencies.kintsu_std]
version = "1.0.0"
provides = ["types"]
chain = ["corp_common", "kintsu_std"]
```

### Lockfile Operations

#### Generation

The lockfile is generated when:

- Running `kintsu check` with no existing lockfile
- Running `kintsu update` to refresh dependencies
- Adding/removing dependencies in `schema.toml`

#### Validation

On each build, the compiler:

1. Checks lockfile exists and parses correctly
2. Verifies all manifest dependencies have locked entries
3. Validates checksums match fetched content
4. Reports mismatches and prompts for update

#### Update Semantics

- `kintsu update` - Resolve all dependencies fresh, regenerate lockfile
- `kintsu update <package>` - Update specific package only
- `kintsu check` - Use lockfile as-is, fail on mismatch

## Rationale

### TOML Format Consistency

Using TOML for lockfile matches the manifest format, enabling shared tooling and familiar syntax.

### Explicit Checksums

SHA-256 checksums provide:

- Integrity verification (detect tampering/corruption)
- Reproducibility verification (same content everywhere)
- Cache keying (skip re-fetch if checksum matches)

### Provides/Chain Structure

The `provides` and `chain` fields solve several problems:

**provides**: Explicitly records which namespaces flow from each dependency. This enables:

- Precise import resolution without re-parsing all dependencies
- Clear visibility into what each dependency contributes
- Detection of unused dependencies

**chain**: Records the dependency path for:

- Cycle detection (if package appears in own chain)
- Debugging transitive dependency issues
- Understanding why a package is included

### Flat Package List

The lockfile uses a flat `[[packages]]` array rather than a tree because:

- Packages may be shared by multiple dependents
- Flat structure enables simple deduplication
- Dependency relationships are captured in `chain`

## Acceptance Criteria

- [ ] AC-1: Lockfile is generated on first build
- [ ] AC-2: Build fails if lockfile doesn't match manifest
- [ ] AC-3: Checksums are verified on package fetch
- [ ] AC-4: `kintsu update` regenerates lockfile
- [ ] AC-5: Transitive dependencies are recorded with correct chains
- [ ] AC-6: All source types (registry, git, path) are correctly locked

## Backwards Compatibility

This is the initial specification of the lockfile format. The version envelope ensures future versions can extend without breaking existing parsers.

If a lockfile has an unknown version, the compiler MUST:

1. Emit a warning about unknown version
2. Attempt to regenerate the lockfile
3. Fail with clear error if regeneration is not possible

## References

- [RFC-0019](/specs/rfc/RFC-0019.md) - Package Manifest Format
- [RFC-0021](/specs/rfc/RFC-0021.md) - Declaration Bundle Format
- [SPEC-0019](/specs/spec/SPEC-0019.md) - Lockfile Implementation
