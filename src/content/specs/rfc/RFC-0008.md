---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 8
status: draft
title: OneOf Type Design
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0008: OneOf Type Design

## Abstract

This RFC documents the design rationale for oneof types in Kintsu. OneOf types represent discriminated unions where a value can be one of several explicitly enumerated types, separated by `|`. Unlike union types that merge fields through composition, oneof types provide discrimination with a tag field that identifies which variant is active. The design supports variant ordering, anonymous struct extraction, and nested oneof expressions.

## Motivation

Type-safe polymorphism is essential for representing data that can take different shapes. Without oneof, schema authors must use weak typing or complex workarounds:

**Without oneof (weak typing):**

```kintsu
struct Response {
    success: bool,
    data: str,      // Only present if success=true
    error: str      // Only present if success=false
};
```

This approach has several problems:

- No compile-time guarantee that only one field is populated
- Code generators must handle all combinations
- Documentation is ambiguous about which fields are mutually exclusive

**With oneof (discriminated union):**

```kintsu
struct Success {
    data: str
};

struct Error {
    message: str,
    code: i32
};

type Response = oneof Success | Error;
```

OneOf types provide explicit discrimination with compile-time safety and clear semantics.

### Why OneOf Types?

**Type safety:** Discriminated unions prevent invalid state combinations. Only one variant can be active at a time.

**Explicit variants:** All possible types are enumerated, making the API contract clear.

**Code generation:** Discriminated unions map naturally to sum types (Rust enums, TypeScript discriminated unions, etc.).

**API flexibility:** Operations can return different response shapes without losing type information.

## Specification

### Syntax

OneOf types use the `oneof` keyword followed by pipe-separated type expressions:

```kintsu
oneof TypeA | TypeB | TypeC
```

**In type alias:**

```kintsu
type Value = oneof i32 | str | bool;
```

**In struct field:**

```kintsu
struct Record {
    data: oneof i32 | f32 | str
};
```

**With arrays (requires parentheses):**

```kintsu
type Numbers = (oneof i32 | f32)[];
```

**With named types:**

```kintsu
type Response = oneof Success | Error;
```

**With anonymous structs:**

```kintsu
type Result = oneof {
    success: bool,
    data: str
} | {
    error: str,
    code: i32
};
```

### Discriminant Strategy

OneOf types are discriminated unions â€” generated code includes a tag field that identifies which variant is active. The discriminant strategy varies by target language:

**Rust:** Enum with variants

```rust
pub enum Response {
    Success(Success),
    Error(Error),
}
```

**TypeScript:** Discriminated union with literal type tag

```typescript
type Response =
  | { kind: "Success"; value: Success }
  | { kind: "Error"; value: Error };
```

> [!IMPORTANT]
> The discriminant mechanism is target-language specific, but the source schema remains language-agnostic. Code generators determine the appropriate representation.

### Variant Ordering

Variants are parsed in declaration order and preserved. The order determines discriminant values in generated code:

```kintsu
type Status = oneof Active | Pending | Completed;
```

**Discriminants:**

- Variant 0: Active
- Variant 1: Pending
- Variant 2: Completed

> [!NOTE]
> Variant order is significant and must be preserved across compilations to maintain binary compatibility in serialization formats.

### Anonymous Struct Variants

Anonymous struct definitions in oneof variants are extracted and numbered sequentially:

```kintsu
type Response = oneof {
    success: bool,
    data: str
} | {
    error: str,
    code: i32
};
```

**After extraction:**

```kintsu
struct Response1 {
    success: bool,
    data: str
};

struct Response2 {
    error: str,
    code: i32
};

type Response = oneof Response1 | Response2;
```

Numbering starts at 1 and increments sequentially.

### Union Variants

OneOf variants can contain union expressions. Unions are resolved before the oneof is finalized:

```kintsu
type Data = oneof (Base & Extensions) | (Alt & More);
```

**Resolution steps:**

1. Resolve union `(Base & Extensions)` -> generates `Data1`
2. Resolve union `(Alt & More)` -> generates `Data2`
3. Final oneof: `oneof Data1 | Data2`

## Rationale

### Why Discriminated Unions Instead of Tagged Unions?

Discriminated unions (oneof) use structural discrimination via type tags, while tagged unions use explicit tag fields in the schema. Discriminated unions provide:

- **Language flexibility:** Code generators can use native sum types
- **Cleaner schemas:** No need to manually define tag fields
- **Type safety:** Impossible to construct invalid states

### Why Pipe Syntax?

The pipe (`|`) syntax is familiar from many languages (TypeScript, Rust, etc.) and clearly denotes alternatives:

```kintsu
oneof A | B | C  // One of these types
```

This is more intuitive than alternatives like `oneof(A, B, C)` or `oneof<A | B | C>`.

### Why Preserve Variant Order?

Variant order determines discriminant values, which affect:

- **Binary serialization:** Discriminant values must be stable across versions
- **Code generation:** Consistent variant indexing in generated enums
- **Documentation:** Variant order matches source schema order

### Why Extract Anonymous Variants?

Anonymous struct extraction provides:

- **Consistent naming:** `Response1`, `Response2` instead of unpredictable context-based names
- **Simpler code generation:** All variants are named types
- **Clear semantics:** Each variant has an explicit identity

### Why Support Union Variants?

Union variants enable composition within discrimination:

```kintsu
type ApiResponse = oneof (Success & Metadata) | (Error & Metadata);
```

This combines union's composition with oneof's discrimination, providing flexibility without complexity.

### OneOf vs Union: When to Use Each?

**Use union (A & B) when:**

- Merging fields from multiple structs
- All fields should be present in the result
- Composition via field merging

**Use oneof (A | B) when:**

- Representing alternatives (only one type is active)
- Different response shapes based on conditions
- Discrimination with explicit variant tags

## Acceptance Criteria

- **AC-1:** OneOf types support multiple variants separated by `|`
- **AC-2:** Variant ordering is preserved and determines discriminant values
- **AC-3:** Anonymous struct variants are extracted with sequential numbering (ParentName1, ParentName2, ...)
- **AC-4:** Union variants are resolved before oneof finalization
- **AC-5:** All variant types must resolve to valid types
- **AC-6:** At least two variants are required

## Backwards Compatibility

Future changes to discriminant strategies or variant handling would require careful consideration of serialization compatibility and code generator impacts.

## References

- [TSY-0008](/specs/tsy/tsy-0008) - OneOf type type-system rules
- [SPEC-0008](/specs/spec/spec-0008) - OneOf type compilation implementation
- [RFC-0007](/specs/rfc/rfc-0007) - Union types (for comparison)
- [TSY-0003](/specs/tsy/tsy-0003) - Anonymous structs (for variant extraction)
