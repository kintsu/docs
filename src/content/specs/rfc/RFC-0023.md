---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: RFC
number: 23
status: draft
title: Error Handling Design
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0023: Error Handling Design

## Abstract

This RFC establishes the design principles and coding taxonomy for Kintsu's error handling system. It defines a hierarchical error code structure, domain organisation, severity levels, and diagnostic requirements that prioritise developer experience (DX). The goal is to create a consistent, predictable, and actionable error reporting system across all Kintsu tooling.

## Motivation

### Current State Problems

The Kintsu compiler currently lacks a unified error handling strategy:

1. **Inconsistent error identification**: Error behaviour is scattered across specifications without formal error codes.

2. **Scattered definitions**: Error behaviour is defined inline within feature specifications rather than in a centralised reference, making it difficult to maintain consistency or discover all possible errors.

3. **Missing diagnostic requirements**: No specification defines what help text, suggestions, or related spans are required for each error class.

4. **Phase ambiguity**: Errors are not consistently mapped to compilation phases, making span attachment requirements unclear.

### Design Goals

1. **Predictability**: Developers should be able to predict error code structure from domain knowledge
2. **Discoverability**: Error codes should be searchable and cross-referenceable
3. **Actionability**: Every error must provide guidance for resolution
4. **Consistency**: All errors follow the same format and diagnostic patterns
5. **Extensibility**: New error domains and codes can be added without restructuring

## Specification

### Error Code Structure

Kintsu error codes follow a hierarchical structure:

```
K[Domain][Category][Sequence]
```

| Component  | Format        | Description                                    |
| ---------- | ------------- | ---------------------------------------------- |
| `K`        | Single letter | Kintsu prefix (distinguishes from other tools) |
| `Domain`   | 2 letters     | Error domain identifier                        |
| `Category` | 1 digit       | Error category within domain                   |
| `Sequence` | 3 digits      | Unique sequence within category (001-999)      |

**Example**: `KTR1001` = Kintsu Type Resolution, Resolution category, first error

### Domain Codes

| Code | Domain          | Description                             | Primary Phase         |
| ---- | --------------- | --------------------------------------- | --------------------- | -------------- |
| `LX` | Lexical         | Token formation from raw text           | Lexing                |
| `PR` | Parsing         | AST construction from tokens            | Parsing               |
| `NS` | Namespace       | Namespace declaration and organisation  | Parsing/Resolution    |
| `TY` | Type Definition | Struct, enum, error, oneof declarations | Parsing               |
| `TR` | Type Resolution | Reference resolution, alias handling    | Resolution 1-8        |
| `UN` | Union           | Union (`&`) and Union Or (`&            | `) operations         | Resolution 4-5 |
| `MT` | Metadata        | Version and error attributes            | Resolution 6-7        |
| `TG` | Tagging         | Variant tagging styles                  | Resolution/Validation |
| `TE` | Type Expression | Pick, Omit, Partial, etc. operators     | Resolution            |
| `PK` | Package         | Manifest and lockfile handling          | Configuration         |
| `RG` | Registry        | Client/server API operations            | Runtime               |
| `FS` | Filesystem      | File read/write operations              | Runtime               |
| `IN` | Internal        | Compiler bugs (should never occur)      | Any                   |

### Category Digits

Within each domain, categories group related errors by their nature:

| Digit | Category      | Description                             |
| ----- | ------------- | --------------------------------------- |
| `0`   | Syntax        | Syntactic or structural malformation    |
| `1`   | Resolution    | Name or reference resolution failure    |
| `2`   | Validation    | Semantic constraint violation           |
| `3`   | Conflict      | Duplicate or collision detected         |
| `4`   | Missing       | Required element is absent              |
| `5`   | Cycle         | Circular dependency detected            |
| `6`   | Compatibility | Version or format incompatibility       |
| `7`   | Reserved      | Future use                              |
| `8`   | Warning       | Non-fatal issue (compilation continues) |
| `9`   | Internal      | Internal implementation error           |

### Severity Levels

Each error specifies one of four severity levels:

| Level       | Behaviour            | Description                                   |
| ----------- | -------------------- | --------------------------------------------- |
| **Error**   | Compilation fails    | Fatal issue preventing successful compilation |
| **Warning** | Compilation succeeds | Non-fatal issue that should be addressed      |
| **Info**    | Compilation succeeds | Optional diagnostic for awareness             |
| **Hint**    | IDE-only             | Guidance shown only in IDE, not CLI           |

**Output Behaviour:**

| Severity | CLI Default | CLI --verbose | IDE   |
| -------- | ----------- | ------------- | ----- |
| Error    | Shown       | Shown         | Shown |
| Warning  | Shown       | Shown         | Shown |
| Info     | Hidden      | Shown         | Shown |
| Hint     | Hidden      | Hidden        | Shown |

### Phase Annotations

Errors may occur during multiple compilation phases. Each error definition specifies:

1. **Primary phase**: The phase where the error is most commonly raised
2. **Additional phases**: Other phases where the same error may occur

The compiler emits errors at the most specific location where the error is detected, regardless of which phase detects it.

### Diagnostic Requirements

Every error must define:

| Requirement          | Description                                  |
| -------------------- | -------------------------------------------- |
| **Message template** | Human-readable description with placeholders |
| **Primary span**     | The source location to highlight             |
| **Help text**        | Actionable guidance for resolution           |

Errors may optionally define:

| Requirement       | Description                              |
| ----------------- | ---------------------------------------- |
| **Related spans** | Additional locations providing context   |
| **Suggestions**   | Algorithm for generating fix suggestions |
| **Notes**         | Additional explanatory information       |

## Rationale

### Why Hierarchical Codes?

Flat error codes (like `E0001`) provide no semantic meaning. Hierarchical codes enable:

1. **Domain filtering**: Search all `KTR*` errors for type resolution issues
2. **Category patterns**: `K??5*` finds all circular dependency errors across domains
3. **Predictable structure**: Developers learn the system once, apply everywhere

### Why Separate ERR Specifications?

Feature specifications (TSY, SPEC) define **what validations occur**. Error specifications (ERR) define **how validation failures are reported**. This separation:

1. Keeps feature specs focused on behaviour, not presentation
2. Centralises diagnostic requirements for consistency
3. Enables error catalog tooling without parsing feature specs
4. Allows diagnostic improvements without modifying feature specs

### Why Four Severity Levels?

- **Error/Warning**: Standard compiler output, always relevant
- **Info**: Useful context that may be noise for experienced users
- **Hint**: IDE-specific guidance that would clutter CLI output

### Why the `K` Prefix?

The `K` prefix:

1. Distinguishes Kintsu errors from other tools in mixed environments
2. Enables clear grep/search patterns
3. Follows established conventions (Rust's `E`, TypeScript's `TS`)

## Acceptance Criteria

- [ ] AC-1: All error codes follow the `K[Domain][Category][Sequence]` format
- [ ] AC-2: Every error defines message template, primary span, and help text
- [ ] AC-3: ERR specifications exist for all 13 error domains
- [ ] AC-4: Feature specifications (TSY, SPEC) cross-reference ERR specs instead of defining codes
- [ ] AC-5: Diagnostic output matches specified severity behaviour

## Backwards Compatibility

This RFC defines the error handling system from initial release. No migration is required.

**Before:**

```
error: undefined type: 'Usr'
```

**After:**

```
error[KTR1001]: type 'Usr' not found
  --> schema/api.ks:15:12
   |
15 |     user: Usr,
   |           ^^^ type not found
   |
   = help: did you mean 'User'?
```

## References

- [SPEC-0022](/specs/spec/spec-0022) - Error System Architecture
- [ERR-0001](/specs/err/err-0001) - Error System Overview
