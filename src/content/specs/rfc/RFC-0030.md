---
author: joshua-auchincloss
components:
  - compiler
  - registry
created: 2025-12-27
kind: RFC
number: 30
status: draft
title: Type Introspection
updates:
  - author: joshua-auchincloss
    date: 2025-12-27
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0030: Type Introspection

## Abstract

This RFC specifies type introspection capabilities for Kintsu: the ability to query type information, track dependencies across packages, resolve type chains, and compute diffs between schema versions. Type introspection provides the foundational data layer for versioning guarantees ([RFC-0031](/specs/rfc/rfc-0031)) and cross-package impact analysis.

## Motivation

### The Visibility Problem

When schemas evolve across package boundaries, developers lack visibility into:

1. **Type dependencies** - Which packages reference which types from other packages
2. **Field-level tracking** - How field projections (`Package::Type::field`) resolve
3. **Type chain resolution** - What underlying type an alias chain resolves to
4. **Version diffs** - What changed between two versions of a package

Without introspection, breaking changes propagate silently until runtime failures occurâ€”the infamous null deserialization error when a field was removed upstream.

### Use Cases

**Cross-package field projection tracking:**

```kintsu title="abc-a/schema/types.ks"
struct Foo {
    a: i32
};
```

```kintsu title="foo-bar/schema/types.ks"
struct Bar {
    /// This field's type depends on abc_a::types::Foo::a
    abc_a: abc_a::types::Foo::a
};
```

When `Foo::a` changes type, `foo-bar` maintainers need to be alerted.

**Type chain resolution:**

```kintsu title="schema/types.ks"
type UserId = i64;
type EntityId = UserId;
type AccountId = EntityId;

struct Account {
    id: AccountId  // Resolves to i64
};
```

Introspection must trace `AccountId` -> `EntityId` -> `UserId` -> `i64`.

**Version comparison:**

```
v1.0.0                      v1.1.0
--------------------        --------------------
struct User {               struct User {
    id: i64,                    id: i64,
    name: str                   name: str,
};                              email?: str    // Added
                            };
```

Introspection computes: "Added optional field `email` to `User`".

## Specification

### Introspection Data Model

#### Type Registry Declaration

Each compiled package produces a `TypeRegistryDeclaration` (defined in [RFC-0021](/specs/rfc/rfc-0021)):

```json title="Type registry structure"
{
  "package": "my-package",
  "namespaces": {
    "types": {
      "name": "types",
      "types": [
        { "definition_type": "struct", ... },
        { "definition_type": "enum", ... },
        { "definition_type": "type_alias", ... }
      ]
    }
  },
  "external_refs": [
    {
      "context": { "package": "dep_a", "namespace": ["types"] },
      "name": "User"
    }
  ]
}
```

#### Extended Reference Tracking

This RFC extends `external_refs` to include field-level projections:

```json title="Extended external_refs" {8-9}
{
  "external_refs": [
    {
      "context": { "package": "abc_a", "namespace": ["types"] },
      "name": "Foo",
      "projection": null
    },
    {
      "context": { "package": "abc_a", "namespace": ["types"] },
      "name": "Foo",
      "projection": ["a"]
    }
  ]
}
```

| Field        | Type             | Description                         |
| ------------ | ---------------- | ----------------------------------- |
| `context`    | TypeContext      | Package and namespace path          |
| `name`       | String           | Type name being referenced          |
| `projection` | String[] \| null | Field path if using `::` projection |

#### Type Chain Tracking

Type aliases record their resolution chain:

```json title="Type alias with chain"
{
  "definition_type": "type_alias",
  "name": "AccountId",
  "target": {
    "type": "named",
    "reference": {
      "context": { "package": "my_pkg", "namespace": ["types"] },
      "name": "EntityId"
    }
  },
  "resolved_type": { "type": "builtin", "ty": "i64" },
  "chain": ["AccountId", "EntityId", "UserId", "i64"]
}
```

### Reference Graph

The registry maintains a cross-package reference graph with two components:

**Nodes:**

- Packages (e.g., `abc_a`, `foo_bar`, `baz_qux`)
- Types (e.g., `abc_a::types::Foo`, `foo_bar::types::Bar`)
- Fields (e.g., `abc_a::types::Foo::a`, `foo_bar::types::Bar::x`)

**Edges:**

- `package_depends_on(foo_bar, abc_a)` - package-level dependency
- `type_references(Bar, Foo)` - type-level reference
- `field_projects(Bar::abc_a, Foo::a)` - field projection relationship

The graph is built from:

- Declaration bundle `external_refs`
- Dependency manifest entries
- Field projection tracking during compilation

### Introspection Queries

#### Type Resolution

Resolve a type reference to its full definition:

```
resolve_type("abc_a::types::Foo")
  -> StructDefinition { name: "Foo", fields: [...] }
```

#### Field Type Lookup

Get the type of a specific field:

```
field_type("abc_a::types::Foo::a")
  -> BuiltinType::I32
```

#### Chain Resolution

Resolve an alias to its underlying type:

```
resolve_chain("my_pkg::types::AccountId")
  -> ["AccountId", "EntityId", "UserId", "i64"]
```

#### Dependents Query

Find all packages/types that depend on a given type:

```
dependents("abc_a::types::Foo")
  -> [
      { package: "foo_bar", type: "Bar", field: "abc_a" },
      { package: "baz_qux", type: "Qux", field: "val" }
    ]
```

#### Field Dependents Query

Find all field projections that reference a specific field:

```
field_dependents("abc_a::types::Foo::a")
  -> [
      { package: "foo_bar", type: "Bar", field: "abc_a" }
    ]
```

### Version Diff Computation

Compare two versions of a package to compute changes:

```
diff("my-package", "1.0.0", "1.1.0")
  -> TypeDiff {
      added: [
        { kind: "field", path: "types::User::email", optional: true }
      ],
      removed: [],
      modified: [],
      renamed: []
    }
```

#### Diff Categories

| Category   | Description                                 |
| ---------- | ------------------------------------------- |
| `added`    | New types, fields, variants, operations     |
| `removed`  | Deleted types, fields, variants, operations |
| `modified` | Changed type, optionality, value, tag       |
| `renamed`  | Name changes (detected via heuristics)      |

#### Modification Details

```json title="Modification record"
{
  "kind": "field_type",
  "path": "types::User::id",
  "before": { "type": "builtin", "ty": "i32" },
  "after": { "type": "builtin", "ty": "i64" }
}
```

## Rationale

### Why Extend external_refs

The existing `external_refs` in declaration bundles already tracks type-level dependencies. Extending it with `projection` field:

1. Reuses existing infrastructure
2. Maintains backwards compatibility (null projection = whole type)
3. Enables precise field-level tracking

### Why Store Resolved Chains

Storing `resolved_type` and `chain` on aliases:

1. Enables fast "what's the actual type" queries
2. Supports patch-level validation (intermediate alias must resolve same)
3. Avoids repeated chain traversal

### Why Registry-Stored Graph

The reference graph lives in the registry (not just declaration bundles) because:

1. Cross-package queries require global view
2. Impact analysis spans the entire ecosystem
3. Pruned dependencies provide clean graph

## Acceptance Criteria

- [ ] AC-1: Declaration bundles include field projection tracking in `external_refs`
- [ ] AC-2: Type aliases include `resolved_type` and `chain` fields
- [ ] AC-3: Registry maintains cross-package reference graph
- [ ] AC-4: Field-level projection tracking through `Type::field` syntax

> [!NOTE]
> CLI commands for introspection are specified in a separate CLI RFC.

## Future Considerations

> **Note**: A query language for complex introspection queries could be valuable for tooling integration. For example, "find all structs with a field of type `datetime`" or "find all packages transitively depending on `core-types`". To be considered in a future RFC.

## References

- [RFC-0018](/specs/rfc/rfc-0018) - Type Expression Design (field projection syntax)
- [RFC-0021](/specs/rfc/rfc-0021) - Declaration Bundle Format
- [RFC-0031](/specs/rfc/rfc-0031) - Versioning Guarantees
