---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 1
status: draft
title: Builtin Type System Design
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0001: Builtin Type System Design

## Abstract

This RFC captures the design rationale and non-normative guidance for Kintsu's builtin type set. It describes the goals, trade-offs, and recommended transit representations that downstream code-generators and runtime libraries should follow. The aim is to standardize interoperability for message/schema transit while leaving room for pluggable wire encodings.

## Motivation

Kintsu is a schema and message type system intended primarily for transit (message/schema) use — similar in intent to protobuf/gRPC style systems. A small, well-understood set of builtin scalar and primitive types makes code generation, validation, and cross-language compatibility tractable. This RFC documents the rationale for the chosen builtins and provides recommended canonical transit forms so that independent implementations can interoperate.

## Specification

This RFC is non-normative. Normative semantics (syntax, validation, and resolution) are specified in TSY-0001 and SPEC-0001.

Builtins (authoritative list):

- bool
- str
- i8, i16, i32, i64
- u8, u16, u32, u64
- f16, f32, f64
- complex
- datetime
- never
- binary
- base64

Key decisions captured here:

- Datetime is always represented as a string on the wire and MUST use an ISO-8601 compliant textual form including timezone information (e.g. 2025-10-30T14:23:00Z or 2025-10-30T09:23:00-05:00). Implementations may accept equivalent forms when parsing, but the canonical transit form is ISO-8601 with timezone designator.

- Complex numeric values are represented as objects (struct-like) with named components (see TSY-0001). This keeps the representation explicit and portable across languages that lack a native complex scalar.

- Kintsu supports multiple wire/encoding styles. For integer wire encodings the recommended/suggested approach is fixed-size (e.g., 8/16/32/64-bit little/big-endian as defined by a chosen wire profile) to keep determinism and simple alignment. Alternative encodings (e.g., varint or strict-length encodings) are allowed per wire profile. The choice is intentionally left to the wire/profile (see SPEC). Implementations and wire/profile documentation MUST explicitly document the chosen encoding for each target/profile — this specification defines the messaging protocol and normative transit forms, not internal code-generator or runtime representations.

Binary data has a binary wire representation (raw bytes) and an interoperable textual form (Base64) when textual transport is required.

- `base64`: a textual-first builtin representing bytes encoded using Base64 (RFC 4648). This type exists to make textual transports explicit and to provide a lightweight, validated textual type for DTOs and APIs where raw binary fields are inconvenient. Note: implementation in compiler/runtime is pending; this RFC documents the intended transit form and validation expectations.

Examples (non-normative):

1. Datetime transit (canonical):

```json
"2025-10-30T14:23:00Z"
```

2. Complex transit (canonical object form):

```json
{ "real": 1.5, "imag": -0.25 }
```

3. Binary textual transit (when the transport is textual):

```json
"SGVsbG8sIHdvcmxkIQ==" // base64("Hello, world!")
```

## Rationale

The goal is secure, clear, and portable transit semantics:

- Datetime-as-string (ISO-8601): many languages and libraries already support ISO-8601 parsing and formatting; carrying timezone information removes ambiguity about instant vs local time. Using strings in transit avoids cross-platform issues with epoch-endian differences and sub-second representations.
- Complex-as-object: not all target languages have a built-in complex scalar. Representing complex numbers as objects with `real` and `imag` ensures every language can map to a concrete representation.
- Integer wire encoding flexibility: fixed-size encodings are simple and deterministic; varints are compact for small values but introduce complexity and potential cross-language surprises. Making encoding a property of the wire/profile preserves interoperability while allowing efficiency trade-offs.

This RFC prefers minimalism at the language surface while delegating wire-specific efficiency decisions to wire/profile documents.

## Acceptance Criteria

The specification is accepted when the following are true:

- [ ] AC-1: The canonical builtin list is documented in `docs/src/syntax/builtin.md` and matches TSY-0001.
- [ ] AC-2: Datetime canonical transit form is documented and test vectors are present (ISO-8601 examples with offsets and Z).
- [ ] AC-3: Complex canonical form is documented (object with `real` and `imag`).
- [ ] AC-4: Guidance for integer wire encodings (recommended fixed-size; alternative encodings allowed per wire/profile) is present and linked to generator guidance.

## References

- [TSY-0001: Builtin Types](/tsy/tsy-0001)
- [SPEC-0001: Builtin Type Resolution](/spec/spec-0001)
