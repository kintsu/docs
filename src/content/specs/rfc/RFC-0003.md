---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 3
status: draft
title: Support Anonymous Structs
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0003: Support Anonymous Structs

## Abstract

This RFC documents the design rationale for anonymous (inline) struct types in Kintsu. Anonymous structs allow schema authors to embed small, one-off composite types inline within field declarations without forcing explicit naming. The compiler automatically extracts these inline structs, generates deterministic names, and registers them as normal named structs. This RFC explains the motivation, name-generation strategy, and the trade-offs that make anonymous structs a useful ergonomic feature while preserving compiler determinism.

## Motivation

Schema authors often need small, context-specific composite types that don't merit separate declarations. Requiring every field type to be named clutters schemas and increases maintenance burden. Anonymous structs address this by allowing inline brace-delimited struct definitions at the point of use. The compiler extracts them and generates stable names automatically so that downstream tooling (documentation generators, code generators, validation libraries) can treat them as first-class named types.

This feature is especially valuable for:

- Nested configuration shapes where the nested struct is used only once
- Operation parameters or return values with inline anonymous shapes
- OneOf variants with inline struct payloads

## Specification

This section summarizes the syntax and extraction behavior. Detailed normative rules appear in TSY-0003 and SPEC-0003.

### Syntax

An anonymous struct is written as a brace-delimited field list at a point where a type expression is expected.

**Example:**

```kintsu
struct Config {
  settings: {
    timeout: i32,
    retries: u8
  }
};
```

The parser recognizes the braced field list as `AnonymousStruct` and embeds it in the AST at the field's type position.

### Extraction and name generation

During the resolution phase, the compiler scans all type positions in the schema. When it encounters an `AnonymousStruct`, it generates a deterministic name from the lexical context (namespace path, containing type name, field name) and synthesizes a `StructDef`.

> [!IMPORTANT]
> Name generation uses PascalCase concatenation of the context stack. For example, the anonymous struct in `Config.settings` becomes `ConfigSettings`.

The generated struct is registered into the namespace like any explicitly declared struct, preserving fields, separators, and type annotations.

### Metadata and comments

> [!NOTE]
> Anonymous structs do not carry source-level metadata or comments (they are inline braces). Generated structs have empty metadata sections. Field-level comments inside the anonymous struct are preserved.

## Rationale

- Ergonomics vs explicitness: Forcing every nested shape to be a top-level named struct increases boilerplate. Anonymous structs reduce this friction without sacrificing compiler determinism. The trade-off is that tooling must display the generated name; the RFC accepts this because generated names are predictable and context-derived.

- Deterministic naming: Using lexical context (namespace + parent type + field name) ensures stable names across compilations. This is critical for documentation, client libraries, and test vectors. Alternative strategies (UUIDs, hashes) are rejected because they produce opaque identifiers that are hard to read and debug.

- Field order and metadata provenance: Generated structs preserve the exact field order and field-level comments/metadata from the source. This makes anonymous structs semantically equivalent to explicitly declared structs at registration time.

## Acceptance Criteria

Enumerate the criteria that must be met for the specification to be considered complete and accepted. These will be referenced as `<spec_id>.AC-1`.

- [ ] AC-1: The RFC explains why anonymous structs improve ergonomics for schema authors (reduce boilerplate for one-off nested shapes).
- [ ] AC-2: The RFC documents the name-generation algorithm (lexical context stack -> PascalCase) and explains why deterministic naming is required for tooling stability.
- [ ] AC-3: The RFC clarifies that anonymous structs do not carry top-level metadata/comments but that field-level metadata is preserved.
- [ ] AC-4: The RFC links to TSY-0003 and SPEC-0003 for normative extraction and registration details.

## Backwards Compatibility

This RFC documents the existing anonymous-struct extraction behavior. Future changes that alter the name-generation algorithm (for example, adding numeric suffixes for disambiguation or changing the case convention) would be breaking for tooling and documentation consumers. Such changes require explicit migration guidance and a versioned compatibility policy.

## References

- [TSY-0003: Anonymous Structs](/specs/tsy/tsy-0003)
- [SPEC-0003: Anonymous Struct Compilation](/specs/spec/spec-0003)
- [RFC-0002: Struct Type Design](./RFC-0002)
