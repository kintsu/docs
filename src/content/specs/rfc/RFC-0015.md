---
author: joshua-auchincloss
components:
  - compiler
created: 2025-10-31
kind: RFC
number: 15
status: draft
title: Type Registry Design
updates:
  - author: joshua-auchincloss
    date: 2025-10-31
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0015: Type Registry Design

## Abstract

This RFC specifies the design of the global Type Registry for cross-schema type resolution. The Type Registry maintains a centralized mapping from qualified type names to type definitions, enabling efficient type lookups across schema boundaries during compilation. The design ensures thread-safe concurrent access, supports import-based name resolution, and provides deterministic lookup semantics for multi-schema workspaces.

## Motivation

### The Cross-Schema Type Resolution Problem

In multi-schema workspaces, type references must resolve across package boundaries. Consider this scenario:

**Schema A (`shapes` package)**:

```kintsu
namespace geometry {
    struct Point {
        x: f64,
        y: f64,
    };
};
```

**Schema B (`graphics` package)**:

```kintsu
use shapes::geometry;

namespace rendering {
    struct Drawable {
        position: geometry::Point,  // Cross-schema reference
    };
};
```

The compiler must resolve `geometry::Point` in schema B to the definition in schema A. This requires:

1. **Global Namespace**: A shared registry accessible by all schemas
2. **Qualified Name Mapping**: Mapping from `shapes::geometry::Point` to the struct definition
3. **Import-Aware Resolution**: Resolving `geometry::Point` relative to imports in scope
4. **Thread Safety**: Supporting parallel compilation of independent schemas

### Alternatives Considered

**Alternative 1: Schema-Local Resolution**

Each schema maintains its own type registry and queries dependencies on-demand.

**Rejected**: Requires complex dependency traversal for each lookup. O(N × D) complexity where N = lookups, D = dependency depth. Poor cache locality.

**Alternative 2: Flat Global Map**

Single global map with unqualified names as keys.

**Rejected**: Name collisions between schemas. `shapes::Point` and `graphics::Point` would conflict. No namespace isolation.

**Alternative 3: Hierarchical Registry Tree**

Registry organized as tree mirroring package/namespace hierarchy.

**Rejected**: Complex tree traversal for lookups. Difficult to handle imports (which skip intermediate nodes). Poor parallelization due to tree lock contention.

**Alternative 4: Global Flat Map with Qualified Keys** (chosen)

Single global `HashMap` with fully qualified names (`package::namespace::Type`) as keys. Import resolution generates candidate qualified names and probes registry.

**Benefits**:

- O(1) average-case lookup after candidate generation
- Trivial duplicate detection (key collision)
- Simple thread-safe implementation (single Mutex)
- Efficient caching (all types in one structure)

### Design Goals

1. **Deterministic Resolution**: Same reference always resolves to same type
2. **Performance**: O(1) average-case lookup after candidate generation
3. **Thread Safety**: Support parallel schema compilation
4. **Duplicate Detection**: Immediate detection of conflicting type definitions
5. **Import Transparency**: Respect import statements for name resolution

## Specification

### Registry Structure

**Core Data Structure**:

```rust
pub struct TypeRegistry {
    inner: Arc<Mutex<HashMap<NamedItemContext, Spanned<ResolvedType>>>>,
}

pub struct NamedItemContext {
    package: String,
    namespace: Vec<String>,
    name: String,
}

pub struct ResolvedType {
    kind: Definition,  // Struct, Enum, OneOf, Error, TypeAlias
    qualified_path: NamedItemContext,
}
```

**Qualified Name Construction**:

```rust
// Example: shapes::geometry::Point
NamedItemContext {
    package: "shapes",
    namespace: vec!["geometry"],
    name: "Point",
}
```

### Registration API

**Primary Registration Method**:

```rust
pub fn register(
    &self,
    context: &RefContext,           // Package and namespace context
    name: &IdentToken,              // Type name
    kind: Definition,                // Type category
    span: Span,                      // Source location
    source: PathBuf,                 // Source file path
) -> Result<()>
```

**Registration Algorithm**:

1. **Construct Qualified Path**: Combine `context` (package + namespace) with `name`
2. **Check Duplicates**: If qualified path exists in registry, return `Error::DuplicateType`
3. **Insert**: Store mapping `qualified_path → ResolvedType` with source location

**Example Registration**:

```rust
// Register shapes::geometry::Point
registry.register(
    &RefContext::new("shapes".into(), vec!["geometry".into()]),
    &IdentToken::new("Point".into()),
    Definition::Struct(/* ... */),
    span,
    "shapes/src/lib.ks".into(),
)?;
```

### Resolution API

**Primary Resolution Methods**:

```rust
// Resolve type if valid, returns None if not found
pub fn resolve(
    &self,
    context: &RefContext,           // Current package/namespace
    reference: &PathOrIdent,        // Type reference to resolve
    ns: &NamespaceCtx,              // Namespace context with imports
) -> Option<Spanned<ResolvedType>>

// Resolve type or return error
pub fn resolve_required(
    &self,
    context: &RefContext,
    reference: &PathOrIdent,
    ns: &NamespaceCtx,
) -> Result<Spanned<ResolvedType>>

// Check if type reference is valid
pub fn is_valid(
    &self,
    context: &RefContext,
    reference: &PathOrIdent,
    ns: &NamespaceCtx,
) -> bool
```

### Candidate Generation Algorithm

Resolution uses **candidate generation** to handle imports. For a type reference, generate all possible qualified names and probe registry for each.

**Algorithm**:

```rust
fn generate_candidates(
    reference: &PathOrIdent,
    context: &RefContext,
    ns: &NamespaceCtx,
) -> Vec<NamedItemContext>
```

**Case 1: Simple Identifier** (`Point`)

1. **Local Context**: `context.item(Point)` → current package/namespace
2. **Imported Items**: For each import in `ns.imports`:
   - If import is `Item(shapes::geometry::Point)`, add `shapes::geometry::Point`
3. **Candidate List**: `[current_package::current_ns::Point, shapes::geometry::Point]`

**Case 2: Qualified Path** (`geometry::Point`)

1. **Parse Segments**: Split into namespace segments `[geometry]` and name `Point`
2. **Local Context**: `context.extend([geometry]).item(Point)` → extend current context
3. **Imported Namespaces**: For each import in `ns.imports`:
   - If import is `Ref(shapes)`, construct `shapes::geometry::Point`
4. **Candidate List**: `[current_pkg::geometry::Point, shapes::geometry::Point]`

**Resolution**: Probe registry for each candidate in order. Return first match.

### Thread Safety

**Concurrency Model**:

- Registry uses `Arc<Mutex<HashMap>>` for shared ownership and mutual exclusion
- All methods acquire lock, perform operation, release lock
- Supports concurrent reads and writes from parallel compilation

**Lock Acquisition Pattern**:

```rust
fn with_lock<F, R>(&self, f: F) -> Result<R>
where
    F: FnOnce(&HashMap<NamedItemContext, ResolvedType>) -> R
{
    self.inner
        .lock()
        .map(|guard| f(&guard))
        .map_err(|_| Error::InternalError { message: "Registry lock poisoned" })
}
```

**Poison Handling**: If lock is poisoned (thread panicked while holding lock), return `Error::InternalError`.

### Example Resolution Scenario

**Setup**:

```kintsu
// Schema A (shapes package)
namespace geometry {
    struct Point { x: f64, y: f64 };
};

// Schema B (graphics package)
use shapes::geometry;

namespace rendering {
    struct Drawable {
        position: geometry::Point,  // Resolve this
    };
}
```

**Resolution Steps**:

1. **Context**: `RefContext { package: "graphics", namespace: ["rendering"] }`
2. **Reference**: `PathOrIdent::Path("geometry::Point")`
3. **Imports**: `[Ref(shapes::geometry)]`
4. **Candidates**:
   - `graphics::rendering::geometry::Point` (local)
   - `shapes::geometry::Point` (imported)
5. **Registry Probe**:
   - Check `graphics::rendering::geometry::Point` → Not found
   - Check `shapes::geometry::Point` → **Found!**
6. **Result**: Return `ResolvedType { kind: Struct, qualified_path: shapes::geometry::Point }`

## Rationale

### Why Global Registry?

**Alternative**: Per-schema registries with dependency queries.

**Chosen**: Global registry simplifies resolution and improves cache locality. All lookups access same data structure. No dependency traversal required.

**Trade-off**: Single global Mutex creates potential contention point. However, lookups are O(1) hash table operations (fast), and registration only occurs during compilation (not runtime).

### Why Mutex over RwLock?

**Alternative**: Use `RwLock` for concurrent reads.

**Considered**: Most operations are reads (resolution), so `RwLock` could improve parallelism.

**Current**: `Mutex` chosen for simplicity. Hash table lookups are extremely fast (~10-50ns), so lock contention is minimal even with `Mutex`.

**Future**: If profiling shows lock contention, upgrade to `RwLock` without changing API.

### Why Qualified Keys?

**Alternative**: Hierarchical tree structure with unqualified names at leaves.

**Chosen**: Flat map with qualified keys provides:

- Instant duplicate detection (key collision)
- No tree traversal overhead
- Simple import resolution (generate qualified candidates)

### Why Candidate Generation?

**Alternative**: Directly resolve imports to qualified names during parsing.

**Chosen**: Defer resolution to Type Registry allows:

- Circular dependency handling (types can reference each other)
- Late binding (types resolved after all schemas loaded)
- Consistent resolution semantics (single algorithm)

## Acceptance Criteria

- [x] RFC-0015.AC-1: Registry maintains global mapping from qualified names to type definitions
- [x] RFC-0015.AC-2: Registration detects duplicate type definitions immediately
- [x] RFC-0015.AC-3: Resolution generates candidates from local context and imports
- [x] RFC-0015.AC-4: Resolution probes registry for each candidate in order
- [x] RFC-0015.AC-5: Registry supports concurrent access from parallel compilation
- [x] RFC-0015.AC-6: Lock poisoning handled gracefully with error return
- [x] RFC-0015.AC-7: Simple identifiers resolve to local context or imported items
- [x] RFC-0015.AC-8: Qualified paths resolve to extended local context or imported namespaces

## Backwards Compatibility

This RFC introduces no breaking changes to existing APIs. The Type Registry is an internal compiler component with no user-facing API. Schema semantics, import statements, and type resolution behavior remain unchanged.

The registry API is designed for future extensibility:

```rust
// Current API
pub fn register(&self, context: &RefContext, name: &IdentToken, /* ... */) -> Result<()>

// Future extension: support for generic types (preserves existing API)
pub fn register_generic(&self, context: &RefContext, name: &IdentToken,
                       type_params: Vec<TypeParam>, /* ... */) -> Result<()>
```

## References

- [SPEC-0015](/spec/spec-0015) — Type Registry Implementation
- [RFC-0014](/rfc/rfc-0014) — Parallel Compilation Design
- [AD-0002](/ad/ad-0002) — Parallel Compilation Architecture
- [RFC-0013](/rfc/rfc-0013) — Type Resolution Design
