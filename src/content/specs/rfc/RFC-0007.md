---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 7
status: draft
title: Union Type Support
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0007: Union Type Support

## Abstract

This RFC documents the design rationale for union types in Kintsu. Union types compose multiple struct types using the `&` operator, merging their fields into a single struct. The design supports nested unions, left-to-right precedence for field conflicts, and context-based name generation. Union types provide a composition mechanism distinct from oneOf's discrimination, enabling code reuse through field merging.

## Motivation

Type composition is a common pattern for building complex data structures from simpler components. Without union types, schema authors must manually duplicate fields across multiple struct definitions:

**Without unions:**

```kintsu
struct User {
    id: i64,
    username: str,
    email: str
};

struct UserWithPermissions {
    id: i64,         // Duplicated from User
    username: str,   // Duplicated from User
    email: str,      // Duplicated from User
    can_read: bool,
    can_write: bool,
    can_delete: bool
};
```

**With unions:**

```kintsu
struct User {
    id: i64,
    username: str,
    email: str
};

struct Permissions {
    can_read: bool,
    can_write: bool,
    can_delete: bool
};

type UserWithPermissions = User & Permissions;
```

Union types eliminate duplication and enable modular field composition.

### Why Union Types?

**Field composition:** Unions merge fields from multiple structs, creating composite types without duplication.

**Code reuse:** Common field groups (e.g., audit fields, metadata) can be defined once and composed into multiple types.

**Modular design:** Complex structs can be built from smaller, focused components.

**Conflict resolution:** Left-to-right precedence provides deterministic behavior when field names overlap.

## Specification

### Syntax

Union types use the `&` operator to compose struct types:

```kintsu
type Composed = TypeA & TypeB;
```

**In type alias:**

```kintsu
type AuthUser = User & Permissions;
```

**In struct field:**

```kintsu
struct Request {
    auth: User & Permissions
};
```

**In oneof variant:**

```kintsu
type Response = oneof (Success & Metadata) | (Error & Metadata);
```

**Nested unions (parenthesized):**

```kintsu
type Extended = Base & (Mixin1 & Mixin2);
```

### Field Merging

The compiler merges fields from all component structs left-to-right. When field names conflict, the leftmost definition wins:

```kintsu
struct Base {
    id: i64,
    version: i32,
    name: str
};

struct Extended {
    version: i32,  // Conflicts with Base.version
    description: str
};

type Merged = Base & Extended;
```

**Result:**

```kintsu
struct Merged {
    id: i64,
    version: i32,      // From Base (leftmost wins)
    name: str,
    description: str   // From Extended
}
```

> [!IMPORTANT]
> Left-to-right precedence ensures deterministic conflict resolution. The leftmost occurrence of a field name determines the final type.

### Nested Unions

Parenthesized unions are resolved recursively:

```kintsu
struct A { x: i32, y: str };
struct B { y: str, z: bool };
struct C { z: i32 };

type Combined = A & (B & C);
```

**Resolution steps:**

1. Resolve `(B & C)` → merge fields from B and C (B.y, B.z wins over C.z)
2. Merge result with A → A.x, A.y wins over B.y, B.z

**Result:**

```kintsu
struct Combined {
    x: i32,  // From A
    y: str,  // From A (wins over B)
    z: bool  // From B (wins over C)
}
```

### Name Generation

The generated struct name depends on context:

**Type alias:** Uses the alias name

```kintsu
type UserData = User & Permissions;
// Generated: struct UserData { ... }
```

**Struct field:** Uses parent struct name + field name

```kintsu
struct Request {
    auth: User & Permissions
};
// Generated: struct RequestAuth { ... }
```

**Oneof variant:** Uses parent name + variant index

```kintsu
type Response = oneof (A & B) | (C & D);
// Generated: struct Response1 { ... }, struct Response2 { ... }
```

> [!NOTE]
> Name generation follows the same context-based rules as anonymous structs, ensuring consistency across the type system.

### Struct-Only Restriction

Only struct types can be merged. Union operands referencing enums, errors, or other non-struct types are rejected:

```kintsu
// INVALID: cannot merge enum with struct
enum Status { Active, Inactive };
struct User { id: i64 };
type Invalid = User & Status;  // ERROR: union operand 'Status' is not a struct
```

## Rationale

### Why Left-to-Right Precedence?

Left-to-right precedence provides predictable conflict resolution without requiring explicit disambiguation syntax. It matches common expectations from other composition patterns (e.g., CSS rule precedence, inheritance chains).

**Alternative considered:** Requiring explicit field renaming for conflicts would be more verbose and increase schema complexity without significant benefit.

### Why Struct-Only Restriction?

Merging fields is only meaningful for struct types. Enums have discriminants (not fields), and errors have variant structures that don't compose well with field merging.

**Alternative considered:** Allowing unions with enums or errors would require complex disambiguation rules and likely confuse schema authors about the resulting type.

### Why Context-Based Naming?

Context-based naming provides predictable struct names without requiring explicit naming at every union usage site. Type aliases can override the default naming when needed.

**Alternative considered:** Generating anonymous names (e.g., `Union1`, `Union2`) would lose semantic meaning and make generated code harder to understand.

### Why Distinguish from OneOf?

Union types compose fields via merging, while oneOf types discriminate variants. These are fundamentally different operations:

- **Union (composition):** `User & Permissions` creates one struct with all fields
- **OneOf (discrimination):** `oneof User | Admin` creates a discriminated union with a tag field

Both patterns are valuable and serve different use cases.

## Acceptance Criteria

- [ ] **AC-1:** Union types support multiple struct operands composed with `&`
- [ ] **AC-2:** Field merging follows left-to-right precedence, with leftmost field winning conflicts
- [ ] **AC-3:** Nested unions are resolved recursively
- [ ] **AC-4:** Union operands must be struct types (enums and errors rejected)
- [ ] **AC-5:** Generated struct names follow context-based rules (type alias, struct field, oneof variant)

## Backwards Compatibility

Union types are a foundational feature present in Kintsu v0.1.0. No breaking changes are introduced by this specification.

Future extensions (e.g., supporting field exclusion, field renaming, or explicit conflict resolution) would require separate RFCs and careful consideration of code generation impacts.

## References

- [TSY-0007](/tsy/tsy-0007) - Union type type-system rules
- [SPEC-0007](/spec/spec-0007) - Union type compilation implementation
- [TSY-0002](/tsy/tsy-0002) - Struct types
- [RFC-0008](/rfc/rfc-0008) - OneOf type design (for comparison)
