---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-01-19
kind: RFC
number: 17
status: draft
title: Variant Tagging Design
updates:
  - author: joshua-auchincloss
    date: 2025-01-19
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0017: Variant Tagging Design

## Abstract

This RFC defines a tagging system for discriminated variants in Kintsu. Variant tagging controls how discriminated unions (oneof) and error types are serialized with type identifiers. The design supports six tagging styles: type_hint (default, runtime type annotations with adjacent data), external (wrapper object), internal (tag field inside content), adjacent (separate tag and content fields), untagged (no discriminator), and index-based (integer discriminants). The system provides namespace-level defaults with per-type and per-variant overrides, enabling schema authors to match diverse serialization requirements across target formats.

## Motivation

### The Serialization Discrimination Problem

Discriminated unions require a mechanism to identify which variant is active during serialization. Different serialization formats and protocol conventions use different discrimination strategies:

**JSON-RPC style (external tagging):**

```json
{ "Success": { "data": "..." } }
```

**Serde-style (internal tagging):**

```json
{ "kind": "Success", "data": "..." }
```

**Protocol Buffers style (adjacent tagging):**

```json
{ "kind": "Success", "content": { "data": "..." } }
```

**Kintsu default (type hints):**

```json
{ "@kintsu": "schema::api::Response::v1::success", "data": { ... } }
```

Without configurable tagging, Kintsu schemas would impose a single serialization strategy, limiting interoperability with existing systems.

### Design Goals

1. **Format-agnostic specification**: Define tagging semantics independent of wire formats
2. **Namespace-level defaults**: Reduce repetition for consistent tagging within a namespace
3. **Per-type overrides**: Allow specific types to use different strategies
4. **Per-variant customization**: Support variant renaming and individual tagging
5. **Builtin exclusion**: Primitive types remain completely untagged
6. **Version-aware type hints**: Support runtime type identification with full paths

### Scope

This RFC applies to **variant types only**:

- **oneof types**: Discriminated unions (anonymous and named)
- **error types**: Struct, tuple, and unit variants
- **union_or fields**: Oneofs generated from `&|` field conflicts

**Excluded** (always untagged):

- **enum types**: Value enumerations without data payloads
- **builtin types**: Primitives (i32, str, bool, etc.)
- **struct types**: Single-shape types without discrimination

## Specification

### Tagging Styles

Kintsu supports six tagging styles for variant types:

#### External Tagging

The variant name wraps the content in an outer object.

**Syntax:** `#[tag(external)]`

**Schema:**

```kintsu
namespace api {
    struct Success {
        message: str,
        request_id: str
    };

    struct Error {
        code: i32,
        reason: str
    };

    #[tag(external)]
    type Response = oneof Success | Error;
};
```

**Serialized outputs:**

```json
// Success variant
{ "success": { "message": "OK", "request_id": "req-123" } }

// Error variant
{ "error": { "code": 404, "reason": "Not found" } }
```

> [!NOTE]
> External tagging provides Serde compatibility. Use `#[tag(external)]` to opt out of the default type_hint tagging.

#### Internal Tagging

A tag field is inserted into the content object alongside other fields.

**Syntax:** `#[tag(name = "field_name")]`

**Schema:**

```kintsu
namespace api {
    struct Success {
        message: str,
        request_id: str
    };

    struct Error {
        code: i32,
        reason: str
    };

    #[tag(name = "kind")]
    type Response = oneof Success | Error;
};
```

**Serialized outputs:**

```json
// Success variant - tag field "kind" inserted alongside struct fields
{ "kind": "success", "message": "OK", "request_id": "req-123" }

// Error variant
{ "kind": "error", "code": 404, "reason": "Not found" }
```

**Default tag field:** `kind`

#### Adjacent Tagging

Separate fields for the tag and content.

**Syntax:** `#[tag(name = "tag_field", content = "content_field")]`

**Schema:**

```kintsu
namespace api {
    struct Success {
        message: str,
        request_id: str
    };

    struct Error {
        code: i32,
        reason: str
    };

    #[tag(name = "type", content = "payload")]
    type Response = oneof Success | Error;
};
```

**Serialized outputs:**

```json
// Success variant - tag and content in separate fields
{ "type": "success", "payload": { "message": "OK", "request_id": "req-123" } }

// Error variant
{ "type": "error", "payload": { "code": 404, "reason": "Not found" } }
```

**Default content field:** `data`

#### Untagged

No discriminator field. Variants are distinguished by structure.

**Syntax:** `#[tag(untagged)]`

**Schema (primitives):**

```kintsu
namespace config {
    #[tag(untagged)]
    type Value = oneof i32 | str | bool;
};
```

**Serialized outputs:**

```json
42        // i32 variant - bare integer
"hello"   // str variant - bare string
true      // bool variant - bare boolean
```

**Schema (distinguishable structs):**

```kintsu
namespace api {
    struct User {
        user_id: i64,
        username: str
    };

    struct Organization {
        org_id: i64,
        name: str,
        members: i32
    };

    #[tag(untagged)]
    type Entity = oneof User | Organization;
};
```

**Serialized outputs:**

```json
// User variant - distinguished by field set
{ "user_id": 42, "username": "alice" }

// Organization variant - has "members" field that User lacks
{ "org_id": 100, "name": "Acme Corp", "members": 50 }
```

> [!WARNING]
> Untagged variants require structurally distinguishable types. Overlapping shapes cause ambiguous deserialization.

#### Index-Based Tagging

Uses integer discriminants instead of string names.

**Syntax:** `#[tag(index)]` or `#[tag(index, name = "field_name")]`

**Schema:**

```kintsu
namespace jobs {
    struct Active {
        started_at: datetime,
        worker_id: str
    };

    struct Pending {
        queued_at: datetime,
        priority: i32
    };

    struct Complete {
        finished_at: datetime,
        result: str
    };

    #[tag(index, name = "t")]
    type JobStatus = oneof Active | Pending | Complete;
};
```

**Serialized:**

```json
// Active variant (index 0)
{ "t": 0, "started_at": "2025-01-19T10:00:00Z", "worker_id": "w-123" }

// Pending variant (index 1)
{ "t": 1, "queued_at": "2025-01-19T09:55:00Z", "priority": 10 }

// Complete variant (index 2)
{ "t": 2, "finished_at": "2025-01-19T10:05:00Z", "result": "success" }
```

**Default index field:** `kind`

> [!IMPORTANT]
> Variant indices are determined by declaration order. Reordering variants is a breaking change.

#### Type Hint Tagging (Default)

Adds a `@kintsu` field with the fully-qualified type path including variant for runtime type identification. Variant fields are placed adjacent to the type hint (not nested). This is the default tagging style.

Type hint tagging is conceptually **untagged serialization plus the `@kintsu` discriminator**. The variant's payload fields appear at the top level of the object, with only the `@kintsu` field added to identify the type and variant. This design minimizes impact on existing data structures while providing runtime type information.

**Syntax:** Default (no attribute needed), or explicitly `#[tag(type_hint)]`

**Schema:**

```kintsu
namespace api {
    #![version(1)]

    struct Success {
        message: str,
        request_id: str
    };

    struct Error {
        code: i32,
        reason: str
    };

    // No #[tag(...)] needed - type_hint is the default
    type Response = oneof Success | Error;
};
```

**Serialized outputs:**

```json
// Success variant - @kintsu at top level, fields adjacent
{
  "@kintsu": "api::api::Response::v1::success",
  "message": "OK",
  "request_id": "req-123"
}

// Error variant
{
  "@kintsu": "api::api::Response::v1::error",
  "code": 404,
  "reason": "Not found"
}
```

**Type path format:** `schema::namespace::Type::v{version}::variant`

**Combining with other styles:**

Type hints can optionally be combined with internal tagging for additional discrimination:

```kintsu
namespace api {
    #![version(1)]

    struct Success {
        message: str
    };

    struct Error {
        code: i32
    };

    #[tag(name = "kind", type_hint)]
    type Response = oneof Success | Error;
};
```

```json
// With both type_hint and internal tagging
{
  "@kintsu": "api::api::Response::v1::success",
  "kind": "success",
  "message": "OK"
}
```

**Disabling type hints:**

To disable type hints, use `#[tag(type_hint = false)]`. This falls back to **untagged** serialization—variant fields are serialized directly without any discriminator. This is appropriate when the consumer can distinguish variants by structure alone, or when integrating with systems that cannot handle the `@kintsu` field.

```kintsu
namespace api {
    #![tag(type_hint = false)]  // Entire namespace uses untagged

    struct User { user_id: i64, name: str };
    struct Org { org_id: i64, name: str, members: i32 };

    type Entity = oneof User | Org;  // Untagged - distinguished by structure
};
```

```json
// User variant - no @kintsu field, just the payload
{ "user_id": 42, "name": "alice" }

// Org variant - distinguished by having "members" field
{ "org_id": 100, "name": "Acme", "members": 50 }
```

Alternatively, specify any other tagging style explicitly to override the default:

```kintsu
namespace api {
    #![tag(external)]  // Use external tagging instead of type_hint

    // Or per-type:
    #[tag(external)]
    type Response = oneof Success | Error;
};
```

> [!WARNING]
> With `type_hint = false`, variants must be structurally distinguishable. If variants have identical field signatures, deserialization becomes ambiguous.

### Type Hint Versioning Guarantees

Type hints include version information to enable runtime type identification. The version attached to a type hint represents the **highest-level versioned container** that guarantees all nested types.

**Versioning contract by object type:**

| Object Type                     | Version Source                                                 | Guarantee Scope                     |
| ------------------------------- | -------------------------------------------------------------- | ----------------------------------- |
| **oneof**                       | The oneof's own `#[version(n)]` or inherited namespace version | All variants and their nested types |
| **error**                       | The error's own `#[version(n)]` or inherited namespace version | All variants and their payloads     |
| **struct** (as variant payload) | Parent oneof/error version                                     | All fields within the struct        |
| **builtin**                     | No version                                                     | Primitives are unversioned          |

**Why nested types omit hints:**

Once the top-level type is identified via its type hint, the specification guarantees the exact shape of all nested content. Including redundant hints on nested objects would:

1. Increase serialization overhead without adding information
2. Create potential for version inconsistencies between parent and child
3. Complicate deserialization logic with redundant validation

**Example: Version propagation**

```kintsu
namespace api {
    #![version(2)]

    struct Metadata {
        trace_id: str,
        timestamp: datetime
    };

    struct Success {
        message: str,
        meta: Metadata
    };

    struct Error {
        code: i32,
        reason: str,
        meta: Metadata
    };

    // Default type_hint tagging
    type Response = oneof Success | Error;
};
```

**Serialized (Success variant with nested Metadata):**

```json
{
  "@kintsu": "api::api::Response::v2::success",
  "message": "OK",
  "meta": {
    "trace_id": "abc-123",
    "timestamp": "2025-01-19T10:00:00Z"
  }
}
```

The version `v2` in the type hint guarantees:

- The `Response` oneof has exactly variants `Success` and `Error`
- `Success` has fields `message: str` and `meta: Metadata`
- `Metadata` has fields `trace_id: str` and `timestamp: datetime`
- No type hints on nested `meta` object—parent version guarantees its shape

> [!NOTE]
> Type hints appear only at the top-level of serialized objects. The parent type's version guarantees all nested structure per the specification.

### Attribute Syntax

Tagging uses the metadata attribute system defined in RFC-0012.

**Namespace-level default (inner attribute):**

```kintsu
namespace api {
    #![tag(name = "kind")]  // All variant types use internal tagging

    struct Success { message: str };
    struct Error { code: i32, reason: str };
    struct Ok { value: i64 };
    struct Err { message: str };

    type Response = oneof Success | Error;  // Uses internal tagging
    type Result = oneof Ok | Err;           // Uses internal tagging
};
```

**Serialized outputs (both types inherit namespace default):**

```json
// Response - Success variant
{ "kind": "success", "message": "OK" }

// Result - Ok variant
{ "kind": "ok", "value": 42 }
```

**Type-level override (outer attribute):**

```kintsu
namespace api {
    #![tag(name = "kind")]  // Namespace default: internal

    struct Success { message: str };
    struct Error { code: i32 };

    type Response = oneof Success | Error;  // Uses internal (inherited)

    #[tag(untagged)]  // Override namespace default
    type Primitive = oneof i32 | str | bool;
};
```

**Serialized outputs:**

```json
// Response - uses inherited internal tagging
{ "kind": "success", "message": "OK" }

// Primitive - uses type-level override (untagged)
42
"hello"
true
```

**Variant-level rename:**

```kintsu
namespace workflow {
    struct Active { started_at: datetime };
    struct Pending { queued_at: datetime };
    struct Complete { finished_at: datetime };

    #[tag(name = "status")]
    type JobStatus = oneof
        Active |
        #[rename("in_progress")]  // Override snake_case default
        Pending |
        Complete;
};
```

**Serialized outputs:**

```json
// Active variant - default snake_case
{ "status": "active", "started_at": "2025-01-19T10:00:00Z" }

// Pending variant - renamed to "in_progress"
{ "status": "in_progress", "queued_at": "2025-01-19T09:55:00Z" }

// Complete variant - default snake_case
{ "status": "complete", "finished_at": "2025-01-19T10:05:00Z" }
```

### Variant Naming

All variant names are normalized to snake_case in serialized output. The `#[rename("...")]` attribute on individual variants overrides the default normalization.

### Unit Variant Serialization

Unit variants (variants with no payload) serialize with the tag only.

**Schema:**

```kintsu
namespace api {
    #[tag(name = "kind")]
    error ApiError {
        Unknown,                      // Unit variant - no payload
        Timeout { duration_ms: i64 }, // Struct variant
        NotFound { resource: str }    // Struct variant
    };
};
```

**Serialized outputs (internal tagging):**

```json
// Unknown - unit variant, no payload fields
{ "kind": "unknown" }

// Timeout - struct variant with fields
{ "kind": "timeout", "duration_ms": 5000 }

// NotFound - struct variant with fields
{ "kind": "not_found", "resource": "users/123" }
```

**Same schema with adjacent tagging:**

```kintsu
namespace api {
    #[tag(name = "type", content = "data")]
    error ApiError {
        Unknown,
        Timeout { duration_ms: i64 },
        NotFound { resource: str }
    };
};
```

**Serialized outputs (adjacent tagging):**

```json
// Unknown - unit variant, content is null
{ "type": "unknown", "data": null }

// Timeout - struct variant wrapped in content field
{ "type": "timeout", "data": { "duration_ms": 5000 } }

// NotFound
{ "type": "not_found", "data": { "resource": "users/123" } }
```

### Nested OneOf Resolution

For nested oneof expressions without explicit names, variant names follow the parent naming algorithm defined in TSY-0008.

**Schema:**

```kintsu
namespace api {
    struct Success { message: str };
    struct PartialError { warnings: str[], completed: i32 };
    struct FatalError { reason: str, stack: str };

    #[tag(name = "kind")]
    type Response = oneof
        Success |
        (oneof PartialError | FatalError);  // Nested oneof
};
```

The nested oneof is extracted and named `Response1` (first anonymous type in Response).

**Serialized outputs:**

```json
// Success variant (index 0)
{ "kind": "success", "message": "All good" }

// PartialError variant (nested oneof, index 1 of outer, index 0 of inner)
{ "kind": "response1", "warnings": ["Slow query"], "completed": 95 }

// FatalError variant (nested oneof, index 1 of outer, index 1 of inner)
// Note: inner variants flatten to outer tagging
{ "kind": "response1", "reason": "Out of memory", "stack": "..." }
```

> [!NOTE]
> Nested oneofs are extracted and named automatically. For clearer APIs, consider using explicit named types instead of inline nested oneofs.

## Rationale

### Six Tagging Styles

Each style addresses specific use cases:

| Style     | Use Case                                        |
| --------- | ----------------------------------------------- |
| Type hint | Default; runtime reflection, versioned dispatch |
| External  | Rust/Serde compatibility, simple wrapping       |
| Internal  | JSON-RPC, discriminated unions in TypeScript    |
| Adjacent  | Protocol Buffers, MessagePack                   |
| Untagged  | Primitives, structurally distinct types         |
| Index     | Binary protocols, compact serialization         |

### Default to Type Hint

Type hint tagging is the default because it provides full runtime type identification with minimal impact on existing data structures. Conceptually, type_hint is **untagged serialization plus the `@kintsu` discriminator**—the variant's fields appear directly at the top level, with only the `@kintsu` field added. This makes it easy to adopt Kintsu without restructuring existing types.

The `@kintsu` field provides a versioned contract: consumers can rely on the exact type and variant, with all nested structure guaranteed by the version number. Schema authors can disable this guarantee with `#[tag(type_hint = false)]` to fall back to pure untagged serialization, or use other explicit styles for Serde/protobuf compatibility.

### Registry Type Hint Compliance

Schema registries SHOULD mark specifications as **type_hint compliant** when all variant types in the schema use type_hint tagging (the default). This marker indicates that:

1. All serialized variant objects include the `@kintsu` field
2. Consumers can rely on runtime type identification
3. The schema supports dynamic dispatch based on type paths

Schemas that disable type_hint (via `#[tag(type_hint = false)]` or other tagging styles) are not type_hint compliant and cannot guarantee runtime type identification.

### Snake_case Normalization

Consistent naming across languages and wire formats.

### No Skip/Alias/Flatten

The design intentionally excludes:

- **skip**: Omitting variants breaks type safety
- **alias**: Multiple names for one variant complicates versioning
- **flatten**: Merging fields loses structural clarity

Kintsu's strict versioning policy (RFC-0012) ensures schema evolution through explicit versions, not through serialization workarounds.

### Type Hints at Top-Level Only

Nested type hints would be redundant. If the parent type is known, the child types are determined by the specification. This reduces serialization overhead and simplifies parsers.

### Builtins Completely Untagged

Primitive types (i32, str, bool, etc.) have no internal structure to tag. They serialize directly to their wire representation.

## Code Generation Examples

This section illustrates how code generators should emit type definitions for each tagging style.

### Type Hint (Default) — Rust

For type_hint tagging, the generated code uses Serde's `tag` attribute with adjacently-placed variant data. The `@kintsu` field acts as the discriminator, with each variant renamed to its fully-qualified type path.

**Kintsu schema:**

```kintsu
namespace api::types {
    #![version(1)]

    struct Foo {
        value: i32
    };

    struct Bar {
        message: str
    };

    type Response = oneof Foo | Bar;
};
```

**Generated Rust:**

```rust
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(tag = "@kintsu")]
pub enum Response {
    #[serde(rename = "api::types::Response::v1::foo")]
    Foo(Foo),
    #[serde(rename = "api::types::Response::v1::bar")]
    Bar(Bar),
}

#[derive(serde::Serialize, serde::Deserialize)]
pub struct Foo {
    pub value: i32,
}

#[derive(serde::Serialize, serde::Deserialize)]
pub struct Bar {
    pub message: String,
}
```

**Serialized output:**

```json
{
  "@kintsu": "api::types::Response::v1::foo",
  "value": 42
}
```

### External Tagging — Rust

External tagging wraps the variant content in an object keyed by the variant name.

**Kintsu schema:**

```kintsu
namespace api {
    #[tag(external)]
    type Response = oneof Foo | Bar;
};
```

**Generated Rust:**

```rust
#[derive(serde::Serialize, serde::Deserialize)]
pub enum Response {
    #[serde(rename = "foo")]
    Foo(Foo),
    #[serde(rename = "bar")]
    Bar(Bar),
}
```

**Serialized output:**

```json
{ "foo": { "value": 42 } }
```

### Internal Tagging — Rust

Internal tagging places the discriminator field inside the content object.

**Kintsu schema:**

```kintsu
namespace api {
    #[tag(name = "kind")]
    type Response = oneof Foo | Bar;
};
```

**Generated Rust:**

```rust
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(tag = "kind")]
pub enum Response {
    #[serde(rename = "foo")]
    Foo(Foo),
    #[serde(rename = "bar")]
    Bar(Bar),
}
```

**Serialized output:**

```json
{ "kind": "foo", "value": 42 }
```

### Adjacent Tagging — Rust

Adjacent tagging separates the tag and content into distinct fields.

**Kintsu schema:**

```kintsu
namespace api {
    #[tag(name = "type", content = "data")]
    type Response = oneof Foo | Bar;
};
```

**Generated Rust:**

```rust
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(tag = "type", content = "data")]
pub enum Response {
    #[serde(rename = "foo")]
    Foo(Foo),
    #[serde(rename = "bar")]
    Bar(Bar),
}
```

**Serialized output:**

```json
{ "type": "foo", "data": { "value": 42 } }
```

### Untagged — Rust

Untagged variants rely on structural discrimination during deserialization.

**Kintsu schema:**

```kintsu
namespace api {
    #[tag(untagged)]
    type Value = oneof i32 | str | bool;
};
```

**Generated Rust:**

```rust
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
pub enum Value {
    Int(i32),
    Str(String),
    Bool(bool),
}
```

**Serialized output:**

```json
42
"hello"
true
```

## Backwards Compatibility

This is a new feature. No backwards compatibility concerns.

## References

- [RFC-0008](/specs/rfc/RFC-0008) - OneOf Type Design
- [RFC-0005](/specs/rfc/RFC-0005) - Error Type Design
- [RFC-0012](/specs/rfc/RFC-0012) - Metadata System
- [RFC-0016](/specs/rfc/RFC-0016) - Union Or (`&|`)
- [TSY-0013](/specs/tsy/TSY-0013) - Variant Tagging Rules
- [SPEC-0016](/specs/spec/SPEC-0016) - Variant Tagging Compilation
