---
author: joshua-auchincloss
components:
  - compiler
  - registry
created: 2025-12-27
kind: RFC
number: 31
status: draft
title: Versioning Guarantees
updates:
  - author: joshua-auchincloss
    date: 2025-12-27
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0031: Versioning Guarantees

## Abstract

This RFC specifies versioning guarantees for Kintsu schemas: strict semver enforcement rules that ensure wire compatibility between versions. Once a schema opts in by publishing version `1.0.0`, these guarantees are enforced for the lifetime of the schema. The RFC also defines the pre-release wall—a strict boundary preventing dependencies between pre-release (`0.x.y`) and released (`≥1.0.0`) schemas.

## Motivation

### The Wire Compatibility Problem

Data schemas are consumed by services that serialize and deserialize data. When schemas change, consumers may encounter:

- **Null deserialization errors** - A required field was removed; consumer receives null
- **Integer overflow** - Field widened from `i32` to `i64`; 32-bit platform truncates
- **Parse failures** - Enum variant removed; wire data contains old value
- **Type mismatches** - Field changed from `i32` to `str`; deserialization fails

Unlike library APIs where breaking changes cause compile errors, schema breaking changes cause **runtime failures**—often in production.

### The Stability Contract

Service providers need to declare compatibility:

> "http-api-foo v1.2.1 is compatible with http-api-foo-schema v23.0.0"

This requires:

1. Schema versions to have **predictable guarantees**
2. Breaking changes to be **blocked at publish time**
3. Cross-package impacts to be **visible and tracked**

### Design Goals

1. **Opt-in, lifetime commitment** - Once subscribed, guarantees are enforced forever
2. **Wire compatibility first** - Any change that could cause deserialization failures is major
3. **No escape hatches** - The rules are the rules; no override mechanisms
4. **Pre-release isolation** - Experimental schemas don't contaminate stable ecosystem

## Specification

### Pre-Release vs Released Schemas

#### The Pre-Release Wall

Schemas exist in one of two states:

**Pre-Release (0.x.y):**

- No versioning enforcement
- Can depend on other pre-release schemas only
- Cannot be consumed by released schemas
- Experimental/development phase

**Released (1.0.0 and above):**

- Strict versioning enforcement
- Can depend on released schemas only
- Versioning guarantees enforced for lifetime
- Service boundary compatibility tracking

Publishing version `1.0.0` is a one-way gate from pre-release to released status.

#### Dependency Rules

| Consumer Version      | Can Depend On            |
| --------------------- | ------------------------ |
| Pre-release (`0.x.y`) | Pre-release schemas only |
| Released (`≥1.0.0`)   | Released schemas only    |

**Error conditions:**

- Released schema depending on pre-release: blocked at publish
- Pre-release schema depending on released: blocked at publish

This creates a hard wall between experimental and stable ecosystems.

### Version Change Rules

#### Patch Versions (`x.y.Z`)

Patches permit **documentation changes only**.

**Allowed:**

- Comment and description changes
- Metadata text updates
- Intermediate type alias insertion (if underlying type unchanged)

**Not allowed:**

- Any structural changes
- Any type changes
- Any field additions or removals
- Any new types

```kintsu title="v1.0.0 -> v1.0.1: ALLOWED" ins={1-2,5-6}
/// A user in the system
struct User {
    /// Unique identifier
    id: i64,
    /// Display name
    name: str
};
```

```kintsu title="v1.0.0 -> v1.0.1: ALLOWED (intermediate alias)"
// Before: id: i64
// After: id: UserId (where UserId = i64)
type UserId = i64;

struct User {
    id: UserId  // Still resolves to i64
};
```

#### Minor Versions (`x.Y.0`)

Minors permit **additive, non-breaking changes**.

**Allowed:**

- Everything in patch
- Add optional fields to structs
- Add new types (structs, enums, oneofs, errors)
- Add new type aliases (if chain resolves to valid roots)
- Add new operations
- Add new namespaces

**Not allowed:**

- Remove anything
- Rename anything
- Change any existing type
- Add required fields
- Add enum variants (exhaustive match breaking)
- Add oneof variants (exhaustive match breaking)
- Change discriminant tags

```kintsu title="v1.0.0 -> v1.1.0: ALLOWED" ins={4}
struct User {
    id: i64,
    name: str,
    email?: str  // New optional field
};
```

```kintsu title="v1.0.0 -> v1.1.0: ALLOWED (new type)"
// Existing types unchanged
struct User { id: i64, name: str };

// New type added
struct UserProfile {
    bio: str,
    avatar?: str
};
```

```kintsu title="v1.0.0 -> v1.1.0: NOT ALLOWED" del={4}
struct User {
    id: i64,
    name: str,
    created_at: datetime  // ERROR: Required field
};
```

#### Major Versions (`X.0.0`)

Majors permit **all changes**.

**Allowed:**

- Everything
- Remove types, fields, variants
- Rename types, fields, variants
- Change field types (widening, narrowing, incompatible)
- Add required fields
- Add or remove enum/oneof variants
- Change discriminant tags
- Change type alias targets

### Breaking Change Classification

#### Struct Changes

| Change                    | Patch | Minor | Major | Rationale               |
| ------------------------- | :---: | :---: | :---: | ----------------------- |
| Add documentation         |  Yes  |  Yes  |  Yes  | No wire impact          |
| Add optional field        |  No   |  Yes  |  Yes  | Read-compatible         |
| Add required field        |  No   |  No   |  Yes  | Write-breaking          |
| Remove field              |  No   |  No   |  Yes  | Read-breaking           |
| Rename field              |  No   |  No   |  Yes  | Wire format + codegen   |
| Change field type (any)   |  No   |  No   |  Yes  | Integer overflow risk   |
| Make required to optional |  No   |  No   |  Yes  | Semantic change         |
| Make optional to required |  No   |  No   |  Yes  | Write-breaking          |
| Insert intermediate alias |  [1]  |  Yes  |  Yes  | If underlying unchanged |

¹ Only if type chain resolves to identical underlying type

#### Enum Changes

| Change                    | Patch | Minor | Major | Rationale                    |
| ------------------------- | :---: | :---: | :---: | ---------------------------- |
| Add documentation         |  Yes  |  Yes  |  Yes  | No wire impact               |
| Add variant               |  No   |  No   |  Yes  | Exhaustive match breaking    |
| Remove variant            |  No   |  No   |  Yes  | Wire data may have old value |
| Rename variant            |  No   |  No   |  Yes  | Codegen breaking             |
| Change variant value      |  No   |  No   |  Yes  | Wire format change           |
| Reorder (implicit values) |  No   |  No   |  Yes  | Value semantics change       |

#### OneOf Changes

| Change                  | Patch | Minor | Major | Rationale                    |
| ----------------------- | :---: | :---: | :---: | ---------------------------- |
| Add documentation       |  Yes  |  Yes  |  Yes  | No wire impact               |
| Add variant             |  No   |  No   |  Yes  | Exhaustive match breaking    |
| Remove variant          |  No   |  No   |  Yes  | Wire data may have old value |
| Change discriminant tag |  No   |  No   |  Yes  | Wire format change           |

#### Type Alias Changes

| Change                               | Patch | Minor | Major | Rationale        |
| ------------------------------------ | :---: | :---: | :---: | ---------------- |
| Add new alias                        |  No   |  Yes  |  Yes  | Additive         |
| Remove alias                         |  No   |  No   |  Yes  | Codegen breaking |
| Rename alias                         |  No   |  No   |  Yes  | Codegen breaking |
| Change target (same underlying)      |  Yes  |  Yes  |  Yes  | Wire-compatible  |
| Change target (different underlying) |  No   |  No   |  Yes  | Type change      |

#### Type/Operation Addition/Removal

| Change            | Patch | Minor | Major | Rationale              |
| ----------------- | :---: | :---: | :---: | ---------------------- |
| Add new type      |  No   |  Yes  |  Yes  | Additive               |
| Add new operation |  No   |  Yes  |  Yes  | Additive               |
| Add new namespace |  No   |  Yes  |  Yes  | Additive               |
| Remove type       |  No   |  No   |  Yes  | Breaking if referenced |
| Remove operation  |  No   |  No   |  Yes  | Breaking               |
| Remove namespace  |  No   |  No   |  Yes  | Breaking               |

### Enforcement Mechanism

#### Compiler Check

The compiler validates version changes locally before publish. It fetches the latest published version from the registry (if any) and compares the current compilation against it. Violations are reported with specific error codes from the KCP domain (see [ERR-0017](/specs/err/err-0017)).

#### Registry Gate

The registry performs the same validation on publish. Publishing is blocked until all violations are resolved. This provides defense in depth—even if a developer bypasses local checks, the registry enforces compliance.

### Cross-Package Impact Analysis

When a package publishes a new version with breaking changes, the registry computes the impact using the reference graph from [RFC-0030](/specs/rfc/rfc-0030).

For example, when `abc-a` publishes version `2.0.0` with a breaking change (`types::Foo::a` changed from `i32` to `i64`), the registry identifies all impacted packages:

- Packages that depend on the changed type
- Packages with field projections referencing the changed field
- Transitive dependents that may be affected

Maintainers of impacted packages are notified of the breaking change.

### Service Boundary Compatibility

Versioning guarantees enable explicit compatibility declarations:

```toml title="service-manifest.toml"
[service]
name = "http-api-foo"
version = "1.2.1"

[schema-compatibility]
http-api-foo-schema = "23.0.0"
core-api-foo-schema = "46.0.0"
```

This declares: _"http-api-foo v1.2.1 is wire-compatible with these exact schema versions."_

## Rationale

### Why No Type Widening in Minor

Type widening (`i32` -> `i64`) seems safe but isn't:

```c title="32-bit platform deserialization"
// Schema says i64, platform is 32-bit
int64_t value = deserialize_i64(wire_data);
// If value > INT32_MAX, truncation or overflow
int32_t truncated = (int32_t)value;  // Data corruption
```

Even "safe" widening can cause integer overflow on constrained platforms. All type changes are major.

### Why Enum Variants Are Major

Adding an enum variant breaks exhaustive matching:

```rust title="Consumer code before variant added"
match status {
    Status::Active => handle_active(),
    Status::Inactive => handle_inactive(),
    // No Pending case - compile succeeds
}

// After variant added, this code receives Status::Pending
// and has undefined behaviour or crashes
```

Languages with exhaustive match semantics (Rust, Swift, Kotlin) fail at runtime when encountering unknown variants.

### Why No Override Mechanism

Override mechanisms create:

1. **False security** - "It's fine, I added the override" becomes routine
2. **Ecosystem fragmentation** - Some packages enforce, some don't
3. **Audit complexity** - "Why was this override added?"

Strict rules with no exceptions create predictable, trustworthy guarantees.

### Why Pre-Release Wall

Mixing pre-release and released schemas creates:

1. **Hidden instability** - Released package depends on experimental code
2. **Upgrade pressure** - Pre-release changes force released package updates
3. **Trust erosion** - "Released" loses meaning

The wall ensures released schemas form a stable, self-contained ecosystem.

## Acceptance Criteria

- [ ] AC-1: Pre-release schemas cannot depend on released schemas
- [ ] AC-2: Released schemas cannot depend on pre-release schemas
- [ ] AC-3: Patch versions allow only documentation changes and same-underlying alias insertion
- [ ] AC-4: Minor versions allow additive changes (optional fields, new types)
- [ ] AC-5: Minor versions block required fields, removals, renames, type changes, variant additions
- [ ] AC-6: Major versions allow all changes
- [ ] AC-7: Registry blocks non-compliant publishes
- [ ] AC-8: Impact analysis notifies maintainers of affected packages

> [!NOTE]
> CLI commands for semver validation are specified in a separate CLI RFC.

## Future Considerations

> **Note**: A deprecation mechanism could provide a migration path for gradual changes. This would allow marking types/fields as deprecated with guidance, while maintaining wire compatibility until the next major version. To be considered in a future RFC.

## References

- [RFC-0019](/specs/rfc/rfc-0019) - Package Manifest Format
- [RFC-0030](/specs/rfc/rfc-0030) - Type Introspection
- [ERR-0017](/specs/err/err-0017) - Compatibility Errors
