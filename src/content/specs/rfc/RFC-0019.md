---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-12-25
kind: RFC
number: 19
status: draft
title: Package Manifest Format
updates:
  - author: joshua-auchincloss
    date: 2025-12-25
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0019: Package Manifest Format

## Abstract

This RFC specifies the format and semantics of the Kintsu package manifest file (`schema.toml`). The manifest defines package identity, dependencies, and configuration for schema compilation and distribution.

## Motivation

Schema packages require a standardized way to declare:

1. **Identity** - Package name, version, description, and authorship
2. **Dependencies** - References to other schema packages (local, git, or registry)
3. **Configuration** - File inclusion/exclusion patterns and build settings
4. **Distribution** - Registry publication settings

A well-defined manifest format enables:

- Reproducible builds across environments
- Dependency resolution and version management
- Package discovery and registry integration
- Project structure conventions

## Specification

### File Location and Name

The package manifest MUST be named `schema.toml` and placed at the package root directory alongside the `schema/` source directory.

```
my-package/
  schema.toml           # Package manifest (this spec)
  schema/
    lib.ks              # Entry point
    ...
```

### Version Envelope

The manifest uses a versioned envelope pattern for forward compatibility:

```toml
version = "v1"

[package]
name = "my-package"
version = "1.0.0"
# ...
```

The `version` field at the root level specifies the manifest schema version. Currently only `v1` is defined.

### Package Metadata

The `[package]` table contains required and optional metadata:

```toml
[package]
# Required fields
name = "my-package"
version = "1.0.0"

# Optional fields
description = "A schema package for my types"
authors = [{ name = "Author Name", email = "author@example.com" }]
repository = "https://github.com/org/my-package"
homepage = "https://example.com/docs"
keywords = ["api", "types"]
license = "MIT"
license_text = "MIT License"  # Full license text or SPDX identifier
readme = "# My Package\n\nDocumentation here"  # Inline content or file path
```

#### Authors

Authors are specified as an array of objects with `name` and `email` fields:

```toml
authors = [
    { name = "Alice", email = "alice@example.com" },
    { name = "Bob", email = "bob@example.com" }
]
```

#### Package Name

Package names MUST:

- Match the regex pattern `[a-z]([a-z0-9\-]*)[a-z0-9]`
- Be at least 2 characters long
- Use kebab-case (lowercase with hyphens)
- Be unique within a registry

Package names are automatically converted to snake_case for namespace declarations:

```
my-package     ->  my_package (namespace)
abc-corp       ->  abc_corp (namespace)
types-v2       ->  types_v2 (namespace)
```

#### Package Version

Versions MUST follow [Semantic Versioning 2.0.0](https://semver.org/):

```toml
version = "1.2.3"
version = "0.1.0-alpha.1"
version = "2.0.0-rc.1+build.456"
```

### Dependencies

Dependencies are declared in the `[dependencies]` table. Four dependency types are supported:

#### Path Dependencies

Reference local packages by filesystem path:

```toml
[dependencies]
local-types = { path = "../local-types" }
shared = { path = "/absolute/path/to/shared" }
```

Path dependencies are resolved relative to the manifest file location.

#### Git Dependencies

Reference packages from git repositories:

```toml
[dependencies]
# Default branch
git-pkg = { git = "https://github.com/org/repo" }

# Specific branch
feature-pkg = { git = "https://github.com/org/repo", branch = "feature-x" }

# Specific tag
tagged-pkg = { git = "https://github.com/org/repo", tag = "v1.0.0" }

# Specific commit
pinned-pkg = { git = "https://github.com/org/repo", rev = "abc123def" }
```

Only one of `branch`, `tag`, or `rev` may be specified.

#### Registry Dependencies

Reference packages from a schema registry:

```toml
[dependencies]
# From default registry with version requirement
types = "^1.0"
errors = { version = ">=2.0, <3.0" }

# From named registry
corp-types = { version = "1.x", registry = "corp-registry" }
```

Version requirements follow the [semver crate](https://docs.rs/semver) syntax:

| Syntax        | Meaning                         |
| ------------- | ------------------------------- |
| `^1.2.3`      | Compatible with 1.2.3 (default) |
| `~1.2.3`      | Approximately 1.2.3             |
| `1.2.3`       | Exactly 1.2.3                   |
| `>=1.0, <2.0` | Range                           |
| `1.x`         | Any 1.x version                 |
| `*`           | Any version                     |

#### Path with Remote Fallback

Combine path and registry for development/production flexibility:

```toml
[dependencies]
# Use local path in development, registry in CI/production
shared-types = { path = "../shared-types", version = "^1.0" }
```

When both `path` and `version` are specified:

- Local development uses the path dependency
- Registry resolution uses the version constraint
- Lockfile records both sources

### File Configuration

The `[files]` table controls which files are included in the package:

```toml
[files]
exclude = [
    "tests/**",
    "*.test.ks",
    "drafts/*"
]
```

The `exclude` array contains glob patterns for files to exclude from compilation. The `schema/` directory is always the source root.

### Complete Example

```toml
version = "v1"

[package]
name = "acme-api"
version = "2.1.0"
description = "ACME Corporation API schema definitions"
authors = [{ name = "ACME Team", email = "schemas@acme.corp" }]
repository = "https://github.com/acme/schemas"
keywords = ["api", "acme", "enterprise"]
license = "Apache-2.0"
license_text = "Apache License 2.0"
readme = "# ACME API Schemas\n\nSchema definitions for ACME APIs."

[dependencies]
kintsu-std = "^1.0"
corp-common = { version = "^2.0", registry = "acme-internal" }
local-utils = { path = "../utils" }
external-types = { git = "https://github.com/acme/external", tag = "v1.0.0" }

[files]
exclude = ["drafts/**", "*.test.ks"]
```

### Serialization Format

The manifest uses TOML format with the following type mappings:

| Field                     | Type                   | Required |
| ------------------------- | ---------------------- | -------- |
| `version`                 | String                 | Yes      |
| `package.name`            | String                 | Yes      |
| `package.version`         | String (semver)        | Yes      |
| `package.description`     | String                 | No       |
| `package.authors`         | Array of Author        | No       |
| `package.authors[].name`  | String                 | Yes      |
| `package.authors[].email` | String                 | Yes      |
| `package.repository`      | String (URL)           | No       |
| `package.homepage`        | String (URL)           | No       |
| `package.keywords`        | Array of String        | No       |
| `package.license`         | String                 | No       |
| `package.license_text`    | String                 | No       |
| `package.readme`          | String (content/path)  | No       |
| `dependencies.*`          | Dependency spec        | No       |
| `files.exclude`           | Array of String (glob) | No       |

## Rationale

### TOML Format

TOML was chosen over alternatives:

- **JSON**: No comments, verbose for humans
- **YAML**: Whitespace-sensitive, complex edge cases
- **TOML**: Human-readable, well-specified, good tooling

### Version Envelope Pattern

The root `version` field enables non-breaking schema evolution:

```toml
version = "v1"  # Parser knows which struct to deserialize into
```

This pattern (tagged enum deserialization) is used consistently across manifest, lockfile, and declaration formats.

### Dependency Types

Four dependency types cover the full development lifecycle:

1. **Path**: Local development and monorepos
2. **Git**: Pre-release and unreleased dependencies
3. **Registry**: Production dependencies with version constraints
4. **Path+Registry**: Smooth local-to-production workflow

### Name Validation

Kebab-case package names with strict validation:

- Prevent typosquatting (similar names)
- Ensure URL-safe identifiers
- Match registry conventions
- Convert cleanly to snake_case namespaces

## Acceptance Criteria

- [ ] AC-1: Compiler parses `schema.toml` files conforming to this specification
- [ ] AC-2: Invalid package names produce clear validation errors
- [ ] AC-3: All four dependency types resolve correctly
- [ ] AC-4: Version requirements follow semver semantics
- [ ] AC-5: File exclusion patterns are respected during compilation
- [ ] AC-6: Unknown fields in future manifest versions are gracefully ignored

## Backwards Compatibility

This is the initial specification of the package manifest format. The version envelope pattern ensures future versions can extend the format without breaking existing parsers.

When a parser encounters an unknown version:

- Parsers SHOULD emit a warning
- Parsers MAY attempt to parse as the latest known version
- Parsers MUST fail gracefully with a clear error message

## References

- [SPEC-0018](/specs/spec/SPEC-0018) - Package Manifest Implementation
- [RFC-0020](/specs/rfc/RFC-0020) - Lockfile Format
- [RFC-0011](/specs/rfc/RFC-0011) - Import System
