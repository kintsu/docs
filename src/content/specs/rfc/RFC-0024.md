---
author: joshua-auchincloss
components:
  - compiler
created: 2025-12-26
kind: RFC
number: 24
status: draft
title: Workspace Manifest Format
updates:
  - author: joshua-auchincloss
    date: 2025-12-26
    description: Changed to [alias.package] syntax, added workspace inheritable fields and version-resolver
  - author: joshua-auchincloss
    date: 2025-12-26
    description: Revised to virtual manifest model with centralised schema definitions
  - author: joshua-auchincloss
    date: 2025-12-26
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0024: Workspace Manifest Format

## Summary

This RFC defines the workspace manifest format for managing multiple related Kintsu schemas within a single development environment. Workspaces use a **virtual manifest** model where all schema definitions are centralised in a single root manifest, fundamentally different from Cargo-style distributed manifests.

## Motivation

Many projects consist of multiple interconnected schemas that share common types and dependencies. Without workspace support, developers must:

- Publish intermediate schemas to a registry during development
- Manually coordinate version constraints across schemas
- Run separate build commands for each schema
- Duplicate common configuration across manifests

Workspaces solve these problems by:

- Allowing local schema references without publishing
- Centralising all package definitions in one manifest
- Enabling coordinated compilation of all schemas
- Automatic derivation of child manifests from workspace configuration

## Specification

### Virtual Manifest Model

Kintsu workspaces use a **virtual manifest** approach that differs fundamentally from tools like Cargo:

| Aspect            | Cargo (Distributed)               | Kintsu (Virtual)                           |
| ----------------- | --------------------------------- | ------------------------------------------ |
| Package manifests | Separate `Cargo.toml` per package | Single `schema.toml` at workspace root     |
| Member definition | Each member has own manifest      | All members defined via `[alias.package]`  |
| Child manifests   | Parsed from filesystem            | Compiled on-the-fly, never written to disk |
| Configuration     | Distributed with inheritance      | Fully centralised                          |
| Schema files      | Alongside manifest                | In `schema/` directory at configured path  |

### Workspace Identification

A workspace is identified by the presence of a `resolver` field in `schema.toml`. This discriminates workspace manifests from regular package manifests:

```toml title="schema.toml (workspace)"
# resolver selects the workspace parser version
resolver = "v1"

[workspace]
name = "my-workspace"

[api.package]
name = "api"
version = "1.0.0"
```

```toml title="schema.toml (package)"
# version selects the package parser version
version = "v1"

[package]
name = "my-schema"
version = "1.0.0"
```

The `resolver = "v1"` implies that all member package definitions follow the v1 format.

### Workspace Root Manifest

The workspace root contains a single `schema.toml` with all schema definitions:

```toml title="schema.toml" collapse={16-32}
resolver = "v1"

[workspace]
name = "my-workspace"
description = "A collection of related schemas"
version = "1.0.0"
version-resolver = ">= 1.0.0, < 2.0.0"
readme = { path = "./README.md" }
license-text = { path = "./LICENSE" }
license = "MIT OR Apache-2.0"

[workspace.dependencies]
external-types = "^2.0"
validation-lib = "^1.5"

# Package definitions use [alias.package] format
[common.package]
# expects './common' relative to workspace root
name = "common"
version = "1.0.0"

[api.package]
name = "api"
version.workspace = true
path = "packages/api"
readme.workspace = true
license.workspace = true
license-text.workspace = true

[api.dependencies]
common.workspace = true
external-types.workspace = true

[internal.package]
name = "internal"
version.workspace = true
path = "packages/internal"

[internal.dependencies]
common.workspace = true
api = { workspace = true, version = ">= 1.0.0" }
```

### Resolver Field

| Value  | Description                        |
| ------ | ---------------------------------- |
| `"v1"` | Current workspace resolver version |

The resolver field:

- **Must** be the first field in the manifest
- **Must** be present for the manifest to be treated as a workspace
- Implies all member package definitions follow the v1 format
- Reserved for future resolver algorithm changes

### Workspace Table

The `[workspace]` table contains workspace-wide configuration:

| Field              | Type               | Required | Description                                  |
| ------------------ | ------------------ | -------- | -------------------------------------------- |
| `name`             | string             | No       | Workspace name for display purposes          |
| `description`      | string             | No       | Workspace description                        |
| `version`          | string             | No       | Inheritable version for members              |
| `version-resolver` | string             | No       | Version requirement for inter-workspace deps |
| `readme`           | string or { path } | No       | Inheritable readme                           |
| `license`          | string             | No       | Inheritable license identifier               |
| `license-text`     | string or { path } | No       | Inheritable license text                     |

#### Workspace Inheritance

Members can inherit fields from workspace using `.workspace = true`:

```toml title="schema.toml"
[workspace]
version = "1.0.0"
license = "MIT"
readme = { path = "./README.md" }

[api.package]
name = "api"
version.workspace = true      # Inherits "1.0.0"
license.workspace = true      # Inherits "MIT"
readme.workspace = true       # Inherits { path = "./README.md" }
```

Note: `description` is **not inheritable** and must be specified per-package.

#### Version Resolver

The `version-resolver` field specifies the version requirement used when one workspace member depends on another:

```toml title="schema.toml"
[workspace]
version = "1.0.0"
version-resolver = ">= 1.0.0, < 2.0.0"

[api-ext.dependencies]
api.workspace = true  # Resolves to: api = { path = "../api", version = ">= 1.0.0, < 2.0.0" }
```

If `version-resolver` is not specified, inter-workspace dependencies use the exact inherited version (no flexibility):

```toml title="schema.toml"
[workspace]
version = "1.0.0"
# No version-resolver

[api-ext.dependencies]
api.workspace = true  # Resolves to: api = { path = "../api", version = "1.0.0" }
```

### Workspace Dependencies

The `[workspace.dependencies]` table declares shared version constraints that members can inherit:

```toml title="schema.toml"
[workspace.dependencies]
# Simple version constraint
common-types = "^1.0"

# Full dependency specification
validation = { version = "^2.0", registry = "corp" }
```

### Package Members

Package members are defined using `[alias.package]` tables, where `alias` is a unique identifier within the workspace (can differ from the package name):

```toml title="schema.toml"
# The alias "common" maps to package name "common"
[common.package]
name = "common"
version = "1.0.0"
description = "Shared types for the workspace"
license = "MIT"

# The alias "my-api" maps to package name "api"
[my-api.package]
name = "api"
version.workspace = true
path = "packages/api"
```

| Field          | Type              | Required | Description                                              |
| -------------- | ----------------- | -------- | -------------------------------------------------------- |
| `name`         | string            | Yes      | Package name (for publishing and imports)                |
| `version`      | string or inherit | Yes      | Package version (semver) or `.workspace = true`          |
| `path`         | string            | No       | Relative path to schema directory (default: `./{alias}`) |
| `description`  | string            | No       | Package description (not inheritable)                    |
| `license`      | string or inherit | No       | License identifier or `.workspace = true`                |
| `license-text` | string or inherit | No       | License text or `.workspace = true`                      |
| `readme`       | string or inherit | No       | Readme content/path or `.workspace = true`               |
| `repository`   | string            | No       | Repository URL                                           |
| `keywords`     | array             | No       | Package keywords                                         |

### Package Dependencies

Each package can have dependencies declared in `[alias.dependencies]`:

```toml title="schema.toml"
[api.package]
name = "api"
version = "1.0.0"

[api.dependencies]
# Reference workspace sibling by alias
common.workspace = true

# Inherit version from workspace.dependencies
external-types.workspace = true

# Override version requirement for compatibility checking
other-api = { workspace = true, version = ">= 1.0.0" }

# Explicit external dependency
other-lib = "^2.0"
```

### Workspace References

Dependencies reference other workspace members or inherit from `[workspace.dependencies]` using `.workspace = true`:

```toml title="schema.toml"
[api.dependencies]
# Reference to workspace sibling (resolved by alias)
common.workspace = true

# Inherit version from [workspace.dependencies]
external-types.workspace = true

# Override with explicit version requirement
other-api = { workspace = true, version = ">= 2.0.0" }
```

The workspace resolver:

1. Checks if the dependency name matches a package alias in the workspace
2. If matched, resolves to the local path with version from `version-resolver` (or exact version)
3. If not matched but in `[workspace.dependencies]`, inherits version constraint
4. If neither, reports error

### Directory Structure

Workspace structure with virtual manifests:

```text title="Workspace structure"
my-workspace/
 |--- schema.toml           # Single manifest with all definitions
 |--- schema.lock.toml      # Unified lockfile
 |--- README.md             # Workspace readme (inheritable)
 |--- LICENSE               # Workspace license (inheritable)
 |--- common/               # Default path for "common" alias
|    |--- schema/
|        |--- *.ks          # Schema files
 |--- packages/
|    |--- api/              # Custom path for "api" package
|   |    |--- schema/
|   |        |--- *.ks
|    |--- internal/
|        |--- schema/
|            |--- *.ks
 |--- target/               # Build artifacts
```

**Note:** There are no `schema.toml` files in subdirectories. The workspace manifest is the single source of truth.

### Virtual Manifest Derivation

When compiling, Kintsu derives a **virtual manifest** for each package member. This manifest is computed in-memory and never written to disk:

**Workspace definition:**

```toml title="schema.toml"
[workspace]
version = "1.0.0"
version-resolver = ">= 1.0.0, < 2.0.0"
license = "MIT"

[api.package]
name = "api"
version.workspace = true
description = "API schema definitions"
path = "packages/api"
license.workspace = true

[api.dependencies]
common.workspace = true
external-types.workspace = true
```

**Derived virtual manifest (conceptual):**

```toml title="Derived manifest for api"
version = "v1"

[package]
name = "api"
version = "1.0.0"
description = "API schema definitions"
license = "MIT"

[dependencies]
common = { path = "../common", version = ">= 1.0.0, < 2.0.0" }
external-types = "^2.0"
```

Use `kintsu inspect --schema api` to view the derived manifest for a workspace member.

### Unified Lockfile

Workspaces use a single `schema.lock.toml` at the workspace root:

```toml title="schema.lock.toml"
version = 1

[[package]]
name = "external-types"
version = "2.1.0"
source = "registry+https://registry.kintsu.dev"
checksum = "sha256:abc123..."

# Workspace members are not locked (they're local)
```

Benefits:

- Single source of truth for all external dependencies
- Atomic updates across all schemas
- Simpler CI/CD caching

### Flat Workspace Constraint

**Nested workspaces are not allowed.** If a subdirectory contains a `schema.toml` with a `resolver` field, an error is emitted.

The workspace does not parse any `schema.toml` files outside the rootâ€”child manifests are automatically derived from the centralised package definitions.

### Workspace Discovery

When running CLI commands, the workspace root is discovered by:

1. Starting from the current directory
2. Walking up parent directories
3. Looking for `schema.toml` with `resolver` field
4. Stopping at filesystem root or first match

If no workspace is found, commands operate on the current directory's `schema.toml` as a standalone package.

### Compilation Behaviour

When compiling a workspace:

1. **Parse Workspace**: Read the single `schema.toml` and validate all `[alias.package]` definitions
2. **Derive Manifests**: Compute virtual manifests for each member
3. **Dependency Graph**: Build a DAG of all workspace schemas
4. **Topological Sort**: Order schemas so dependencies compile first
5. **Parallel Compilation**: Compile independent schemas in parallel
6. **Artifact Location**: Each schema's output goes to `target/{schema-name}/`

```bash
# Compile all schemas in dependency order
kintsu check

# Compile specific schema and its dependencies
kintsu check --schema api

# Watch mode for all schemas
kintsu check --watch
```

### Error Conditions

| Condition                                     | Description                                      |
| --------------------------------------------- | ------------------------------------------------ |
| Invalid TOML syntax in workspace manifest     | Malformed TOML in root `schema.toml`             |
| No packages found in workspace                | No `[alias.package]` definitions                 |
| Circular dependency between workspace schemas | Schema A depends on B, B depends on A            |
| Invalid workspace configuration field         | Unknown field in `[workspace]` or package tables |
| Nested workspace detected                     | Subdirectory contains `resolver` field           |
| Schema path escapes workspace root            | Path like `../external` not allowed              |
| Duplicate package name in workspace           | Two packages with same `name` field              |
| Duplicate alias in workspace                  | Two packages using same alias                    |
| Version conflict for shared dependency        | Incompatible constraints across members          |
| Workspace manifest not found when expected    | Command expects workspace but none found         |
| Configured schema directory not found         | `path` points to non-existent directory          |
| Referenced workspace schema not found         | `.workspace = true` for non-existent schema/dep  |

See [ERR-0015](/specs/err/err-0015) for detailed error definitions.

## Compatibility

### CLI Commands

All CLI commands work with workspaces:

| Command            | Workspace Behaviour                                 |
| ------------------ | --------------------------------------------------- |
| `kintsu check`     | Compiles all schemas in dependency order            |
| `kintsu check`     | Validates all schemas                               |
| `kintsu update`    | Updates unified lockfile                            |
| `kintsu add <dep>` | Adds to workspace.dependencies                      |
| `kintsu publish`   | Publishes specified schema only                     |
| `kintsu inspect`   | Shows all derived manifests (or `--schema` for one) |

### Inspecting Virtual Manifests

To view the derived manifest for a workspace member:

```bash
# Show all schemas' derived manifests
kintsu inspect

# Show specific schema's derived manifest
kintsu inspect --schema api
```

This is useful for debugging dependency resolution and understanding what configuration is derived for each member.

## Acceptance Criteria

### AC-1: Workspace Identification

Given a `schema.toml` with `resolver = "v1"`, when parsed, then it must be treated as a workspace manifest.

### AC-2: Member Discovery

Given a workspace with `[alias.package]` definitions, when resolved, then all members must be discovered and validated.

### AC-3: Workspace Dependencies

Given `[workspace.dependencies]`, when a member uses `.workspace = true`, then the version must be inherited correctly.

### AC-4: Sibling References

Given workspace members, when one references another with `.workspace = true`, then the local path must be used.

### AC-5: Unified Lockfile

Given a workspace, when dependencies are locked, then a single `schema.lock.toml` must be created at the root.

### AC-6: Virtual Manifest Derivation

Given a workspace member, when inspected, then the derived manifest must reflect all inherited and explicit configuration.

### AC-7: Path Validation

Given a schema path escaping workspace root, when validated, then an error must be emitted.

### AC-8: Dependency Order

Given workspace schemas with inter-dependencies, when compiled, then dependencies must be compiled before dependents.

### AC-9: Workspace Discovery

Given a nested directory within a workspace, when running CLI commands, then the workspace root must be discovered.

### AC-10: Duplicate Name Detection

Given duplicate package names, when validated, then an error must be emitted.

### AC-11: No Child Manifests

Given a workspace, when compiling, then no `schema.toml` files must be read from member directories.

### AC-12: Version Inheritance

Given `version.workspace = true`, when deriving manifest, then `[workspace].version` must be used.

### AC-13: Version Resolver

Given `version-resolver` in workspace, when resolving inter-workspace deps, then the resolver constraint must be used.

### AC-14: Field Inheritance

Given inheritable fields with `.workspace = true`, when deriving manifest, then workspace values must be inherited.

## References

- [RFC-0019](/specs/rfc/rfc-0019) - Package Manifest Format
- [RFC-0020](/specs/rfc/rfc-0020) - Lockfile Format
- [ERR-0015](/specs/err/err-0015) - Workspace Errors
