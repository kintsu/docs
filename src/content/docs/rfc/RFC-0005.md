---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 5
status: draft
title: Error Type Design
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0005: Error Type Design

## Abstract

This RFC documents the design rationale for error types in Kintsu, which provide structured representations of operation failure modes. Error types declare named variants that can carry data payloads (tuple variants with type references or struct variants with inline fields). Errors are associated with operations via metadata attributes, enabling type-safe error handling in client code. This RFC explains the motivation for three variant styles, the automatic extraction of anonymous structs in struct variants, and the operation association mechanism.

## Motivation

RPC and message-passing systems need explicit, type-safe representations of failure modes. Without structured error types, schema authors must resort to:

- Opaque error messages (e.g., returning `str` for all failures)
- Generic result envelopes with untyped error codes
- Ad-hoc discriminated unions lacking compile-time validation

Errors address these problems by:

- Providing named variants for distinct failure cases (e.g., `Timeout`, `InvalidInput`, `DatabaseError`)
- Supporting data payloads for variant-specific context (timestamps, field names, error codes)
- Enabling compiler validation of error-operation associations
- Allowing code generators to translate to native error types in target languages (exceptions, Result types, tagged unions)

Use cases include: operation-specific errors (validation failures, timeouts, auth errors), domain errors (database errors, external API failures), and structured diagnostic information.

## Specification

This section summarizes the syntax and association behavior. Detailed normative rules appear in TSY-0005 and SPEC-0005.

### Syntax

Errors are declared with the `error` keyword, a name, and a brace-delimited list of variants:

```kintsu
error NetworkError {
    Timeout {
        endpoint: str,
        duration_ms: i64
    },
    ConnectionRefused(SocketError),
    Unknown
}
```

### Variant styles

- **Struct variants**: inline brace-delimited field list (e.g., `Timeout { endpoint: str, ... }`). The compiler extracts the inline struct and generates a named struct type.
- **Tuple variants**: parenthesized reference to an existing type (e.g., `ConnectionRefused(SocketError)`).
- **Unit variants**: name only, no payload (e.g., `Unknown`).

### Anonymous struct extraction for struct variants

Struct variants with inline fields are treated as anonymous structs during compilation. The compiler extracts them and generates struct names by concatenating the error name and variant name:

**Example:**

```kintsu
error RequestError {
    InvalidInput {
        field: str,
        expected: str
    }
};
```

After extraction, the compiler synthesizes:

```kintsu
struct RequestErrorInvalidInput {
    field: str,
    expected: str
};

error RequestError {
    InvalidInput(RequestErrorInvalidInput)
};
```

### Operation association

Errors are associated with operations using the `#[err(...)]` metadata attribute. Operations with result types (indicated by `!` suffix on return type) must have an associated error type.

**Operation-level:**

```kintsu
error ValidationError {
    MissingField { name: str }
};

#[err(ValidationError)]
operation validate(input: str) -> bool!
```

**Namespace-level (default for all operations):**

```kintsu
#![err(ApiError)]

namespace api

error ApiError {
    Unknown { report_id: str }
};

operation process(value: i32) -> str!
```

## Rationale

### Three variant styles

Supporting struct, tuple, and unit variants balances ergonomics with flexibility:

- **Struct variants** reduce boilerplate for error-specific context (e.g., validation failures with field names and reasons). Automatic extraction to named structs ensures downstream tooling treats them as first-class types.
- **Tuple variants** enable reuse of existing types (e.g., wrapping standard IO errors or database errors).
- **Unit variants** provide lightweight markers for simple failure cases (e.g., `Unknown`, `NotImplemented`).

### Automatic extraction for struct variants

Extracting inline struct payloads to named types ensures:

- Code generators can emit target-language struct/class definitions
- Documentation tools can reference generated names
- Validation and serialization logic treats error payloads uniformly

The naming strategy (ErrorName + VariantName) produces readable, predictable identifiers that match the semantic relationship between the error and its variant.

### Operation association via metadata

Using attributes (`#[err(...)]`) to associate errors with operations keeps the schema declarative and avoids embedding error handling logic in operation signatures. This separation allows:

- Namespace-level defaults (reducing repetition for common error types)
- Operation-specific overrides (for specialized error handling)
- Clear compile-time validation (operations with result types must have errors)

## Acceptance Criteria

- [ ] AC-1: The RFC explains why error types improve structured error handling for operations (explicit failure modes, type-safe payloads).
- [ ] AC-2: The RFC documents the three variant styles (struct/tuple/unit) and their use cases.
- [ ] AC-3: The RFC clarifies the anonymous struct extraction behavior for struct variants (ErrorName + VariantName â†’ generated struct name).
- [ ] AC-4: The RFC describes the operation association mechanism (`#[err(...)]` at operation or namespace level) and validates that result types require error associations.

## Backwards Compatibility

This RFC documents the existing error type behavior. Future changes that alter the variant extraction naming algorithm (e.g., changing case conventions or adding disambiguation suffixes) would be breaking for tooling. Such changes require explicit migration guidance.

## References

- [TSY-0005: Error Types](/tsy/tsy-0005)
- [SPEC-0005: Error Compilation](/spec/spec-0005)
