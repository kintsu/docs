---
author: joshua-auchincloss
components:
  - compiler
created: 2025-10-30
kind: RFC
number: 13
status: draft
title: Type Resolution Design
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0013: Type Resolution Design

## Abstract

This RFC defines an eight-phase type resolution system for Kintsu compilers that transforms raw parsed types into fully resolved, validated type definitions. The multi-phase approach handles complex interdependencies between type features (anonymous structs, unions, aliases, metadata) by processing them in a specific order that ensures each phase can depend on the outputs of previous phases. This design enables deterministic, predictable type resolution across all compiler implementations.

## Motivation

### The Type Resolution Challenge

Type resolution in Kintsu is complex because different type features have interdependencies that must be resolved in a specific order:

**Problem 1: Anonymous Struct Dependencies**

Anonymous structs can appear inline within fields, but must be extracted and registered as named types before other features can reference them:

```kintsu
struct User {
    address: {           // Anonymous struct
        street: string,
        city: string,
    }
};
```

Before resolving unions or aliases, we need `UserAddress` to exist as a named type.

**Problem 2: Union-Alias Circular Dependencies**

Unions can reference type aliases, and type aliases can reference unions:

```kintsu
type Address = string | AddressStruct;

struct User {
    address: Address,    // References alias
};
```

We must resolve aliases before validating unions, but unions must be identified before alias resolution.

**Problem 3: Metadata Inheritance Dependencies**

Version and error metadata depend on both namespace-level defaults and item-level overrides:

```kintsu
namespace api {
    #![version(1)]
    #![err(ApiError)]

    struct User { ... };  // Inherits metadata
};
```

Metadata resolution requires all types to be registered first.

**Problem 4: Reference Validation Timing**

Type references can only be validated after all types (including generated types like anonymous structs and unions) have been registered:

```kintsu
struct Post {
    author: User,    // Must validate User exists
};
```

### Why Sequential Phases?

A single-pass resolution approach fails because:

1. Cannot validate union members before extracting anonymous structs
2. Cannot resolve aliases before identifying unions
3. Cannot validate references before all types are registered
4. Cannot merge unions before validating their members

A multi-phase system solves these dependencies by establishing a clear execution order.

## Specification

### Eight-Phase Resolution System

Type resolution proceeds through eight sequential phases, each with specific inputs, outputs, and responsibilities:

#### Phase 1: Anonymous Struct Extraction

**Purpose**: Extract inline anonymous structs and generate named types

**Input**: Raw parsed namespace with inline anonymous structs

**Process**:

- Traverse all type definitions depth-first
- Identify anonymous struct patterns (inline `{ field: type }` syntax)
- Generate PascalCase names based on context (parent type + field name)
- Extract anonymous structs as named struct definitions
- Replace anonymous references with named type references

**Output**: Collection of generated struct definitions

**Example transformation**:

```kintsu
// Before Phase 1
struct User {
    address: {
        street: string,
        city: string,
    },
};

// After Phase 1 (generated)
struct UserAddress {
    street: string,
    city: string,
};

struct User {
    address: UserAddress,  // Reference replaced
};
```

#### Phase 2: Union Identification

**Purpose**: Identify union type expressions and prepare for resolution

**Input**: Types with anonymous structs resolved

**Process**:

- Scan all type positions for union syntax (`A | B | C`)
- Record union locations with context (field name, type alias, etc.)
- Generate names for unions based on context
- Track union members for later validation

**Output**: Collection of identified union records

#### Phase 3: Type Alias Resolution

**Purpose**: Resolve all type aliases to their concrete target types

**Input**: Types with unions identified

**Process**:

- Build dependency graph of type aliases
- Detect circular alias references
- Resolve aliases in topological order
- Follow alias chains to terminal types
- Cache resolved types for reuse

**Output**: Map of alias names to resolved types

**Example**:

```kintsu
type StringOrInt = string | i32;
type Value = StringOrInt;  // Resolves through chain

// Phase 3 result:
// Value -> StringOrInt -> (string | i32)
```

#### Phase 4: Union Validation

**Purpose**: Validate that all union members are valid struct types

**Input**: Unions identified, aliases resolved

**Process**:

- For each union, resolve all member types
- Follow aliases to concrete types
- Verify all members are struct types (no primitives in unions)
- Validate all member types exist

**Output**: Validated union records ready for merging

**Constraint**: Unions can only contain struct types

```kintsu
// Valid
type Address = ResidentialAddress | BusinessAddress;

// Invalid
type Value = string | i32;  // Primitives not allowed in unions
```

#### Phase 5: Union Merging

**Purpose**: Merge union member structs into single generated structs

**Input**: Validated unions

**Process**:

- For each union, collect all fields from all member structs
- Merge fields left-to-right (first occurrence wins for duplicates)
- Generate new struct definition with merged fields
- Name generated struct based on union context

**Output**: Collection of generated union struct definitions

**Example**:

```kintsu
struct A { id: i64, name: string };
struct B { id: str, email: string };

type AB = A | B;

// Phase 5 generates:
struct AB {
    id: i64,      // From A (first occurrence)
    name: string, // From A
    email: string, // From B
};
```

#### Phase 6: Version Metadata Resolution

**Purpose**: Resolve effective version metadata for all types

**Input**: All types registered (including generated types)

**Process**:

- Check namespace-level `#![version(n)]` inner attribute
- For each type, check item-level `#[version(n)]` outer attribute
- Apply precedence: item-level > namespace-level > default (1)
- Store resolved version for each type

**Output**: Map of type names to version numbers

#### Phase 7: Error Metadata Resolution

**Purpose**: Resolve effective error types for fallible operations

**Input**: All types and operations registered

**Process**:

- Check namespace-level `#![err(ErrorType)]` inner attribute
- For each operation, check item-level `#[err(ErrorType)]` outer attribute
- Determine if operation is fallible (return type with `!` suffix)
- Apply precedence: operation-level > namespace-level
- Validate fallible operations have error types

**Output**: Map of operation names to error type names

#### Phase 8: Type Reference Validation

**Purpose**: Validate all type references resolve to declared types

**Input**: All types registered, all metadata resolved

**Process**:

- Traverse all type references in structs, operations, enums, errors
- Check each reference against type registry
- Validate cross-namespace references
- Validate cross-schema references
- Report missing types with source locations

**Output**: Validation result (success or errors)

### Phase Dependencies

Each phase depends on previous phases:

```
Phase 1 (Anonymous Structs)
    ↓
Phase 2 (Union Identification) - depends on Phase 1 (all structs extracted)
    ↓
Phase 3 (Alias Resolution) - depends on Phase 2 (unions identified)
    ↓
Phase 4 (Union Validation) - depends on Phase 3 (aliases resolved)
    ↓
Phase 5 (Union Merging) - depends on Phase 4 (unions validated)
    ↓
Phase 6 (Version Metadata) - depends on Phase 5 (all types registered)
    ↓
Phase 7 (Error Metadata) - depends on Phase 6 (versions resolved)
    ↓
Phase 8 (Reference Validation) - depends on Phase 7 (metadata complete)
```

### Execution Model

**Sequential execution**: Phases execute sequentially for each namespace

**Per-namespace isolation**: Each namespace runs through all eight phases independently

**Output aggregation**: Results collected in `NamespaceResolution` structure

```rust
pub struct NamespaceResolution {
    pub anonymous_structs: Vec<StructDef>,      // Phase 1
    pub identified_unions: Vec<UnionRecord>,    // Phase 2
    pub resolved_aliases: BTreeMap<String, Type>, // Phase 3
    pub union_structs: Vec<StructDef>,          // Phase 5
    pub versions: BTreeMap<String, u32>,        // Phase 6
    pub errors: BTreeMap<String, String>,       // Phase 7
    // Phase 4 and 8 are validation-only (no output artifacts)
};s
```

## Rationale

### Why Eight Phases?

Each phase addresses a specific concern and produces outputs consumed by later phases. Fewer phases would create circular dependencies; more phases would add unnecessary complexity.

**Phase 1 must come first** because anonymous structs can appear anywhere and must be extracted before other features can reference them.

**Phase 2 before Phase 3** because alias resolution needs to know which types are unions to properly resolve union expressions.

**Phase 3 before Phase 4** because union validation requires following aliases to terminal types.

**Phase 4 before Phase 5** because merging requires validated unions to prevent invalid merges.

**Phase 5 before Phase 6/7** because metadata resolution requires all generated types (unions) to be registered.

**Phase 6/7 before Phase 8** because reference validation needs complete type registry including metadata.

### Why Sequential Rather Than Parallel?

Phases have strict dependencies that prevent parallelization within a namespace:

- Phase 5 cannot start until Phase 4 completes validation
- Phase 8 cannot start until all types are registered (Phases 1-5)

However, **different namespaces can resolve in parallel** because they operate on independent type registries.

### Why Separate Validation Phases?

Phase 4 (union validation) and Phase 8 (reference validation) are pure validation phases that produce no output artifacts. This separation provides:

1. **Early error detection**: Union errors caught before expensive merging
2. **Clear error messages**: Validation failures reference specific phases
3. **Fail-fast behavior**: Stop processing on validation failure

### Alternative Approaches Considered

**Alternative 1: Single-pass resolution with backtracking**

Attempt to resolve everything in one pass, backtrack on failures.

Rejected: Backtracking is non-deterministic, complex to implement, and difficult to debug.

**Alternative 2: Iterative fixed-point resolution**

Repeatedly process types until no changes occur.

Rejected: Non-deterministic iteration count, unclear termination conditions, poor error messages (which iteration failed?).

**Alternative 3: Demand-driven lazy resolution**

Resolve types on-demand when referenced.

Rejected: Difficult to detect circular dependencies, poor error ordering (deep stack traces), hard to parallelize.

**Chosen approach**: Sequential eight-phase resolution

**Benefits**:

- Deterministic execution order
- Clear phase boundaries
- Predictable error reporting
- Enables per-namespace parallelization
- Easy to understand and debug
- Verifiable phase invariants

## Acceptance Criteria

- [ ] **AC-1**: The RFC describes all eight phases of type resolution with clear inputs and outputs.
- [ ] **AC-2**: The RFC explains the dependency relationships between phases.
- [ ] **AC-3**: The RFC specifies the sequential execution model for phases within a namespace.
- [ ] **AC-4**: The RFC documents the `NamespaceResolution` aggregation structure.
- [ ] **AC-5**: The RFC provides rationale for the eight-phase design over alternative approaches.
- [ ] **AC-6**: The RFC explains why phases must execute sequentially within a namespace.
- [ ] **AC-7**: The RFC includes examples demonstrating transformations performed by each phase.
- [ ] **AC-8**: The RFC specifies the fail-fast validation behavior (Phase 4 and Phase 8).

## Backwards Compatibility

This RFC codifies the existing eight-phase resolution implementation. No changes to compiler behavior are introduced.

Existing schemas continue to resolve identically through the eight phases. The RFC formalizes what was previously implicit in the implementation.

## References

- [AD-0001](../ad/AD-0001.md) - Type Resolution Architecture
- [SPEC-0013](../spec/SPEC-0013.md) - Type Resolution Phases (detailed implementation)
- [RFC-0003](RFC-0003.md) - Anonymous Structs
- [RFC-0007](RFC-0007.md) - Union Types
- [RFC-0006](RFC-0006.md) - Type Aliases
- [RFC-0012](RFC-0012.md) - Metadata System
