---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 9
status: draft
title: Operation Design
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0009: Operation Design

## Abstract

Operations are the primary interface definitions for RPC-style APIs in Kintsu. This RFC documents the design motivation for operation syntax, error handling strategy (fallible vs infallible operations), metadata-based error association, and the rationale for PascalCase naming conventions in error metadata storage. Operations represent callable endpoints with typed parameters and return values, supporting both infallible operations (always succeed) and fallible operations (may return errors using result types).

## Motivation

### RPC Interface Definition Problem

Modern API development requires clear, typed interface definitions that:

- **Define callable endpoints** with explicit parameter contracts
- **Specify return types** for type-safe client generation
- **Distinguish success from failure** paths without weak typing
- **Associate error types** with operations that may fail

Without explicit operation definitions, API contracts are implicit, leading to runtime errors, type mismatches, and unclear error handling expectations.

### Error Handling Strategy

Operations must support both:

- **Infallible operations**: Always succeed (e.g., `get_config() -> str`)
- **Fallible operations**: May return errors (e.g., `get_user(id: i64) -> User!`)

The `!` suffix on return types indicates a result type, distinguishing fallible operations from infallible ones at the schema level. This allows code generators to emit appropriate error handling in target languages (e.g., `Result<T, E>` in Rust, exceptions in Java, error tuples in Go).

### Metadata-Based Error Association

Fallible operations must declare their error types. Rather than inline error types in operation signatures (verbose), Kintsu uses metadata attributes:

```kintsu
#[err(ApiError)]
operation get_user(id: i64) -> User!;
```

This keeps operation signatures concise while maintaining type safety. Error types can be specified at operation level or namespace level for consistency across multiple operations.

## Specification

### Operation Syntax

Operations use `operation` keyword with parameters in parentheses and `->` return type:

```kintsu
operation name(param1: Type1, param2: Type2) -> ReturnType;
```

**Infallible operation:**

```kintsu
operation add(a: i32, b: i32) -> i32;
```

**Fallible operation (result type):**

```kintsu
#[err(ApiError)]
operation fetch(id: i64) -> User!;
```

### Parameter Definitions

Parameters are comma-separated with `name: Type` syntax. Optional parameters use `?` suffix:

```kintsu
operation search(
    query: str,
    limit?: i32,
    offset?: i32
) -> Result[];
```

### Return Type Forms

Operations support all type expressions in return types:

- **Primitives**: `i32`, `str`, `bool`
- **Named types**: `User`, `Config`
- **Arrays**: `Item[]`
- **Optional**: `User?`
- **OneOf**: `oneof Success | Error`
- **Result**: `Data!` (indicates fallible operation)

### Error Handling Operator

The `!` suffix on return types marks operations as fallible:

```kintsu
#[err(MyError)]
operation process() -> bool!;
```

This generates result types in target languages that force callers to handle errors explicitly.

### Error Type Association

**Operation-level attribute** (highest precedence):

```kintsu
#[err(SpecificError)]
operation task() -> str!;
```

**Namespace-level attribute** (default for all fallible operations in namespace):

```kintsu
#![err(DefaultError)]
namespace api;

operation task1() -> str!;  // Uses DefaultError
operation task2() -> i32!;  // Uses DefaultError
```

Operation-level attributes override namespace-level defaults.

### PascalCase Naming in Error Metadata

Operations are stored in error metadata using **PascalCase** names for consistency with struct/enum/error naming conventions:

```kintsu
#[err(MyError)]
operation fetch_user(id: i64) -> User!;
```

Stored as `FetchUser` in error metadata HashMap.

## Rationale

### Why Result Types with `!` Suffix?

**Alternative considered**: Separate keywords for fallible operations (e.g., `fallible operation`).

**Chosen approach**: Use `!` suffix on return types.

**Rationale**: The `!` suffix is concise, visually distinctive, and mirrors Rust's `Result` unwrapping convention. It keeps operation syntax uniform while clearly marking fallible operations at the type level, not the keyword level.

### Why Attribute-Based Error Association?

**Alternative considered**: Inline error types in signatures (e.g., `operation fetch() -> User throws ApiError`).

**Chosen approach**: Use `#[err(...)]` attributes.

**Rationale**: Attributes keep operation signatures focused on data flow (parameters â†’ return type) without cluttering with error specifications. Attributes also support namespace-level defaults, reducing repetition when many operations share the same error type.

### Why PascalCase for Error Metadata?

**Alternative considered**: Store operations with snake_case names (as declared).

**Chosen approach**: Convert to PascalCase for error metadata storage.

**Rationale**: Struct types, enum types, and error types use PascalCase naming. Error metadata associates operations with error types, so using PascalCase for operation names in metadata maintains consistency across type references. Code generators can rely on this convention when resolving operation-error associations.

### Why Operation-Level Overrides Namespace-Level?

**Alternative considered**: Require all fallible operations to specify error types explicitly.

**Chosen approach**: Support namespace-level defaults with operation-level overrides.

**Rationale**: Many APIs use a single error type for all operations (e.g., `ApiError`). Namespace-level attributes eliminate repetition. Operation-level attributes provide granularity when specific operations need different error types. This balances convenience with flexibility.

### Infallible vs Fallible Operations

**Why distinguish?**

Infallible operations represent deterministic computations (e.g., calculations, transformations) that never fail. Fallible operations represent I/O, lookups, or validations that may fail. Distinguishing at the schema level allows:

- **Code generators** to emit appropriate types (direct return vs result types)
- **Callers** to know which operations require error handling
- **Schema authors** to document failure conditions explicitly

## Acceptance Criteria

- **AC-1**: Operations are defined with `operation` keyword, parameters, and `->` return type
- **AC-2**: Parameters support optional syntax (`name?: Type`)
- **AC-3**: Return types support all type expressions (primitives, named, arrays, optional, oneOf, result)
- **AC-4**: Result types use `!` suffix to mark fallible operations
- **AC-5**: Fallible operations must have error types via `#[err(...)]` attribute
- **AC-6**: Error attributes can be specified at operation level or namespace level
- **AC-7**: Operation-level error attributes override namespace-level attributes
- **AC-8**: Operations are stored in error metadata using PascalCase names

## Backwards Compatibility

This RFC introduces operation definitions as a new feature. No breaking changes to existing type system features.

**New syntax:**

```kintsu
operation name(params) -> ReturnType;
```

**Error association syntax:**

```kintsu
#[err(ErrorType)]
operation name() -> T!;
```

These additions are backward compatible with existing struct, enum, error, union, and oneOf definitions.

## References

- [TSY-0009](../tsy/TSY-0009.md) - Operation type system rules
- [SPEC-0009](../spec/SPEC-0009.md) - Operation compilation
- [RFC-0005](../rfc/RFC-0005.md) - Error type design
- [TSY-0005](../tsy/TSY-0005.md) - Error type system rules
