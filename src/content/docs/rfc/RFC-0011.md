---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 11
status: draft
title: Import System
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0011: Import System

## Abstract

The import system enables code reuse and modular organization through `use` statements that make external types and namespaces available in the current scope. This RFC documents the design motivation for the import system, syntax choices (`use` keyword with `::` path separator), resolution strategy (namespace traversal), and the distinction between private imports (namespace-scoped) and public imports (re-exported). The import system supports cross-schema dependencies, enabling schemas to build on shared libraries.

## Motivation

### Code Reuse Problem

Complex schemas require sharing types across namespaces and schemas:

- **Within-schema reuse**: API namespace needs types from common namespace
- **Cross-schema reuse**: Application schema needs types from shared library schema
- **Dependency management**: Explicit declarations of what each namespace requires

Without imports, schemas would need to duplicate types or use fully-qualified paths everywhere, leading to maintenance burden and lack of clarity about dependencies.

### Modular Organization Requirements

Large schemas benefit from modular organization:

- **Separation of concerns**: Types organized in namespaces by domain
- **Explicit dependencies**: Import statements document what each namespace needs
- **Dependency graph**: Import relationships enable compilation ordering

### Public API Surface Control

Schemas need to control what types are publicly accessible:

- **Private imports**: Internal dependencies not exposed to consumers
- **Public imports**: Explicitly re-exported types/namespaces for schema API
- **lib.ks convention**: Central declaration of public API surface

## Specification

### Use Statement Syntax

Import statements use `use` keyword followed by a path:

```kintsu
use abc::types::User;
```

### Namespace Import

Import entire namespace:

```kintsu
use abc::types;  // Import namespace 'types' from schema 'abc'
```

All types in `abc::types` become accessible via `types::TypeName`.

### Specific Type Import

Import specific types:

```kintsu
use abc::types::User;
use abc::types::Config;
```

Types become accessible directly by name (`User`, `Config`).

### Multiple Items Syntax

Import multiple items from same namespace using braces:

```kintsu
use abc::types::{
    User,
    Config,
    Session
};
```

Equivalent to three separate `use` statements.

### Path Resolution with `::`

Paths use `::` as separator:

```kintsu
use root::sub::nested::Type;
```

Resolution follows namespace hierarchy:

1. Start with root namespace (`root`)
2. Enter child namespace (`sub`)
3. Enter grandchild namespace (`nested`)
4. Find type (`Type`)

### Private Imports (Namespace Files)

Imports in namespace `.ks` files are private:

```kintsu
# api/handlers.ks
namespace api::handlers;

use abc::types::User;  // Private to api::handlers

operation handle(user: User) -> bool;
```

`User` is visible only within `api::handlers`. Other namespaces cannot access it through `api::handlers`.

### Public Imports (lib.ks)

Imports in `lib.ks` are public and re-exported:

```kintsu
# lib.ks
namespace myschema;

use foo;
use bar;
```

Consumers of `myschema` can access `foo` and `bar` namespaces. This defines the schema's public API surface.

### Cross-Schema Dependencies

Import from other schemas (dependencies):

```kintsu
namespace myapp;

use external_pkg::types::User;
use other_schema::api::Request;
```

Dependencies must be declared in schema manifest (`schema.toml`).

## Rationale

### Why `use` Keyword?

**Alternative considered**: `import` keyword (common in other languages).

**Chosen approach**: `use` keyword.

**Rationale**: Rust convention. Kintsu follows Rust patterns where practical. `use` is familiar to Rust developers and conveys "bring into scope" semantics clearly.

### Why `::` Path Separator?

**Alternative considered**: Dot notation (e.g., `abc.types.User`).

**Chosen approach**: `::` separator.

**Rationale**: Consistency with Rust. The `::` separator is less ambiguous than `.` (which might imply member access). It clearly indicates namespace traversal. Rust's convention makes this intuitive for developers.

### Why Brace Syntax for Multiple Items?

**Alternative considered**: Require separate `use` statement for each type.

**Chosen approach**: Brace syntax for multiple items from same namespace.

**Rationale**: Reduces repetition when importing many types from one namespace. Common pattern in Rust. Improves readability by grouping related imports. The formatter can split or combine as needed.

### Why Private vs Public Import Distinction?

**Alternative considered**: All imports are public (re-exported by default).

**Chosen approach**: Private imports in namespace files, public in `lib.ks`.

**Rationale**: Most imports are internal dependencies, not part of public API. Making all imports public would expose implementation details. The `lib.ks` convention provides explicit control over public API surface, similar to Rust's module system.

### Why lib.ks for Public Imports?

**Alternative considered**: Special metadata to mark public imports.

**Chosen approach**: Dedicated `lib.ks` file at schema root.

**Rationale**: Central location for public API definition. Single source of truth for what a schema exports. Familiar pattern from Rust's `lib.rs` and Python's `__init__.py`. Makes public API immediately discoverable.

### Why Require Dependency Declarations?

**Alternative considered**: Allow importing any schema without declaration.

**Chosen approach**: Require dependencies in schema manifest.

**Rationale**: Explicit dependency management prevents version conflicts and ensures reproducible builds. Schema manifest lists dependencies with versions, similar to `Cargo.toml` or `package.json`. This enables proper dependency resolution and version checking.

## Acceptance Criteria

- **AC-1**: Use statements support `use` keyword with `::` path separator
- **AC-2**: Namespace imports bring entire namespace into scope
- **AC-3**: Specific type imports bring individual types into scope
- **AC-4**: Multiple items from same namespace use brace syntax
- **AC-5**: Imports in namespace files are private to that namespace
- **AC-6**: Imports in `lib.ks` are public and re-exported
- **AC-7**: Cross-schema imports require dependency declarations in schema manifest
- **AC-8**: Import resolution validates namespace and type existence

## Backwards Compatibility

This RFC introduces import statements as a core feature. No breaking changes to existing type system features.

**New syntax:**

```kintsu
use namespace::Type;  // Single type
use namespace::{Type1, Type2};  // Multiple types
use namespace;  // Namespace import
```

**lib.ks convention:**

```kintsu
# lib.ks - public API surface
namespace myschema;

use internal::types;
use internal::operations;
```

These additions are backward compatible with existing namespace, type, and operation definitions.

## References

- [TSY-0011](../tsy/TSY-0011.md) - Import type system rules
- [SPEC-0011](../spec/SPEC-0011.md) - Import resolution
- [RFC-0010](../rfc/RFC-0010.md) - Namespace system design
- [TSY-0010](../tsy/TSY-0010.md) - Namespace type system rules
