---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 10
status: draft
title: Namespace System
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0010: Namespace System

## Abstract

Namespaces are logical containers for type definitions and operations in Kintsu. This RFC documents the design motivation for the namespace system, file organization strategies, module structure, and the rationale for supporting both file-level and block-scoped namespace declarations. Namespaces provide hierarchical organization, prevent name collisions, and enable parallel compilation through dependency-based ordering.

## Motivation

### Code Organization Problem

As API schemas grow, organizing types and operations becomes critical:

- **Name collisions**: Multiple types with the same name (e.g., `User` in different contexts)
- **Logical grouping**: Related types scattered across definitions
- **Version management**: Different API versions with overlapping types
- **Dependency tracking**: Understanding which types depend on others

Without namespaces, schemas become flat lists of definitions, making it difficult to understand relationships and maintain consistency.

### File Organization Strategies

Modern schemas span multiple files for maintainability. The namespace system must support:

- **Single-file namespaces**: All definitions in one file (small APIs)
- **Multi-file namespaces**: Definitions spread across files (large APIs)
- **Nested namespaces**: Hierarchical organization (e.g., `company.api.v1`)

### Parallel Compilation Requirements

Large schemas benefit from parallel compilation. Namespaces enable:

- **Dependency graph construction**: Track import relationships between namespaces
- **Topological ordering**: Compile dependencies before dependents
- **Parallelism at each depth**: Compile independent namespaces simultaneously

## Specification

### File-Level Namespace Declaration

File-level namespaces use semicolon syntax:

```kintsu
# api/user.ks
namespace api;

struct User {
    id: i64,
    name: str
};

operation get_user(id: i64) -> User;
```

All definitions in the file belong to the `api` namespace.

### Block-Scoped Namespace Declaration

Block-scoped namespaces use brace syntax:

```kintsu
namespace api {
    struct User {
        id: i64,
        name: str
    };

    operation get_user(id: i64) -> User;
};
```

Definitions within the braces belong to the `api` namespace.

### Nested Namespace Hierarchy

Namespaces can be nested to create hierarchical organization:

```kintsu
namespace company;

namespace api {
    struct Request {
        foo: i32
    };

    namespace v1 {
        operation handle(req: schema::api::Request) -> bool;
    };
};
```

This creates:

- `company` (root namespace)
- `company::api` (child namespace)
- `company::api::v1` (grandchild namespace)

### Metadata Inheritance

**Inner metadata** applies to all items within the namespace:

```kintsu
#![version(2)]
#![err(DefaultError)]
namespace api;

error DefaultError { Unknown };

operation process() -> i64!;  // Inherits version 2 and DefaultError
```

**Outer metadata** applies to the namespace itself:

```kintsu
#[version(1)]
namespace legacy;
```

**Override behavior**: Item-level metadata overrides namespace-level defaults:

```kintsu
#![err(DefaultError)]
namespace api;

error DefaultError { Unknown };
error SpecificError { NotFound };

operation task1() -> str!;  // Uses DefaultError

#[err(SpecificError)]
operation task2() -> i32!;  // Overrides with SpecificError
```

### Compilation Order

Namespaces are compiled using breadth-first search by depth level:

1. **Depth 0**: Root namespaces compiled first
2. **Depth 1**: Child namespaces compiled after parents
3. **Depth 2**: Grandchild namespaces compiled last
4. **Parallelism**: Namespaces at the same depth compiled in parallel

This ensures dependencies (parent namespaces) are available before dependents (child namespaces).

### Multi-File Namespace Support

A namespace can span multiple files:

```kintsu
# api/user.ks
namespace api;

struct User { id: i64 };
```

```kintsu
# api/product.ks
namespace api;

struct Product { id: i64 };
```

Both files contribute to the `api` namespace. The compiler merges definitions from all files with the same namespace declaration.

## Rationale

### Why Both File-Level and Block-Scoped Syntax?

**Alternative considered**: Single syntax (only file-level or only block-scoped).

**Chosen approach**: Support both syntaxes.

**Rationale**: File-level syntax is concise for single-namespace files (common case). Block-scoped syntax enables multiple namespaces in one file (useful for small related namespaces or examples). Supporting both provides flexibility without adding complexity — the parser handles both forms naturally.

### Why Nested Namespaces?

**Alternative considered**: Flat namespaces with dot notation (e.g., `company.api.v1`).

**Chosen approach**: True nested namespaces with hierarchy.

**Rationale**: Nested namespaces provide:

- **Scoping**: Child namespaces inherit context from parents
- **Organization**: Clear hierarchical relationships
- **Dependency tracking**: Parent-child relationships explicit in structure

Flat namespaces with dots are syntactic sugar; true nesting provides semantic structure.

### Why Metadata at Namespace Level?

**Alternative considered**: Require metadata on every item.

**Chosen approach**: Namespace-level metadata with item-level overrides.

**Rationale**: Many items in a namespace share common metadata (e.g., version, default error type). Namespace-level metadata reduces repetition. Item-level overrides provide granularity when needed. This balances convenience (defaults) with flexibility (overrides).

### Why Inner (`#![...]`) vs Outer (`#[...]`) Metadata?

**Alternative considered**: Single metadata syntax.

**Chosen approach**: Distinguish inner (applies to children) from outer (applies to namespace itself).

**Rationale**: Rust's convention distinguishes module-level attributes (`#![...]`) from item attributes (`#[...]`). Inner metadata sets defaults for children; outer metadata applies to the namespace definition. This distinction clarifies scope without ambiguity.

### Why Breadth-First Compilation by Depth?

**Alternative considered**: Depth-first traversal or arbitrary order.

**Chosen approach**: Breadth-first by depth level, with parallelism within each level.

**Rationale**: Breadth-first ensures all namespaces at depth N are compiled before depth N+1, satisfying parent-before-child constraints. Parallelism within each level maximizes throughput. This approach balances correctness (dependency order) with performance (parallel compilation).

### Why Support Multi-File Namespaces?

**Alternative considered**: One namespace per file (strict 1:1 mapping).

**Chosen approach**: Multiple files can contribute to the same namespace.

**Rationale**: Large namespaces benefit from splitting definitions across files for maintainability. For example, `api` namespace might have `user.ks`, `product.ks`, `order.ks` — each file focuses on a specific domain, but all belong to the `api` namespace. This improves code organization without fragmenting the namespace into artificial sub-namespaces.

## Acceptance Criteria

- **AC-1**: Namespaces support file-level syntax (`namespace name;`)
- **AC-2**: Namespaces support block-scoped syntax (`namespace name { ... }`)
- **AC-3**: Namespaces can be nested to create hierarchical organization
- **AC-4**: Inner metadata (`#![...]`) applies to all children within the namespace
- **AC-5**: Outer metadata (`#[...]`) applies to the namespace definition itself
- **AC-6**: Item-level metadata overrides namespace-level defaults
- **AC-7**: Namespaces are compiled in breadth-first order by depth level
- **AC-8**: Namespaces at the same depth level can be compiled in parallel
- **AC-9**: Multiple files can contribute to the same namespace

## Backwards Compatibility

This RFC introduces namespace definitions as a core feature. No breaking changes to existing type system features.

**New syntax:**

```kintsu
namespace name;  // File-level
namespace name { ... };  // Block-scoped
```

**Metadata syntax:**

```kintsu
#![version(1)]  // Inner (applies to children)
#[version(1)]   // Outer (applies to namespace)
```

These additions are backward compatible with existing struct, enum, error, union, oneOf, and operation definitions.

## References

- [TSY-0010](/tsy/tsy-0010) - Namespace type system rules
- [SPEC-0010](/spec/spec-0010) - Namespace compilation
- [RFC-0011](/rfc/rfc-0011) - Import system design
- [TSY-0011](/tsy/tsy-0011) - Import type system rules
