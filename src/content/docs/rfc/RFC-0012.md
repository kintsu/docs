---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: RFC
number: 12
status: draft
title: Metadata System
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# RFC-0012: Metadata System

## Abstract

This RFC defines a metadata annotation system for Kintsu schemas that enables version tracking and error type defaults. Metadata uses attribute syntax (`#[...]` for outer attributes, `#![...]` for inner attributes) to annotate namespaces, types, and operations with version information and default error types. The system supports inheritance, where namespace-level metadata provides defaults that can be overridden at the type or operation level.

## Motivation

### The Version Tracking Problem

As schemas evolve over time, clients and servers need to understand which version of a type they are working with. Without explicit version tracking:

- Breaking changes are difficult to identify and communicate
- Protocol versioning becomes ad-hoc and error-prone
- Backward compatibility strategies lack structure
- Migration paths are unclear to API consumers

**Example problem:**

```kintsu
// Version 1 - original
struct User {
    id: i64,
    name: string,
}

// Version 2 - breaking change (email now required)
struct User {
    id: i64,
    name: string,
    email: string,  // New required field
}
```

Without version metadata, there's no way to distinguish these two incompatible versions.

### The Error Type Defaults Problem

Operations with fallible return types (indicated by `!` suffix) must specify which error type they use. Without defaults:

- Every fallible operation must repeat the error type annotation
- Changing the error type requires updating every operation
- Namespace-level error handling patterns are not enforceable
- Boilerplate increases with schema size

**Example problem:**

```kintsu
// Without defaults - repetitive
#[err(ApiError)]
operation getUser(id: i64) -> User!;

#[err(ApiError)]
operation updateUser(user: User) -> User!;

#[err(ApiError)]
operation deleteUser(id: i64) -> void!;
```

### Solution: Metadata Annotation System

A metadata system addresses both problems by:

1. **Version tracking**: Explicit `#[version(n)]` annotations on types and namespaces
2. **Error defaults**: Namespace-level `#![err(ErrorType)]` provides defaults for all operations
3. **Inheritance**: Inner attributes (`#![...]`) at namespace level apply to child items
4. **Override capability**: Outer attributes (`#[...]`) on specific items override defaults

## Specification

### Metadata Syntax

Metadata uses Rust-style attribute syntax with two forms:

**Outer attributes** (`#[...]`) apply to the item they precede:

```kintsu
#[version(1)]
struct User {
    id: i64,
    name: string,
}
```

**Inner attributes** (`#![...]`) apply to the containing scope (namespace) and its children:

```kintsu
namespace users {
    #![version(1)]        // Applies to types in this namespace
    #![err(UserError)]    // Default error for operations

    struct User { ... }   // Inherits version(1)

    operation getUser(id: i64) -> User!;  // Uses UserError
}
```

### Version Metadata

Version metadata tracks schema evolution using integer version numbers.

**Syntax**: `#[version(n)]` where `n` is a positive integer

**Application**:

- Namespace-level: `#![version(n)]` sets default version for all types in namespace
- Type-level: `#[version(n)]` sets specific version for individual type

**Example:**

```kintsu
namespace api {
    #![version(1)]

    struct User {
        id: i64,
        name: string,
    }  // Implicitly version 1

    #[version(2)]
    struct Account {
        id: i64,
        email: string,
    }  // Explicitly version 2
}
```

### Error Metadata

Error metadata specifies default error types for fallible operations.

**Syntax**: `#[err(ErrorType)]` where `ErrorType` is a reference to an error type

**Application**:

- Namespace-level: `#![err(ErrorType)]` sets default error for all fallible operations
- Operation-level: `#[err(ErrorType)]` overrides namespace default for specific operation

**Example:**

```kintsu
namespace api {
    #![err(ApiError)]

    // Uses ApiError (namespace default)
    operation getUser(id: i64) -> User!;

    // Uses ValidationError (operation override)
    #[err(ValidationError)]
    operation createUser(user: User) -> User!;
}
```

### Inner vs Outer Attributes

The distinction between inner (`#![...]`) and outer (`#[...]`) attributes determines scope:

**Inner attributes** (`#![...]`):

- Appear at the beginning of a namespace declaration
- Apply to all child items (types and operations) in that namespace
- Provide defaults that child items inherit
- Syntax: `#!` followed by `[metadata(...)]`

**Outer attributes** (`#[...]`):

- Appear immediately before the item they annotate
- Apply only to that specific item
- Override any inherited defaults from namespace
- Syntax: `#` followed by `[metadata(...)]`

**Example showing both:**

```kintsu
namespace api {
    #![version(1)]           // Inner: applies to children
    #![err(DefaultError)]    // Inner: applies to children

    struct User { ... }      // Inherits version(1), no error (not applicable)

    #[version(2)]            // Outer: overrides namespace version
    struct Account { ... }   // Uses version(2)

    operation getUser() -> User!;  // Inherits err(DefaultError)

    #[err(SpecificError)]    // Outer: overrides namespace error
    operation createUser() -> User!;  // Uses SpecificError
}
```

### Metadata Inheritance

Inheritance follows these rules:

1. **Namespace-level inner attributes** provide defaults for all child items
2. **Type-level outer attributes** override namespace defaults for specific types
3. **Operation-level outer attributes** override namespace defaults for specific operations
4. **Specificity wins**: More specific (closer to item) metadata overrides less specific

## Rationale

### Why Attributes Rather Than Other Syntax?

Several alternatives were considered:

**Alternative 1: Inline version in type name**

```kintsu
struct User_v1 { ... }
struct User_v2 { ... }
```

Rejected: Pollutes type names, doesn't scale, no tooling support

**Alternative 2: Separate version block**

```kintsu
version 1 {
    struct User { ... }
}
```

Rejected: Adds unnecessary nesting, breaks flat namespace structure

**Alternative 3: Comment-based metadata**

```kintsu
// @version 1
struct User { ... }
```

Rejected: Not part of AST, fragile, no validation

**Chosen approach**: Attribute syntax (`#[...]` / `#![...]`)

**Benefits**:

- Part of the AST, fully validated during parsing
- Familiar to Rust developers (reduces learning curve)
- Clear distinction between item-level and scope-level metadata
- Extensible to additional metadata types in the future
- Tooling can easily extract and process metadata

### Why Inner vs Outer Distinction?

The inner/outer distinction provides two critical capabilities:

1. **Defaults without repetition**: Inner attributes avoid boilerplate by setting namespace-wide defaults
2. **Explicit overrides**: Outer attributes allow exceptions to defaults when needed

This matches Rust's attribute model and provides a familiar, proven pattern.

### Why Integer Versions?

Version numbers use positive integers (`1`, `2`, `3`, ...) rather than semantic versioning (`1.0.0`) because:

- Simpler for schema versioning (each change gets a new number)
- Clear ordering and comparison
- No ambiguity about what constitutes a "major" vs "minor" change
- Easier to generate and validate

### Why Inheritance Model?

The inheritance model (namespace â†’ type/operation) provides:

1. **DRY principle**: Set defaults once at namespace level
2. **Flexibility**: Override when needed at item level
3. **Maintainability**: Change namespace default to update all inheriting items
4. **Clarity**: Explicit metadata at item level makes intent obvious

## Acceptance Criteria

- [ ] **AC-1**: The RFC describes attribute syntax for both outer (`#[...]`) and inner (`#![...]`) metadata forms.
- [ ] **AC-2**: The RFC specifies version metadata syntax (`#[version(n)]`) and its application to types and namespaces.
- [ ] **AC-3**: The RFC specifies error metadata syntax (`#[err(ErrorType)]`) and its application to operations and namespaces.
- [ ] **AC-4**: The RFC explains the distinction between inner and outer attributes and how they determine scope.
- [ ] **AC-5**: The RFC defines metadata inheritance rules from namespace to child items.
- [ ] **AC-6**: The RFC provides rationale for choosing attribute syntax over alternatives.
- [ ] **AC-7**: The RFC explains why integer versions are used rather than semantic versioning.
- [ ] **AC-8**: The RFC includes examples demonstrating version metadata, error metadata, inner attributes, outer attributes, and inheritance.

## Backwards Compatibility

This RFC introduces metadata as a new feature. Schemas without metadata remain valid:

**Before metadata (still valid):**

```kintsu
namespace api {
    struct User {
        id: i64,
        name: string,
    }
}
```

**With metadata (new capability):**

```kintsu
namespace api {
    #![version(1)]

    struct User {
        id: i64,
        name: string,
    }
}
```

No breaking changes are introduced. Existing schemas continue to work without modification.

## References

- [TSY-0012](/tsy/tsy-0012) - Metadata type system rules
- [SPEC-0012](/spec/spec-0012) - Metadata resolution implementation
- [RFC-0005](RFC-0005) - Error types (uses error metadata)
- [RFC-0009](RFC-0009) - Operations (uses error metadata)
- [RFC-0010](RFC-0010) - Namespace system (uses version metadata)
