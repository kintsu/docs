---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 9
status: draft
title: Operations
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0009: Operations

## Overview

This document defines the normative type-system rules for operation definitions in Kintsu. Operations represent callable RPC endpoints with typed parameters and return values. This TSY specifies operation syntax, parameter definitions (including optional parameters), return type forms, error handling operator (`!`), error type association rules (operation-level vs namespace-level), and validation constraints.

![Operation Flow](../../../../diagrams/operation_flow.png)

## Motivation

Operations are the primary interface definitions for RPC-style APIs. This TSY documents the exact syntax and type-system rules so schema authors know how to declare operations correctly and code generators can emit consistent client/server code. The error association rules are normative â€” fallible operations must have error types or compilation fails.

## Design Principles

- **Explicit typing**: All parameters and return types must be explicitly declared
- **Error safety**: Fallible operations (result types) must have associated error types
- **Metadata-based errors**: Use `#[err(...)]` attributes instead of inline error specifications
- **Optional parameters**: Support optional parameters with `?` suffix
- **Namespace-level defaults**: Allow namespace-level error types for consistency across operations
- **Operation-level overrides**: Support operation-specific error types when needed

## Type system rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu type system.

### Operation syntax and parsing

Operations use `operation` keyword followed by:

1. **Name** (identifier in snake_case)
2. **Parameters** in parentheses (comma-separated)
3. **Return type** with `->` separator

**Basic syntax:**

```kintsu
operation name(param1: Type1, param2: Type2) -> ReturnType;
```

**Infallible operation:**

```kintsu
operation add(a: i32, b: i32) -> i32;
```

**Fallible operation:**

```kintsu
#[err(ApiError)]
operation fetch(id: i64) -> User!;
```

> [!IMPORTANT]
> Operation names must be unique within their namespace. Duplicate operation names cause compilation errors.

### Parameter definitions

Parameters are defined with `name: Type` syntax, separated by commas. Parameter names must be unique within the operation.

**Parameter syntax:**

```kintsu
operation search(query: str, limit: i32, offset: i32) -> Result[];
```

**Optional parameters** use `?` suffix:

```kintsu
operation search(
    query: str,
    limit?: i32,
    offset?: i32
) -> Result[];
```

**Type validation:**

All parameter types must resolve to valid types during compilation:

- **Builtin types**: `i32`, `str`, `bool`, `f32`, `f64`, `i64`, `bytes`
- **Named types**: Struct, enum, error, oneOf, or type alias
- **Array types**: `Type[]`
- **Optional types**: `Type?`
- **OneOf types**: `oneof T1 | T2 | ...`
- **Union types**: `(T1 & T2 & ...)`

> [!WARNING]
> If any parameter type cannot be resolved, compilation fails with "type not found" error.

### Return type forms

Operations support all type expressions in return types:

**Primitives:**

```kintsu
operation calculate() -> i32;
```

**Named types:**

```kintsu
operation get_user() -> User;
```

**Arrays:**

```kintsu
operation list_items() -> Item[];
```

**Optional types:**

```kintsu
operation find(id: i64) -> User?;  // May return no value
```

**OneOf types:**

```kintsu
operation process(data: oneof str | bytes) -> bool;
```

**Result types (fallible operations):**

```kintsu
#[err(AppError)]
operation fetch(id: i64) -> Data!;  // May return error
```

> [!IMPORTANT]
> Return types must resolve to valid types. Unresolved return types cause compilation errors.

### Error handling operator (!)

The `!` suffix on return types marks operations as **fallible** (may return errors):

```kintsu
#[err(MyError)]
operation process() -> bool!;
```

This indicates the operation returns a result type (success or error), not a direct value.

**Without `!` suffix (infallible):**

```kintsu
operation calculate(a: i32, b: i32) -> i32;
```

Infallible operations always succeed and return the specified type directly.

> [!NOTE]
> The `!` suffix is part of the return type syntax, not a separate modifier. It applies to the entire return type.

### Error type association (operation-level)

Fallible operations (those with `!` suffix) must have an associated error type via the `#[err(...)]` attribute.

**Operation-level attribute:**

```kintsu
error MyError { Unknown };

#[err(MyError)]
operation process() -> i64!;
```

The error type specified must exist in the type registry.

> [!IMPORTANT]
> Fallible operations without error attributes (and without namespace-level defaults) cause compilation errors.

### Error type association (namespace-level)

Namespaces can declare a default error type for all fallible operations:

```kintsu
#![err(DefaultError)]
namespace api;

error DefaultError { Unknown };

operation task1() -> str!;  // Uses DefaultError
operation task2() -> i32!;  // Uses DefaultError
```

All fallible operations in the namespace inherit this default error type.

### Error attribute precedence

Operation-level `#[err(...)]` attributes **override** namespace-level `#![err(...)]` attributes:

```kintsu
#![err(DefaultError)]
namespace api;

error DefaultError { Unknown };
error SpecificError { NotFound };

operation task1() -> str!;  // Uses DefaultError (namespace-level)

#[err(SpecificError)]
operation task2() -> i32!;  // Uses SpecificError (operation-level override)
```

> [!NOTE]
> This precedence rule allows flexibility: use namespace-level for consistency, override for specific operations.

### Missing error type validation

If a fallible operation has no error attribute at operation level **and** no namespace-level default, compilation fails:

```kintsu
operation process() -> i64!;  // ERROR: no error type specified
```

**Compilation error:** "Missing error type for fallible operation 'process'"

> [!WARNING]
> All fallible operations must have error types. This is a compile-time validation rule.

### Infallible operations

Operations without the `!` suffix are **infallible** and never return errors:

```kintsu
operation calculate(a: i32, b: i32) -> i32;
```

Infallible operations do not require error attributes.

### Parameter and return type validation

The type system enforces:

1. **Parameter uniqueness**: Parameter names must be unique within the operation
2. **Type resolution**: All parameter and return types must resolve to valid types
3. **Error type resolution**: Error types in attributes must exist in the type registry
4. **Fallibility constraint**: Fallible operations must have error types

## Implications

**For schema authors:**

- Declare operations with typed parameters and return types
- Use `!` suffix for fallible operations
- Specify error types via `#[err(...)]` attributes
- Optional parameters use `?` suffix

**For code generators:**

- Infallible operations return types directly
- Fallible operations return result types (success or error)
- Error types are resolved from operation-level or namespace-level attributes
- Parameter types include optionality information

**For type system implementers:**

- Validate parameter uniqueness
- Resolve all parameter and return types
- Enforce error type association for fallible operations
- Apply operation-level precedence over namespace-level for error types

## References

- [RFC-0009](/rfc/rfc-0009) - Operation design rationale
- [SPEC-0009](/spec/spec-0009) - Operation compilation
- [TSY-0005](/tsy/tsy-0005) - Error type system rules
- [RFC-0005](/rfc/rfc-0005) - Error type design
