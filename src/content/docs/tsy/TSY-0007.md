---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 7
status: draft
title: Union Types
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0007: Union Types

## Overview

This document defines the normative type-system rules for union types in Kintsu. Union types compose multiple struct types using the `&` operator, merging their fields into a single generated struct. This TSY specifies union syntax, field merging rules (left-to-right precedence), nested union resolution, name generation context rules, and struct-only operand validation.

## Motivation

Union types provide field composition through merging. This TSY documents the exact merging semantics and conflict resolution rules so schema authors and code generators can rely on consistent behavior. The left-to-right precedence rule for field conflicts is normative — implementations must resolve conflicts deterministically to ensure interoperability.

## Design Principles

- **Field composition:** Unions merge fields from multiple structs into a single composite struct
- **Left-to-right precedence:** Field name conflicts are resolved by selecting the leftmost definition
- **Recursive resolution:** Nested unions (parenthesized) are resolved from innermost to outermost
- **Context-based naming:** Generated struct names depend on usage context (type alias, struct field, oneof variant)
- **Struct-only operands:** Only struct types can be merged; enums and errors are rejected

## Type system rules (normative)

The following diagram illustrates how union types merge fields from multiple structs with left-to-right precedence for conflict resolution:

![Union Field Merging](../../../../diagrams/union_field_merging.png)

### Syntax and parsing

Union type expressions use the `&` operator to compose struct types:

```kintsu
TypeA & TypeB
```

**Union operands:**

- Identifiers referencing struct types: `User & Permissions`
- Parenthesized nested unions: `A & (B & C)`
- Anonymous structs: `User & { extra: str }`

**Examples:**

```kintsu
type AuthUser = User & Permissions;
type Extended = Base & (Mixin1 & Mixin2);
type Combined = A & B & C & D;

struct Request {
    auth: User & Permissions
};
```

> [!NOTE]
> The `&` operator is left-associative: `A & B & C` parses as `(A & B) & C`.

### Field merging (left-to-right precedence)

When multiple operands define fields with the same name, the leftmost definition wins. Subsequent definitions with the same name are ignored.

**Example:**

```kintsu
struct Base {
    id: i64,
    version: i32,
    name: str
};

struct Extended {
    version: i32,  // Conflicts with Base.version
    description: str,
    tags: str[]
};

type Merged = Base & Extended;
```

**Result:**

```kintsu
struct Merged {
    id: i64,
    version: i32,      // From Base (leftmost wins)
    name: str,
    description: str,  // From Extended
    tags: str[]        // From Extended
}
```

> [!IMPORTANT]
> The leftmost occurrence of a field name determines both the field type and metadata (optionality, documentation, etc.). All subsequent occurrences are discarded.

### Nested union resolution

Parenthesized unions are resolved recursively before merging with outer operands.

**Example:**

```kintsu
struct A { x: i32, y: str };
struct B { y: str, z: bool };
struct C { z: i32 };

type Combined = A & (B & C);
```

**Resolution steps:**

1. Resolve inner union `(B & C)`:
   - Merge B and C
   - B.y (str), B.z (bool) wins over C.z (i32)
   - Result: `{ y: str, z: bool }`
2. Merge A with inner result:
   - A.x (i32), A.y (str) wins over inner y (str), z (bool) from inner
   - Result: `{ x: i32, y: str, z: bool }`

**Final struct:**

```kintsu
struct Combined {
    x: i32,  // From A
    y: str,  // From A (wins over B)
    z: bool  // From B (wins over C)
}
```

> [!WARNING]
> Resolution order matters. `A & (B & C)` produces different results than `(A & B) & C` when field conflicts involve different types.

### Multi-way unions

Unions with multiple operands are resolved left-to-right:

```kintsu
type Multi = A & B & C & D;
```

**Resolution steps:**

1. Merge A and B → `AB`
2. Merge AB and C → `ABC`
3. Merge ABC and D → `ABCD`

Each merge step follows left-to-right precedence for field conflicts.

### Name generation (context-dependent)

The generated struct name depends on the union's usage context:

**In type alias:** Uses the alias name

```kintsu
type UserData = User & Permissions;
// Generated struct name: UserData
```

**In struct field:** Uses parent struct name + field name (PascalCase)

```kintsu
struct Request {
    auth: User & Permissions
};
// Generated struct name: RequestAuth
```

**In oneof variant:** Uses parent name + variant index (1-indexed)

```kintsu
type Response = oneof (A & B) | (C & D);
// Generated struct names: Response1, Response2
```

> [!IMPORTANT]
> Name generation follows the same context-based rules as anonymous structs (TSY-0003) to ensure consistency.

### Union operand validation

All union operands must resolve to struct types. Operands referencing enums, errors, or other non-struct types are rejected.

**Valid operands:**

```kintsu
struct User { id: i64 };
struct Permissions { can_read: bool };
type Valid = User & Permissions;  // OK: both are structs
```

**Invalid operands:**

```kintsu
enum Status { Active, Inactive }
struct User { id: i64 }
type Invalid = User & Status;  // ERROR: 'Status' is an enum, not a struct
```

> [!WARNING]
> The compiler must validate operand types before field merging. If any operand is not a struct, the union resolution fails.

### Union operand resolution

Before field merging, all operand names must resolve to registered types:

```kintsu
type AuthUser = User & Permissions;
```

Both `User` and `Permissions` must exist in the type registry. If any operand cannot be resolved, union processing fails.

**Example (invalid):**

```kintsu
type Invalid = User & UnknownType;  // ERROR: type 'UnknownType' not found
```

### Anonymous struct operands

Union operands can be anonymous structs (inline field lists):

```kintsu
type Extended = User & {
    extra_field: str,
    metadata: i64
};
```

Anonymous struct operands are extracted and merged with other operands following the same left-to-right precedence rules.

> [!NOTE]
> Anonymous struct extraction (TSY-0003) occurs before union resolution, so anonymous operands are treated as named structs during merging.

## Implications

**For schema authors:**

- Unions enable modular field composition without duplication
- Left-to-right precedence provides predictable conflict resolution
- Context-based naming generates meaningful struct names

**For code generators:**

- Union resolution is deterministic — same schema produces same merged fields
- Generated structs have predictable names based on usage context
- Struct-only validation ensures type safety

**For tooling:**

- Field conflicts can be detected and reported with the leftmost winner
- Union resolution can be traced step-by-step for debugging
- Generated struct names can be predicted from context

## References

- [RFC-0007](/rfc/rfc-0007) - Union type design rationale
- [SPEC-0007](/spec/spec-0007) - Union type compilation implementation
- [TSY-0002](/tsy/tsy-0002) - Struct types
- [TSY-0003](/tsy/tsy-0003) - Anonymous structs
- [TSY-0008](/tsy/tsy-0008) - OneOf types (for comparison)
