---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 4
status: draft
title: Enum Types
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0004: Enum Types

## Overview

This document defines the normative type-system rules for enum types in Kintsu. Enums declare a named set of variants with discriminant values. The parser recognizes three variant styles: unit variants (name only, auto-assigned integer discriminants), integer-valued variants (explicit `i64` discriminants), and string-valued variants (explicit string discriminants). This TSY specifies the syntax, value type consistency rules, discriminant assignment algorithm, and validation constraints.

![Enum Variant Types](../../../../diagrams/enum_variants.png)

## Motivation

Enums provide type-safe representations of categorical data. This TSY documents the exact syntax and validation semantics so schema authors and code generators can rely on consistent enum behavior. The discriminant assignment algorithm is normative â€” implementations must assign values deterministically to ensure interoperability.

## Design Principles

- Value type consistency: all variants within an enum must use the same discriminant type (integer or string). This ensures unambiguous wire-format serialization and enables translation to native enum types in target languages.
- Sequential assignment: unit variants (no explicit value) receive auto-assigned integer discriminants starting from 0, incrementing by 1. This reduces boilerplate for simple categorical enums.
- Explicit control: schema authors may specify explicit discriminants when domain semantics require specific values (e.g., HTTP status codes, database enum IDs).

## Type system rules (normative)

### Syntax and parsing

Enum declarations use the `enum` keyword followed by a name and a brace-delimited list of variants separated by commas.

**Variant syntax:**

- `VariantName` (unit variant)
- `VariantName = <value>` (explicit value)

Explicit values must be integer literals (`i64`) or string literals.

**Example:**

```kintsu
enum Status {
    Pending = 0,
    Active = 1,
    Inactive = 2
}

enum Role {
    Admin = "admin",
    User = "user"
}
```

### Value type inference and validation

The parser determines the enum's value type by examining the first variant with an explicit value:

- If the first explicit value is an integer, the enum is an integer enum.
- If the first explicit value is a string, the enum is a string enum.
- If no variants have explicit values, the enum defaults to integer type.

> [!IMPORTANT]
> All variants must use the same value type. Mixing integer and string values is rejected with a parse error.

**Example (invalid):**

```kintsu
enum Mixed {
    First = 1,
    Second = "two"  // ERROR: inconsistent value type
}
```

### Discriminant assignment algorithm

**Integer enums:**

- If a variant has no explicit value and is the first variant, assign `0`.
- If a variant has no explicit value and follows another variant, assign the previous variant's value + 1.
- If a variant has an explicit value, use that value.

**String enums:** All variants must have explicit values. Auto-assignment is not supported for string enums.

**Examples:**

```kintsu
enum Priority {
    Low,      // 0
    Medium,   // 1
    High      // 2
}

enum HttpStatus {
    Ok = 200,
    Created = 201,
    NotFound = 404
}
```

### Variant name uniqueness

Variant names must be unique within the enum. Duplicate names are rejected with a compile error.

**Example (invalid):**

```kintsu
enum Status {
    Active,
    Inactive,
    Active  // ERROR: duplicate variant 'Active'
}
```

### Explicit value uniqueness

Explicit values should be unique within the enum (two variants should not have the same discriminant value).

> [!WARNING]
> The compiler does not enforce this as an error (some use cases intentionally define aliases), but duplicate values may cause issues in generated code depending on the target language. Code generators should warn or error on duplicate discriminants if the target language does not support aliased enum values.

### Enum type references

Enums are first-class types and can be referenced by name in struct fields, operation parameters, return types, and type aliases.

**Example:**

```kintsu
enum Status {
  Active,
  Inactive
}

struct User {
    id: i64,
    status: Status
}
```

## Implications

- Code generators must translate enum discriminants to target-language enum values. Integer enums map to numeric enums; string enums map to string-based enums or string constants.
- Wire-format serializers must preserve discriminant values exactly as specified in the schema (no reordering or normalization).
- Schema authors should document the semantic meaning of discriminant values (especially for integer enums with explicit values like HTTP status codes).

## References

- [RFC-0004: Enum Type Design](/rfc/rfc-0004)
- [SPEC-0004: Enum Compilation](/spec/spec-0004)
