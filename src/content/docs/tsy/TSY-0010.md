---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: TSY
number: 10
status: draft
title: Namespaces
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# TSY-0010: Namespaces

## Overview

This document defines the normative type-system rules for namespace declarations in Kintsu. Namespaces are logical containers for type definitions and operations. This TSY specifies namespace syntax (file-level and block-scoped), nested namespace rules, metadata (inner and outer), child item uniqueness constraints, and type resolution stages within namespaces.

![Namespace Hierarchy](../../../../diagrams/namespace_hierarchy.png)

## Motivation

Namespaces provide hierarchical organization for schemas. This TSY documents the exact syntax and semantics so schema authors know how to declare namespaces correctly and code generators can navigate namespace hierarchies reliably. The nested namespace rules and metadata inheritance are normative â€” implementations must follow these rules to ensure consistent behavior.

## Design Principles

- **Two syntaxes**: Support file-level (semicolon) and block-scoped (braces) for flexibility
- **Nested hierarchy**: Allow nested namespaces for hierarchical organization
- **Metadata inheritance**: Namespace-level metadata applies to all children
- **Item-level overrides**: Children can override namespace defaults
- **Unique names**: Child item names must be unique within their namespace
- **Type resolution stages**: Process types in deterministic order

## Type system rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu type system.

### File-level namespace syntax

File-level namespaces use semicolon syntax after the `namespace` keyword:

```kintsu
namespace api;

struct User {
    id: i64,
    name: str
};
```

All definitions in the file belong to the declared namespace.

**Rules:**

- File-level namespace declaration must appear before any type definitions
- Only one file-level namespace declaration allowed per file
- All subsequent definitions belong to this namespace

> [!IMPORTANT]
> File-level namespace declarations use semicolon (`;`) syntax, not braces.

### Block-scoped namespace syntax

Block-scoped namespaces use brace syntax:

```kintsu
namespace api {
    struct User {
        id: i64,
        name: str
    };
};
```

Definitions within the braces belong to the declared namespace.

**Rules:**

- Block-scoped namespaces can appear multiple times in a file
- Definitions must be within the braces to belong to the namespace
- Braces create explicit scope boundaries

> [!NOTE]
> Block-scoped syntax enables multiple namespaces in one file.

### Nested namespace rules

Namespaces can be nested to create hierarchical organization:

```kintsu
namespace company;

namespace api {
    struct Request { foo: i32 };

    namespace v1 {
        operation handle(req: schema::api::Request) -> bool;
    };
};
```

**Hierarchy:**

- `company` (root namespace, depth 0)
- `company::api` (child namespace, depth 1)
- `company::api::v1` (grandchild namespace, depth 2)

**Rules:**

- Nested namespaces are children of their parent namespace
- Full path is constructed by joining parent and child names with `::`
- Depth is determined by nesting level (root = 0)

> [!IMPORTANT]
> Nested namespaces inherit the parent's context. Full paths include all parent names.

### Flat vs nested semantics

**Flat namespace** (no nesting):

```kintsu
namespace api;

struct User { id: i64 };
```

Full path: `api::User`

**Nested namespace** (explicit hierarchy):

```kintsu
namespace company;

namespace api {
    struct User { id: i64 };
};
```

Full path: `company::api::User`

**Difference**: Flat namespaces have no parent; nested namespaces are children of enclosing namespaces.

### Spanned namespaces (block-scoped)

Spanned namespaces use brace syntax and are parsed as `SpannedNamespace` AST nodes:

```kintsu
namespace api {
    struct User { id: i64 };
    operation get_user(id: i64) -> User;
};
```

**Parsing:**

1. Parse `namespace` keyword
2. Parse namespace name
3. Parse opening brace `{`
4. Parse AST stream within braces
5. Parse closing brace `}`

> [!NOTE] > `SpannedNamespace` is the AST representation for block-scoped namespaces.

### Inner metadata (`#![...]`)

Inner metadata applies to all children within the namespace:

```kintsu
#![version(2)]
#![err(DefaultError)]
namespace api;

error DefaultError { Unknown };

operation process() -> i64!;  // Inherits version 2 and DefaultError
```

**Rules:**

- Inner metadata uses `#![...]` syntax
- Must appear at the top of the namespace (before any items)
- Applies to all child items (structs, enums, errors, operations, etc.)
- Children can override with item-level metadata

> [!IMPORTANT]
> Inner metadata sets defaults for all children. Item-level metadata overrides these defaults.

### Outer metadata (`#[...]`)

Outer metadata applies to the namespace definition itself:

```kintsu
#[version(1)]
namespace legacy;
```

**Rules:**

- Outer metadata uses `#[...]` syntax
- Must appear before the namespace declaration
- Applies to the namespace, not its children

> [!NOTE]
> Outer metadata is for the namespace entity itself, not its contents.

### Metadata inheritance and overrides

Children inherit namespace-level metadata unless overridden:

```kintsu
#![err(DefaultError)]
#![version(1)]
namespace api;

error DefaultError { Unknown };
error SpecificError { NotFound };

operation task1() -> str!;  // Uses DefaultError (inherited)

#[err(SpecificError)]
operation task2() -> i32!;  // Uses SpecificError (override)

#[version(2)]
struct NewFeature { ... };  // Uses version 2 (override)
```

**Precedence:**

1. Item-level metadata (highest precedence)
2. Namespace-level metadata (fallback)

### Child item uniqueness

Child item names must be unique within their namespace:

```kintsu
namespace api;

struct User { id: i64 };

// INVALID: duplicate name
struct User { name: str };  // ERROR: 'User' already defined
```

**Rules:**

- Struct, enum, error, oneOf, type alias, operation, and nested namespace names must be unique
- Different item kinds can have the same name (not recommended, but allowed)
- Uniqueness is enforced within the namespace scope only

> [!WARNING]
> Duplicate child names cause compilation errors.

### Type resolution stages

Namespaces are processed through multiple type resolution stages:

**Stage order:**

1. **Anonymous Struct Extraction** - Extract inline anonymous structs
2. **Union Identification** - Identify union type expressions
3. **Type Alias Resolution** - Resolve type alias chains
4. **Union Validation** - Validate union member types exist
5. **Union Resolution** - Merge union fields into structs
6. **Version Resolution** - Resolve version metadata
7. **Error Resolution** - Resolve operation error types
8. **Reference Validation** - Validate all type references

**Processing:**

- Stages run sequentially within each namespace
- All namespaces at the same depth level can be processed in parallel
- Each stage must complete before the next stage begins

> [!NOTE]
> Type resolution stages are deterministic. The order ensures dependencies are resolved before use.

### Namespace children

Namespaces contain child items:

- **struct** definitions
- **enum** definitions
- **error** definitions
- **oneof** definitions (if named)
- **type** aliases
- **operation** definitions
- **namespace** definitions (nested)

All children are registered in the namespace's children map.

## Implications

**For schema authors:**

- Use file-level syntax for single-namespace files
- Use block-scoped syntax for multiple namespaces in one file
- Nested namespaces create hierarchical organization
- Inner metadata sets defaults for all children
- Item-level metadata overrides namespace defaults

**For code generators:**

- Namespace paths use `::` separator (e.g., `company::api::User`)
- Nested namespaces have depth levels (root = 0)
- Type resolution follows deterministic stage order
- Child item names are unique within their namespace

**For type system implementers:**

- Support both file-level and block-scoped syntax
- Build nested namespace hierarchy with parent-child relationships
- Apply metadata inheritance with item-level override precedence
- Enforce child item uniqueness constraints
- Execute type resolution stages in order

## References

- [RFC-0010](../rfc/RFC-0010.md) - Namespace system design rationale
- [SPEC-0010](../spec/SPEC-0010.md) - Namespace compilation
- [TSY-0011](../tsy/TSY-0011.md) - Import system rules
- [RFC-0011](../rfc/RFC-0011.md) - Import system design
