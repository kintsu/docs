---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 6
status: draft
title: Type Alias Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0006: Type Alias Compilation

## Overview

This SPEC documents the compiler's deterministic behavior for parsing, validating, and resolving type aliases. It specifies the dependency extraction algorithm, DFS-based cycle detection, topological ordering using Kahn's algorithm, and resolution order enforcement. This SPEC is normative for implementers who must reproduce the compiler's alias resolution behavior.

## Motivation

Code generators and downstream tooling rely on consistent alias resolution. This SPEC records the precise algorithms for dependency extraction, cycle detection, and topological sorting so implementations produce identical outputs for the same source schemas. The ordering guarantees ensure aliases are resolved in dependency order, preventing undefined behavior.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

The following diagram illustrates the complete alias resolution pipeline from parsing through cycle detection, topological ordering, and resolution:

![Alias Resolution Flow](../../../../diagrams/alias_resolution_flow.png)

### Dependency extraction

For each type alias, the compiler extracts all type names referenced in the target type expression. These dependencies determine the resolution order.

**Extraction rules:**

- **Named types (`Type::Ident`):** Extract the identifier name if it's a simple identifier (not a path to external module)
- **Arrays (`Type::Array`):** Recursively extract dependencies from the element type
- **Unions (`Type::Union`):** Extract dependencies from all union operands (recursively for nested unions)
- **Oneofs (`Type::OneOf`):** Extract dependencies from all variant types
- **Parenthesized types (`Type::Paren`):** Recursively extract dependencies from the inner type
- **Anonymous structs (`Type::Struct`):** Extract dependencies from all field types
- **Builtins and result types:** No dependencies

**Example:**

```kintsu
type Complex = (oneof UserId | AdminId)[];
```

**Dependencies:** `[UserId, AdminId]`

> [!IMPORTANT]
> Only dependencies that are also type aliases affect the resolution order. References to structs, enums, or errors are validated but don't create ordering constraints.

### Circular dependency detection (DFS)

The compiler detects circular alias chains using depth-first search (DFS) with a recursion stack.

**Algorithm:**

1. Initialize empty `visited` set, `rec_stack` set, and `path` list
2. For each alias not yet visited:
   - Call `detect_cycles_dfs(alias, visited, rec_stack, path)`
3. In `detect_cycles_dfs(current)`:
   - Mark `current` as visited, add to `rec_stack` and `path`
   - For each dependency `dep` of `current`:
     - If `dep` is not an alias (e.g., a struct), skip it
     - If `dep` is not visited, recurse: `detect_cycles_dfs(dep)`
     - If `dep` is in `rec_stack`, a cycle is detected — report error with `path`
   - Remove `current` from `rec_stack` and `path` after processing
4. If no cycles found, return success

**Example cycle:**

```kintsu
type A = B;
type B = C;
type C = A;
```

**DFS traversal:** Visit `A` → visit `B` → visit `C` → detect `A` in `rec_stack` → report cycle `[A, B, C, A]`

> [!WARNING]
> The error message must include the full cycle path to aid debugging. Example: `circular type alias detected: A → B → C → A`

### Topological ordering (Kahn's algorithm)

The compiler resolves aliases in topological order using Kahn's algorithm. This ensures all dependencies are resolved before an alias is processed.

**Algorithm:**

1. Build adjacency list and in-degree map:
   - For each alias `A` with dependency `D` (where `D` is also an alias):
     - Add `A` to adjacency list of `D` (dependents)
     - Increment in-degree of `A`
2. Initialize queue with all aliases having in-degree 0 (no dependencies)
3. While queue is not empty:
   - Dequeue alias `current`
   - Add `current` to `sorted` list
   - For each dependent `D` of `current`:
     - Decrement in-degree of `D`
     - If in-degree reaches 0, enqueue `D`
4. If `sorted.len() != total_aliases`, a cycle exists (fallback error)

**Example:**

```kintsu
type A = i64;
type B = A;
type C = B;
type D = A;
```

**Dependency graph:** `B → A`, `C → B`, `D → A`

**In-degrees:** `A: 0`, `B: 1`, `C: 1`, `D: 1`

**Topological order:** `[A, B, D, C]` or `[A, D, B, C]` (both valid)

> [!NOTE]
> Multiple valid orderings may exist. Any topologically valid order is acceptable as long as dependencies are resolved before dependents.

### Resolution order enforcement

Aliases are resolved in the topological order determined by Kahn's algorithm. For each alias in order:

1. Retrieve the alias entry (target type and dependencies)
2. Resolve the target type:
   - If the target references other aliases, they are already resolved (guaranteed by topological order)
   - Replace alias references with their resolved concrete types
3. Store the resolved type in the namespace resolution map

**Example:**

```kintsu
type A = i64;
type B = A;
type C = B;
```

**Resolution steps:**

1. Resolve `A`: target is `i64` (concrete) → store `A → i64`
2. Resolve `B`: target is `A` → lookup `A` → resolve to `i64` → store `B → i64`
3. Resolve `C`: target is `B` → lookup `B` → resolve to `i64` → store `C → i64`

> [!IMPORTANT]
> Resolution is idempotent. Resolving an alias multiple times produces the same result.

### Union and anonymous struct alias handling

Union and anonymous struct aliases receive special treatment during resolution:

**Union aliases:**

1. Detect that the target type is a union (`Type::Union`)
2. Trigger union resolution (Phase 4) to merge fields and generate a struct
3. Use the alias name as the generated struct name
4. Replace the alias with a reference to the generated struct

**Anonymous struct aliases:**

1. Detect that the target type is an anonymous struct (`Type::Struct`)
2. Trigger anonymous struct extraction (Phase 1)
3. Use the alias name as the generated struct name (instead of context-based naming)
4. Replace the alias with a reference to the generated struct

> [!NOTE]
> This special handling simplifies name generation and ensures alias names map 1:1 to struct names.

### Target type validation

During resolution, all type references in the target type expression are validated:

- Named types must exist in the type registry
- Array element types must be valid
- Union operands must be valid
- Oneof variants must be valid

If validation fails, the compiler reports an error with the alias name and missing type.

**Example:**

```kintsu
type Invalid = UnknownType;
```

**Error:** `type 'UnknownType' not found, referenced by alias 'Invalid'`

## Acceptance Criteria

- **AC-1:** Dependency extraction correctly identifies all type names referenced in alias targets
- **AC-2:** DFS cycle detection identifies circular alias chains and reports the full cycle path
- **AC-3:** Topological ordering using Kahn's algorithm produces a valid resolution order
- **AC-4:** Aliases are resolved in topological order with all dependencies resolved first
- **AC-5:** Union aliases generate structs using the alias name
- **AC-6:** Anonymous struct aliases generate structs using the alias name
- **AC-7:** Target type validation reports missing types with the alias context

## Design Principles

- **Dependency-driven ordering:** Use topological sort to enforce dependency resolution order
- **Early cycle detection:** Detect cycles before resolution to provide clear error messages
- **Deterministic resolution:** Same schema produces same resolution order and concrete types
- **Special struct handling:** Union and anonymous struct aliases map 1:1 to struct names

## Implications

**For implementers:**

- DFS and Kahn's algorithm are normative — implementations must use equivalent algorithms
- Cycle detection must report full cycle paths
- Topological ordering guarantees are critical for correctness

**For code generators:**

- Resolved aliases are always concrete types (no alias references remain)
- Union and anonymous struct aliases produce predictable struct names
- Validation errors include alias context for debugging

## References

- [RFC-0006](../rfc/RFC-0006.md) - Type alias design rationale
- [TSY-0006](../tsy/TSY-0006.md) - Type alias type-system rules
- [SPEC-0001](../spec/SPEC-0001.md) - Builtin types
- [SPEC-0002](../spec/SPEC-0002.md) - Struct compilation
- [SPEC-0003](../spec/SPEC-0003.md) - Anonymous struct compilation
- [SPEC-0007](../spec/SPEC-0007.md) - Union type compilation
