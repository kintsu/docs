---
author: joshua-auchincloss
components:
  - compiler
created: 2025-10-30
kind: SPEC
number: 13
status: draft
title: Type Resolution Phases
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0013: Type Resolution Phases

## Overview

This specification defines the deterministic implementation rules for all eight phases of type resolution in Kintsu compilers. Each phase has specific inputs, processing algorithms, outputs, and error conditions. The specification ensures all compiler implementations resolve types identically by prescribing exact algorithms for each phase.

## Motivation

Compilers must implement type resolution consistently to ensure:

- **Predictable behavior**: Same schema produces same resolved types across implementations
- **Clear algorithms**: Each phase has well-defined processing steps
- **Deterministic ordering**: Phase execution order and intra-phase processing order are specified
- **Complete validation**: All validation rules are explicit

This specification provides the normative implementation guide for type resolution.

## Architecture

The eight phases execute sequentially via `TypeResolver::resolve()`:

**Implementation** (from `parser/src/ctx/resolve/mod.rs`):

```rust
pub async fn resolve(mut self) -> crate::Result<NamespaceResolution> {
    self.anonymous_structs().await?;           // Phase 1
    self.identify_unions().await?;             // Phase 2
    self.resolve_type_aliases().await?;        // Phase 3
    self.validate_unions().await?;             // Phase 4
    self.merge_unions().await?;                // Phase 5
    self.resolve_versions().await?;            // Phase 6
    self.resolve_error_types().await?;         // Phase 7
    self.validate_all_references().await?;     // Phase 8
    Ok(self.resolution)
}
```

Each phase is implemented as a private method that mutates `self.resolution`.

![Type Resolution Architecture](../../../../diagrams/type_resolution_architecture.png)

![Phase Flows Detailed](../../../../diagrams/phase_flows_detailed.png)

## Design Principles

1. **Deterministic ordering**: All iterations use ordered collections (BTreeMap, Vec with stable ordering)
2. **Single responsibility**: Each phase handles one concern
3. **Fail-fast**: Validation phases return errors immediately
4. **Immutable inputs**: Phases read namespace context, don't modify it
5. **Output accumulation**: Results stored in `NamespaceResolution` for downstream phases

## Deterministic resolution rules (normative)

### Phase 1: Anonymous Struct Extraction

**Inputs**:

- `NamespaceCtx` with raw parsed types

**Algorithm**:

1. Create `NameContext` for name generation
2. Iterate namespace children in order
3. For each child, traverse type AST depth-first post-order
4. Identify anonymous struct patterns (`Type::Struct` with inline fields)
5. Generate PascalCase name from context stack (e.g., `UserAddress` from `User.address`)
6. Extract anonymous struct as `StructDef`
7. Replace anonymous reference with `Type::Ident` referencing generated name
8. Collect all generated `StructDef` instances

**Output**:

- `Vec<SourceSpanned<StructDef>>` stored in `resolution.anonymous_structs`

**Implementation** (from `parser/src/ctx/resolve/anonymous.rs`):

Traverses types recursively, maintaining context stack for naming. Uses depth-first post-order to handle nested anonymous structs (innermost first).

**Example**:

```kintsu
// Input
struct User {
    address: {
        street: string,
        city: string,
    },
}

// Phase 1 output
anonymous_structs = [
    StructDef {
        name: "UserAddress",
        fields: [
            Field { name: "street", typ: string },
            Field { name: "city", typ: string },
        ]
    }
]

// Type replaced
struct User {
    address: UserAddress,  // Reference to generated type
}
```

### Phase 2: Union Identification

**Inputs**:

- Types with anonymous structs resolved

**Algorithm**:

1. Create `NameContext` for union naming
2. Iterate namespace children in order
3. For each child, scan all type positions
4. Identify `Type::Union` expressions
5. Generate union name based on context (field name, alias name, etc.)
6. Create `UnionRecord` with:
   - Generated name
   - Union type expression
   - Context (where union appears)
   - Member type references
7. Collect all `UnionRecord` instances

**Output**:

- `Vec<Spanned<UnionRecord>>` stored in `resolution.identified_unions`

**Implementation** (from `parser/src/ctx/resolve/unions.rs`):

Scans type positions: struct fields, operation parameters/returns, type alias targets, oneof variants. Records union location and member types for later validation.

**Example**:

```kintsu
// Input
struct User {
    contact: Email | Phone,
}

// Phase 2 output
identified_unions = [
    UnionRecord {
        name: "UserContact",
        members: ["Email", "Phone"],
        context: Field("contact"),
    }
]
```

### Phase 3: Type Alias Resolution

**Inputs**:

- Types with unions identified

**Algorithm**:

1. Build alias dependency graph
   - Extract all type aliases
   - For each alias, extract referenced type names
   - Create edges: alias → dependencies
2. Detect circular references using DFS
3. Topologically sort aliases by dependencies
4. Resolve aliases in topological order:
   - Follow alias chains to terminal types
   - Resolve nested aliases recursively
   - Cache resolved types
5. Store resolved types in map

**Output**:

- `BTreeMap<String, Spanned<Type>>` stored in `resolution.resolved_aliases`

**Implementation** (from `parser/src/ctx/resolve/aliases.rs`):

```rust
pub(super) async fn resolve_type_aliases(&mut self) -> crate::Result<()> {
    // Build dependency graph
    let mut graph = AliasGraph::new();

    // Add all aliases to graph
    for (name, child) in &ns.children {
        if let NamespaceChild::Type(type_alias) = &child.value {
            graph.add_alias(name, type_alias.target_type);
        }
    }

    // Detect cycles
    if let Some(cycle) = graph.detect_cycles() {
        return Err(Error::CircularAlias(cycle));
    }

    // Topological sort
    let sorted = graph.topological_sort();

    // Resolve in order
    for alias_name in sorted {
        let resolved = resolve_alias_chain(alias_name, &graph)?;
        self.resolution.resolved_aliases.insert(alias_name, resolved);
    }

    Ok(())
}
```

**Example**:

```kintsu
// Input
type A = string;
type B = A;
type C = B;

// Phase 3 output
resolved_aliases = {
    "A": string,
    "B": string,  // Resolved through A
    "C": string,  // Resolved through B → A
}
```

### Phase 4: Union Validation

**Inputs**:

- Unions identified (Phase 2)
- Aliases resolved (Phase 3)

**Algorithm**:

1. For each union in `identified_unions`:
2. Resolve each member type:
   - If member is alias, follow to resolved type
   - If member is path, validate in registry
3. Verify all members are struct types:
   - Check resolved type is `Type::Ident` referencing struct
   - Reject primitive types, arrays, other unions
4. Collect validation errors
5. Return aggregated errors or success

**Output**:

- Validation result (no artifacts, only pass/fail)

**Implementation** (from `parser/src/ctx/resolve/unions.rs`):

```rust
pub(super) async fn validate_unions(&mut self) -> crate::Result<()> {
    for union_record in &self.resolution.identified_unions {
        validate_union_record(&union_record.value, &ns, &self.resolution.resolved_aliases).await?;
    }
    Ok(())
}

async fn validate_union_record(
    record: &UnionRecord,
    ns: &NamespaceCtx,
    resolved_aliases: &BTreeMap<String, Type>,
) -> Result<()> {
    for member in &record.members {
        // Resolve member type (follow aliases)
        let resolved_type = resolve_member_type(member, resolved_aliases)?;

        // Verify it's a struct
        if !is_struct_type(&resolved_type, ns).await {
            return Err(Error::UnionMemberNotStruct {
                union_name: record.name.clone(),
                member: member.clone(),
            });
        }
    }
    Ok(())
}
```

**Error example**:

```kintsu
// Invalid
type Value = string | i32;  // Error: union members must be structs

Error: union members must be struct types
  --> schema.ks:1:14
   |
 1 | type Value = string | i32;
   |              ^^^^^^ primitive type not allowed in union
```

### Phase 5: Union Merging

**Inputs**:

- Validated unions (Phase 4 passed)

**Algorithm**:

1. For each union in `identified_unions`:
2. Collect all member struct definitions
3. Extract fields from each member struct
4. Merge fields left-to-right:
   - First occurrence of field name wins
   - Preserve field order from first struct
   - Add unique fields from subsequent structs
5. Generate new `StructDef` with merged fields
6. Name struct using union's generated name
7. Store generated struct

**Output**:

- `Vec<SourceSpanned<StructDef>>` stored in `resolution.union_structs`

**Implementation** (from `parser/src/ctx/resolve/unions.rs`):

```rust
pub(super) async fn merge_unions(&mut self) -> crate::Result<()> {
    for union_record in &self.resolution.identified_unions {
        let merged_struct = merge_union(&union_record.value, &ns).await?;
        self.resolution.union_structs.push(merged_struct);
    }
    Ok(())
}

async fn merge_union(record: &UnionRecord, ns: &NamespaceCtx) -> Result<StructDef> {
    let mut merged_fields = Vec::new();
    let mut seen_fields = HashSet::new();

    for member in &record.members {
        let struct_def = ns.registry.lookup_struct(member)?;

        for field in &struct_def.fields {
            if seen_fields.insert(field.name.clone()) {
                merged_fields.push(field.clone());  // First occurrence wins
            }
        }
    }

    Ok(StructDef {
        name: record.name.clone(),
        fields: merged_fields,
    })
}
```

**Example**:

```kintsu
// Input
struct A { id: i64, name: string }
struct B { id: i64, email: string }
type AB = A | B;

// Phase 5 output
union_structs = [
    StructDef {
        name: "AB",
        fields: [
            Field { name: "id", typ: i64 },      // From A (first)
            Field { name: "name", typ: string }, // From A
            Field { name: "email", typ: string }, // From B
        ]
    }
]
```

### Phase 6: Version Metadata Resolution

**Inputs**:

- All types registered (including generated from Phases 1, 5)

**Algorithm**:

1. Extract namespace-level version: `#![version(n)]` from namespace metadata
2. For each type in namespace children:
3. Extract item-level version: `#[version(n)]` from type metadata
4. Resolve effective version:
   - If item-level version exists, use it (highest priority)
   - Else if namespace-level version exists, use it
   - Else use default version 1
5. Store resolved version for type

**Output**:

- `BTreeMap<String, Spanned<u32>>` stored in `resolution.versions`

**Implementation** (from `parser/src/ctx/resolve/metadata.rs`):

```rust
pub(super) async fn resolve_versions(&mut self) -> crate::Result<()> {
    let ns = self.namespace.lock().await;

    let namespace_version = ns.version.as_ref().map(|v| v.version_spanned());

    for (item_ctx, child) in &ns.children {
        let item_name = item_ctx.name.borrow_string().clone();

        let item_version = extract_version_from_meta(&child);

        let resolved_version = item_version
            .or_else(|| namespace_version.clone())
            .unwrap_or_else(|| Spanned::call_site(1));  // Default

        self.resolution.versions.insert(item_name, resolved_version);
    }

    Ok(())
}
```

**Example**:

```kintsu
namespace api {
    #![version(1)]

    struct User { ... }       // Resolves to version 1

    #[version(2)]
    struct Account { ... }    // Resolves to version 2
}

// Phase 6 output
versions = {
    "User": 1,
    "Account": 2,
}
```

### Phase 7: Error Metadata Resolution

**Inputs**:

- All operations with metadata

**Algorithm**:

1. Extract namespace-level error: `#![err(ErrorType)]` from namespace metadata
2. For each operation in namespace children:
3. Check if operation is fallible (return type has `!` suffix)
4. If not fallible, skip (no error needed)
5. Extract operation-level error: `#[err(ErrorType)]` from operation metadata
6. Resolve effective error:
   - If operation-level error exists, use it (highest priority)
   - Else if namespace-level error exists, use it
   - Else error: fallible operation missing error type
7. Store resolved error for operation

**Output**:

- `BTreeMap<String, Spanned<String>>` stored in `resolution.errors`

**Implementation** (from `parser/src/ctx/resolve/metadata.rs`):

```rust
pub(super) async fn resolve_error_types(&mut self) -> crate::Result<()> {
    let ns = self.namespace.lock().await;

    let namespace_error = ns.error.as_ref().map(|e| e.error_name_string());

    for (item_ctx, child) in &ns.children {
        if let NamespaceChild::Operation(op_def) = &child.value {
            let item_name = item_ctx.name.borrow_string().clone();

            let is_fallible = is_fallible_operation(&op_def.return_type);

            if !is_fallible {
                continue;  // Non-fallible, no error needed
            }

            let operation_error = extract_error_from_meta(&op_def.meta);

            let resolved_error = match operation_error {
                Some(err) => err,
                None => {
                    match namespace_error.clone() {
                        Some(err) => err,
                        None => {
                            return Err(Error::MissingErrorType {
                                operation: item_name,
                            });
                        }
                    }
                }
            };

            self.resolution.errors.insert(item_name, resolved_error);
        }
    }

    Ok(())
}
```

**Example**:

```kintsu
namespace api {
    #![err(ApiError)]

    operation getUser() -> User!;     // Resolves to ApiError

    #[err(ValidationError)]
    operation createUser() -> User!;  // Resolves to ValidationError
}

// Phase 7 output
errors = {
    "getUser": "ApiError",
    "createUser": "ValidationError",
}
```

### Phase 8: Type Reference Validation

**Inputs**:

- All types fully resolved and registered

**Algorithm**:

1. Iterate all namespace children
2. For each type definition (struct, enum, oneof, error, operation):
3. Extract all type references from fields/parameters/returns
4. For each type reference:
   - Check if type exists in registry
   - Validate cross-namespace references
   - Validate cross-schema references
5. Collect validation errors with source spans
6. Return aggregated errors or success

**Output**:

- Validation result (no artifacts, only pass/fail)

**Implementation** (from `parser/src/ctx/resolve/validation.rs`):

```rust
pub(super) async fn validate_all_references(&mut self) -> crate::Result<()> {
    let ns = self.namespace.lock().await;

    for child in ns.children.values() {
        match &child.value {
            NamespaceChild::Struct(struct_item) => {
                for field in &struct_item.fields {
                    validate_type_reference(&field.typ, &ns)?;
                }
            },
            NamespaceChild::Operation(op_item) => {
                if let Some(params) = &op_item.params {
                    for param in params {
                        validate_type_reference(&param.typ, &ns)?;
                    }
                }
                validate_type_reference(&op_item.return_type, &ns)?;
            },
            // ... other cases
        }
    }

    Ok(())
}

fn validate_type_reference(ty: &Type, ns: &NamespaceCtx) -> Result<()> {
    match ty {
        Type::Ident { to } => {
            if !ns.registry.is_valid(&ns.ctx, to, ns) {
                return Err(Error::UndefinedType {
                    name: to.to_string()
                });
            }
        },
        Type::Array { ty } => {
            validate_type_reference(&ty.element, ns)?;
        },
        // ... other type forms
    }
    Ok(())
}
```

**Error example**:

```kintsu
struct Post {
    author: User,  // Error if User not defined
}

Error: undefined type 'User'
  --> schema.ks:2:13
   |
 2 |     author: User,
   |             ^^^^ type not found
```

## Acceptance Criteria

- [ ] Phase 1 extracts all anonymous structs depth-first post-order
- [ ] Phase 2 identifies all unions in type positions
- [ ] Phase 3 resolves aliases topologically, detects circular aliases
- [ ] Phase 4 validates union members are structs
- [ ] Phase 5 merges union members left-to-right
- [ ] Phase 6 resolves versions with item > namespace > default precedence
- [ ] Phase 7 resolves errors with operation > namespace precedence
- [ ] Phase 8 validates all type references exist
- [ ] All phases use deterministic ordering (BTreeMap, stable Vec iteration)
- [ ] Validation phases (4, 8) return errors with source spans

## Implications

### For Compiler Implementers

Must implement all eight phases exactly as specified with deterministic ordering. Cannot reorder phases or merge phases without breaking correctness.

### For Schema Authors

Understanding phase order helps debug resolution issues. Knowing that aliases resolve before union validation explains certain error messages.

### For Testing

Each phase can be tested independently by constructing appropriate inputs and verifying outputs match specification.

## References

- [RFC-0013](../rfc/RFC-0013.md) - Type Resolution Design
- [AD-0001](../ad/AD-0001.md) - Type Resolution Architecture
- [RFC-0003](../rfc/RFC-0003.md) - Anonymous Structs (Phase 1)
- [RFC-0007](../rfc/RFC-0007.md) - Union Types (Phases 2, 4, 5)
- [RFC-0006](../rfc/RFC-0006.md) - Type Aliases (Phase 3)
- [RFC-0012](../rfc/RFC-0012.md) - Metadata System (Phases 6, 7)
