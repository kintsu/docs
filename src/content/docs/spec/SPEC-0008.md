---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 8
status: draft
title: OneOf Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0008: OneOf Compilation

## Overview

This SPEC documents the compiler's deterministic behavior for parsing, validating, and registering oneOf types. It specifies oneOf registration, variant validation (type existence checks), anonymous struct variant extraction (sequential numbering algorithm), union variant identification and resolution, variant ordering preservation, and discriminant assignment semantics. This SPEC is normative for implementers who must reproduce the compiler's oneOf handling behavior.

![OneOf Discriminated Union Structure](../../../../diagrams/oneof_structure.png)

## Motivation

Code generators and downstream tooling rely on consistent oneOf variant ordering and naming. This SPEC records the precise algorithms for variant processing, anonymous struct extraction, and union resolution so implementations produce identical outputs for the same source schemas. The sequential numbering for anonymous variants and variant ordering preservation are critical for binary serialization compatibility.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

### OneOf registration

The compiler registers oneOf definitions during parsing. For each oneOf:

1. Parse `oneof` keyword
2. Parse first variant type
3. Parse pipe separator `|` and subsequent variant types
4. Construct `AnonymousOneOf` or `OneOfDef` with variant list
5. Register in namespace if it's a named oneOf definition

**For named oneOf (via type alias or dedicated syntax):**

```kintsu
type Response = oneof Success | Error;
```

**For anonymous oneOf (inline in type positions):**

```kintsu
struct Record {
    data: oneof i32 | f32 | str  // Anonymous oneOf in field type
};
```

> [!IMPORTANT]
> OneOf definitions are registered during parsing, but variant validation and extraction occur in later resolution phases.

### Variant validation (type existence)

Before finalizing oneOf types, the compiler validates that all variant types resolve to valid types.

**Validation algorithm:**

1. For each variant in the oneOf:
   - If variant is a named type (identifier), look up in type registry
     - If resolved alias, recursively validate resolved type
     - If namespace child (struct/enum/error/oneOf), valid ✓
     - If not found, error - "undefined type"
   - If variant is a builtin type, valid ✓
   - If variant is an anonymous struct, valid (extracted in Phase 1) ✓
   - If variant is a union, valid (resolved in Phase 4) ✓
   - If variant is a parenthesized type, recursively validate inner type
   - If variant is an array, recursively validate element type
2. If all variants are valid, oneOf is valid
3. If any variant is invalid, oneOf validation fails

**Example validation:**

```kintsu
type Invalid = oneof Foo | UnknownType;
```

**Error:** `type 'UnknownType' not found in oneOf variant list`

> [!WARNING]
> Validation must occur after all type definitions are parsed but before code generation. Missing types cause compilation failure.

### Anonymous struct variant extraction (sequential numbering)

Anonymous struct definitions in oneOf variants are extracted during Phase 1 (anonymous struct extraction) and assigned generated names using the parent oneOf name + sequential index.

**Naming algorithm:**

1. Determine parent context name:
   - If oneOf is in type alias, use alias name
   - If oneOf is in struct field, use struct name + field name
   - If oneOf is in oneof variant, use parent name + variant index
2. For each anonymous struct variant in order:
   - Generate name: `{ParentName}{Index}` where Index = 1, 2, 3, ...
   - Extract anonymous struct to named struct
   - Register generated struct in namespace
   - Replace variant with reference to generated struct

**Example:**

```kintsu
type Response = oneof {
    success: bool,
    data: str
} | {
    error: str,
    code: i32
} | str;
```

**Extraction steps:**

1. First variant (anonymous struct) → generate `Response1`
2. Second variant (anonymous struct) → generate `Response2`
3. Third variant (str) → no extraction needed

**After extraction:**

```kintsu
struct Response1 { success: bool, data: str };
struct Response2 { error: str, code: i32 };
type Response = oneof Response1 | Response2 | str;
```

> [!IMPORTANT]
> Numbering starts at 1 and increments sequentially based on variant position. Only anonymous struct variants are numbered; named types retain their names.

### Union variant identification and resolution

When a oneOf variant is a union expression, the compiler identifies and resolves it during Phase 4 (union resolution).

**Algorithm:**

1. During union identification (SPEC-0007), scan oneOf variant types
2. For each union variant:
   - Record union with context (parent oneOf name + variant index)
   - Generate union struct name: `{ParentName}{Index}`
3. During union resolution:
   - Merge union fields into generated struct
   - Register generated struct
   - Replace union variant with reference to generated struct

**Example:**

```kintsu
struct Base { x: i32 };
struct Extension { y: str };
type Data = oneof (Base & Extension) | str;
```

**Resolution steps:**

1. Identify union `(Base & Extension)` in variant 0
2. Context: Data, variant index 0 → generate name `Data1`
3. Resolve union: merge Base and Extension → `Data1 { x: i32, y: str }`
4. Replace variant: `oneof Data1 | str`

> [!NOTE]
> Union variants follow the same sequential numbering as anonymous struct variants, ensuring consistent naming across variant types.

### Variant ordering preservation

The compiler preserves variant order as declared in the source schema. This order determines:

- Discriminant values in generated code
- Variant indices for error messages
- Binary serialization discriminant encoding

**Algorithm:**

1. During parsing, store variants in a list preserving declaration order
2. During validation and extraction, process variants in order
3. During code generation, emit variants in the same order

**Example:**

```kintsu
type Status = oneof Active | Pending | Completed;
```

**Variant indices:** Active=0, Pending=1, Completed=2

> [!IMPORTANT]
> Variant order is part of the type's identity. Reordering variants changes discriminant values and breaks binary compatibility.

### Discriminant assignment semantics

While the source schema doesn't specify explicit discriminant values, the compiler assigns them based on variant order:

**Assignment:**

- First variant: discriminant 0
- Second variant: discriminant 1
- Third variant: discriminant 2
- ...and so on

**Example:**

```kintsu
type Response = oneof Success | Error | Timeout;
```

**Discriminants:** Success=0, Error=1, Timeout=2

> [!NOTE]
> Discriminant values are implicit and derived from variant order. Code generators use this mapping to implement discrimination in the target language.

### Variant count validation

The compiler enforces that oneOf types have at least two variants:

**Validation:**

1. After parsing all variants, check variant count
2. If count < 2, error - "oneOf requires at least 2 variants"
3. If count >= 2, valid ✓

**Example (invalid):**

```kintsu
type Invalid = oneof Foo;
```

**Error:** `oneOf requires at least 2 variants, found 1`

> [!WARNING]
> Single-variant oneOf types are meaningless for discrimination and are rejected during compilation.

## Acceptance Criteria

- **AC-1:** OneOf definitions are registered during parsing with variant list preserved
- **AC-2:** Variant validation checks that all variant types exist in type registry
- **AC-3:** Anonymous struct variants are extracted with sequential numbering (Name1, Name2, ...)
- **AC-4:** Union variants are identified and resolved with sequential numbering
- **AC-5:** Variant order is preserved from source to code generation
- **AC-6:** Discriminant values are assigned based on variant order (0-indexed)
- **AC-7:** OneOf types with fewer than 2 variants are rejected

## Design Principles

- **Preserve order:** Variant declaration order determines discriminant values
- **Sequential naming:** Anonymous variants use predictable numbering (1, 2, 3...)
- **Validate before generation:** All variant types must resolve before code generation
- **Consistent extraction:** Anonymous structs and unions follow the same numbering scheme
- **Minimum variants:** Enforce meaningful discrimination with at least 2 variants

## Implications

**For implementers:**

- Variant order must be preserved exactly as declared
- Sequential numbering for anonymous variants is deterministic
- Union variant resolution follows SPEC-0007 rules
- Discriminant values are derived, not explicit in source

**For code generators:**

- Variant names and discriminants are stable and predictable
- Anonymous struct variants have generated names (Name1, Name2, ...)
- Union variants are pre-resolved to struct types
- Discriminant mapping is 0-indexed based on variant order

**For tooling:**

- Variant order changes are breaking (affect discriminant values)
- Anonymous variant names can be predicted from context
- Type validation ensures all variants are well-formed

## References

- [RFC-0008](../rfc/RFC-0008.md) - OneOf type design rationale
- [TSY-0008](../tsy/TSY-0008.md) - OneOf type type-system rules
- [SPEC-0003](../spec/SPEC-0003.md) - Anonymous struct compilation (for variant extraction)
- [SPEC-0007](../spec/SPEC-0007.md) - Union type compilation (for union variant resolution)
- [SPEC-0002](../spec/SPEC-0002.md) - Struct compilation
