---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 10
status: draft
title: Namespace Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0010: Namespace Compilation

## Overview

This SPEC documents the compiler's deterministic behavior for loading, organizing, and compiling namespace definitions. It specifies the namespace loading process (file discovery and parallel reading), file resolution behavior (merging multiple files into same namespace), dependency graph construction (import-based relationships), compilation order (breadth-first by depth with parallelism), and the eight type resolution stages executed for each namespace. This SPEC is normative for implementers who must reproduce the compiler's namespace handling behavior.

![Namespace Compilation Flow](../../../../diagrams/namespace_compilation_flow.png)

## Motivation

Parallel compilation and deterministic ordering are critical for performance and reproducibility. This SPEC records the precise algorithms for discovering namespace files, building dependency graphs, ordering compilation, and executing type resolution stages so implementations produce identical outputs and leverage parallelism effectively.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

### Namespace file discovery

The compiler discovers namespace files during schema loading:

**Discovery algorithm:**

1. Scan workspace directory tree
2. Identify files with `.ks` extension
3. For each file:
   - Parse file header to extract namespace declaration
   - Group files by namespace name
4. Build namespace → file list mapping

**Example:**

```text
workspace/
  api/
    user.ks      # namespace api;
    product.ks   # namespace api;
  common/
    types.ks     # namespace common;
```

**Result:** `api` → `[user.ks, product.ks]`, `common` → `[types.ks]`

> [!IMPORTANT]
> Multiple files can contribute to the same namespace. Files are grouped by namespace declaration.

### Parallel file reading

Files within a namespace are read in parallel for performance:

**Reading algorithm:**

1. For namespace with file list `[f1, f2, f3, ...]`:
   - Create parallel read tasks for each file
   - Use async I/O to read file contents concurrently
2. Collect results: `[(f1, content1), (f2, content2), ...]`
3. Process results sequentially to maintain deterministic order

**Rust implementation reference:**

```rust
use futures_util::future::join_all;

let read_futures: Vec<_> = paths
    .iter()
    .map(|path| async move {
        let source = fs.read_to_string(path).await?;
        Ok::<(PathBuf, String), Error>((path.clone(), source))
    })
    .collect();

let file_contents = join_all(read_futures).await;
```

> [!NOTE]
> Parallel reading improves I/O performance. Sequential processing ensures deterministic ordering.

### Multi-file namespace merging

When multiple files declare the same namespace, the compiler merges their definitions:

**Merging algorithm:**

1. For namespace with files `[f1, f2, f3]`:
   - Parse f1 → extract namespace declaration and children
   - Register namespace from f1
2. For each subsequent file (f2, f3):
   - Parse file → extract children
   - Validate namespace declaration matches registered namespace
   - Merge children into namespace's children map
   - Detect duplicate child names → error if found

**Example:**

```kintsu
# api/user.ks
namespace api;

struct User { id: i64 };
```

```kintsu
# api/product.ks
namespace api;

struct Product { id: i64 };
```

**Result:** `api` namespace contains `User` and `Product` children.

> [!WARNING]
> Duplicate child names across files cause compilation errors. Child names must be unique within the namespace.

### Dependency graph construction

The compiler builds a dependency graph based on `use` statements:

**Graph construction:**

1. For each namespace:
   - Parse `use` statements
   - Extract imported namespace paths
   - Add edge: current namespace → imported namespace
2. Build directed graph: nodes = namespaces, edges = import dependencies

**Example:**

```kintsu
namespace api;

use common::types::User;
```

**Edge:** `api` → `common` (api depends on common)

> [!NOTE]
> Dependency graph determines compilation order. Dependencies must be compiled before dependents.

### Circular dependency detection

The compiler detects circular dependencies during graph construction:

**Detection algorithm:**

1. Perform depth-first search on dependency graph
2. Track visited nodes and recursion stack
3. If node already in recursion stack, cycle detected

**Example (invalid):**

```kintsu
# api.ks
namespace api;
use common::types::User;
```

```kintsu
# common.ks
namespace common;
use api::Request;  // ERROR: circular dependency
```

**Error:** `Circular dependency detected: api → common → api`

> [!WARNING]
> Circular namespace dependencies are compilation errors. Schemas must be acyclic.

### Compilation order (breadth-first by depth)

Namespaces are compiled in breadth-first order by depth level:

**Ordering algorithm:**

1. Assign depth to each namespace:
   - Root namespaces (no parent): depth 0
   - Child namespaces: parent depth + 1
2. Group namespaces by depth: `{0: [ns1, ns2], 1: [ns3, ns4], ...}`
3. Compile in order:
   - Depth 0 namespaces first
   - Then depth 1, depth 2, ...
4. Within each depth level, compile namespaces in parallel

**Example:**

```text
company (depth 0)
  api (depth 1)
    v1 (depth 2)
    v2 (depth 2)
  common (depth 1)
```

**Compilation order:**

1. `company` (depth 0)
2. `api`, `common` (depth 1, parallel)
3. `v1`, `v2` (depth 2, parallel)

> [!IMPORTANT]
> Breadth-first ensures parents are compiled before children. Parallelism within each depth maximizes throughput.

### Type resolution stages (sequential)

Each namespace is processed through eight type resolution stages:

#### Stage 1: Anonymous Struct Extraction

- Extract inline anonymous structs
- Generate names for anonymous structs (per SPEC-0003)
- Register extracted structs in namespace

#### Stage 2: Union Identification

- Identify union type expressions (`T1 & T2 & ...`)
- Record union contexts and names (per SPEC-0007)

#### Stage 3: Type Alias Resolution

- Resolve type alias chains
- Detect circular aliases
- Validate resolved types exist (per SPEC-0006)

#### Stage 4: Union Validation

- Validate union member types exist
- Check for field name conflicts (per SPEC-0007)

#### Stage 5: Union Resolution

- Merge union fields into structs
- Generate union structs
- Register in namespace (per SPEC-0007)

#### Stage 6: Version Resolution

- Extract version metadata from items
- Resolve version numbers
- Store in `resolved_versions` map

#### Stage 7: Error Resolution

- Identify fallible operations
- Resolve error types (operation-level vs namespace-level)
- Store in `resolved_errors` map (per SPEC-0009)

#### Stage 8: Reference Validation

- Validate all type references resolve
- Check struct fields, operation parameters, return types
- Ensure no dangling references

> [!NOTE]
> Stages run sequentially within each namespace. All namespaces at the same depth can execute stages in parallel.

### Parallelism within depth levels

Namespaces at the same depth level are independent and can be compiled in parallel:

**Parallelization:**

1. For depth level N:
   - Collect all namespaces at depth N
2. Create parallel compilation tasks for each namespace
3. Execute type resolution stages for all namespaces concurrently
4. Wait for all tasks to complete before proceeding to depth N+1

**Example:**

```text
Depth 1: api, common (compile in parallel)
  - api: Execute stages 1-8
  - common: Execute stages 1-8
  - Wait for both to complete
Depth 2: api::v1, api::v2 (compile in parallel)
```

> [!IMPORTANT]
> Parallelism is safe within depth levels because namespaces at the same depth have no parent-child dependencies.

### Namespace context initialization

Each namespace is initialized with a `NamespaceCtx`:

**Initialization:**

1. Create `NamespaceCtx` with:
   - `ctx`: RefContext (namespace path)
   - `sources`: Source file map
   - `comments`: Comment stream
   - `error`: Namespace-level error metadata
   - `version`: Namespace-level version metadata
   - `namespace`: NamespaceDef AST
   - `imports`: Import list
   - `children`: Children map (empty initially)
   - `registry`: Global type registry (shared)
   - `resolved_versions`: Empty map (populated in Stage 6)
   - `resolved_errors`: Empty map (populated in Stage 7)

> [!NOTE]
> The type registry is shared across all namespaces for global type lookups.

## Acceptance Criteria

- **AC-1:** Namespace files are discovered by scanning workspace directory
- **AC-2:** Files within a namespace are read in parallel for performance
- **AC-3:** Multiple files declaring the same namespace are merged into one namespace
- **AC-4:** Dependency graph is constructed based on `use` statements
- **AC-5:** Circular dependencies are detected and cause compilation errors
- **AC-6:** Namespaces are compiled in breadth-first order by depth level
- **AC-7:** Namespaces at the same depth level are compiled in parallel
- **AC-8:** Type resolution executes eight stages sequentially within each namespace
- **AC-9:** Each namespace has a NamespaceCtx with shared type registry

## Design Principles

- **Parallel I/O**: Read namespace files concurrently for performance
- **Deterministic ordering**: Process files in consistent order for reproducibility
- **Breadth-first compilation**: Ensure parents compiled before children
- **Parallelism at depth**: Compile independent namespaces simultaneously
- **Sequential stages**: Execute type resolution stages in order
- **Shared registry**: Use global type registry for cross-namespace lookups

## Implications

**For implementers:**

- File discovery requires directory tree scanning
- Parallel file reading uses async I/O primitives
- Multi-file namespace merging must detect duplicate names
- Dependency graph construction requires parsing `use` statements
- Breadth-first ordering requires depth calculation
- Parallelism within depth requires concurrent task execution

**For code generators:**

- Namespaces are available in dependency order
- Type resolution stages complete before code generation
- Resolved versions and errors are in namespace context
- All type references are validated

**For tooling:**

- Namespace compilation is deterministic
- Parallel compilation improves performance on multi-core systems
- Dependency graph reveals namespace relationships
- Type resolution stages can be inspected for debugging

## References

- [RFC-0010](../rfc/RFC-0010.md) - Namespace system design rationale
- [TSY-0010](../tsy/TSY-0010.md) - Namespace type system rules
- [SPEC-0003](../spec/SPEC-0003.md) - Anonymous struct compilation (Stage 1)
- [SPEC-0007](../spec/SPEC-0007.md) - Union compilation (Stages 2, 4, 5)
- [SPEC-0006](../spec/SPEC-0006.md) - Type alias compilation (Stage 3)
- [SPEC-0009](../spec/SPEC-0009.md) - Operation compilation (Stage 7)
