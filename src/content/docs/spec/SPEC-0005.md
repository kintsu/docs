---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 5
status: draft
title: Error Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0005: Error Compilation

## Overview

This SPEC documents the compiler's deterministic behavior for parsing, validating, and registering error types. It specifies the variant parsing algorithm (distinguishing struct, tuple, and unit forms), anonymous struct extraction for struct variants, type reference validation for tuple variants, error-operation association resolution via metadata attributes, and registration into the type registry. This SPEC is normative for implementers who must reproduce the compiler's error handling.

## Motivation

Code generators and downstream tooling rely on consistent error variant representations and operation associations. This SPEC records the precise parsing, extraction, and validation algorithms so implementations produce identical outputs for the same source schemas. The variant parsing logic (struct vs tuple detection) and extraction naming strategy ensure generated types are stable and predictable.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

The following diagram illustrates the error compilation pipeline from parsing through variant processing, validation, and registration:

![Error Resolution Flow](../../../../diagrams/error_resolution.png)

### Variant parsing and discrimination

The parser determines variant type by examining the token immediately following the variant name:

- If the next token is `{` (left brace), parse as struct variant (`Variant::LocalStruct` with inline `AnonymousStruct`)
- If the next token is `(` (left paren), parse as tuple variant (`Variant::Tuple` with parenthesized `Type`)
- Otherwise, parse as unit variant (no payload)

> [!IMPORTANT]
> The parser uses lookahead (peek) to distinguish struct and tuple variants without backtracking. This ensures deterministic parsing with no ambiguity.

### Struct variant extraction

For struct variants with inline field lists, the compiler extracts the anonymous struct during resolution Phase 1 (anonymous-struct extraction).

The extraction process:

- Generate a struct name by concatenating the error name and variant name in PascalCase
- Synthesize a `StructDef` with the generated name and fields from the inline struct
- Register the generated struct in the namespace's children map
- Transform the struct variant into a tuple variant referencing the generated struct

**Example:** Error `NetworkError`, variant `Timeout { endpoint: str, duration_ms: i64 }` â†’ generated struct `NetworkErrorTimeout`, transformed variant `Timeout(NetworkErrorTimeout)`.

### Tuple variant type resolution

For tuple variants with type references, the compiler validates that the referenced type exists in the type registry during resolution.

> [!WARNING]
> If the referenced type is not found, the compiler emits a diagnostic error referencing the error name, variant name, and missing type. Compilation fails.

### Variant name uniqueness validation

During parsing, the compiler tracks variant names within the error and rejects duplicate names with a diagnostic error.

### Error-operation association resolution

The compiler resolves error-operation associations during metadata resolution:

1. Scan all operations for result types (return type with `!` suffix)
2. Check for operation-level `#[err(...)]` attribute
3. If absent, fall back to namespace-level `#![err(...)]` attribute
4. Validate that the error type exists in the type registry
5. Store the error association in operation metadata

> [!WARNING]
> Operations with result types must have an associated error type (via operation-level or namespace-level attributes). Missing associations produce compile errors.

### Registration into type registry

After parsing and variant extraction, error definitions are registered into the type registry as first-class types.

- Errors are added to the namespace's children map with the error name as the key
- The compiler validates that error names are unique within the namespace (no duplicate type names)

## Acceptance criteria

- [ ] The compiler must parse three variant forms (struct/tuple/unit) using lookahead to distinguish struct and tuple variants.
- [ ] Struct variants must be extracted to named structs using ErrorName + VariantName naming.
- [ ] Tuple variant type references must be validated; missing types must produce compile errors.
- [ ] The compiler must reject duplicate variant names within the same error.
- [ ] Error-operation associations must be resolved from `#[err(...)]` (operation-level) or `#![err(...)]` (namespace-level) attributes.
- [ ] Operations with result types must have associated error types; missing associations must fail compilation.
- [ ] Errors must be registered into the type registry and validate name uniqueness within the namespace.

## Design Principles

- Determinism: variant parsing uses lookahead without backtracking; extraction and naming are reproducible
- Phase separation: struct variant extraction runs in Phase 1 (anonymous-struct extraction), before type registration
- Validation: type references, variant names, and error-operation associations are validated at compile time

## Implications

- Schema authors must ensure tuple variant types exist before referencing them in errors.
- Extracted struct names (ErrorName + VariantName) must be documented and surfaced in diagnostics.
- Operations with result types require explicit error associations; namespace-level defaults simplify common cases.

## References

- [RFC-0005: Error Type Design](/rfc/rfc-0005)
- [TSY-0005: Error Types](/tsy/tsy-0005)
- [SPEC-0003: Anonymous Struct Compilation](./SPEC-0003)
