---
author: joshua-auchincloss
components:
  - compiler
created: 2025-10-31
kind: SPEC
number: 15
status: draft
title: Type Registry
updates:
  - author: joshua-auchincloss
    date: 2025-10-31
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0015: Type Registry

## Overview

This specification defines the deterministic rules for type registration and resolution in the global Type Registry. It prescribes exact algorithms for qualified name construction, candidate generation, registry lookup, duplicate detection, and thread-safe access. The specification ensures all compiler implementations register and resolve types identically.

### Type Registry Structure

![Type Registry Structure](../../../../diagrams/type_registry_structure.png)

_Figure 1: Global Type Registry structure. The registry maintains a thread-safe HashMap mapping qualified names (package::namespace::Type) to ResolvedTypes. Each entry stores the type kind (Struct, Enum, etc.) and source location._

### Type Lookup Flow

![Type Lookup Flow](../../../../diagrams/type_lookup_flow.png)

_Figure 2: Type resolution algorithm. Phase 1 generates candidates from imports and local context. Phase 2 probes registry for each candidate in order, returning first match or error if none found._

## Motivation

Compilers must implement type registry operations consistently to ensure:

- **Deterministic Resolution**: Same type reference resolves to same definition across implementations
- **Correct Candidate Generation**: All possible qualified names explored in correct order
- **Duplicate Detection**: Conflicting type definitions detected immediately
- **Thread Safety**: Concurrent access during parallel compilation is safe

This specification provides the normative implementation guide for the Type Registry.

## Rules

### Rule 1: Qualified Name Construction

**Requirement**: The compiler MUST construct qualified names by concatenating package, namespace path, and type name.

**Implementation** (from `parser/src/ctx/paths.rs` via `NamedItemContext`):

```rust
pub struct NamedItemContext {
    package: String,
    namespace: Vec<String>,  // Hierarchical namespace path
    name: String,
}

impl NamedItemContext {
    pub fn display(&self) -> String {
        let mut parts = vec![self.package.clone()];
        parts.extend(self.namespace.clone());
        parts.push(self.name.clone());
        parts.join("::")
    }
}
```

**Algorithm**:

1. **Package**: Root package name (e.g., `"shapes"`)
2. **Namespace Path**: Hierarchical namespace segments (e.g., `["geometry", "primitives"]`)
3. **Name**: Type name (e.g., `"Point"`)
4. **Qualified Name**: Join with `"::"` separator → `"shapes::geometry::primitives::Point"`

**Example**:

```rust
let context = NamedItemContext {
    package: "shapes".into(),
    namespace: vec!["geometry".into(), "primitives".into()],
    name: "Point".into(),
};

assert_eq!(context.display(), "shapes::geometry::primitives::Point");
```

### Rule 2: Type Registration

**Requirement**: The compiler MUST register types with their qualified names and detect duplicates.

**Implementation** (from `parser/src/ctx/registry.rs:register`):

```rust
pub fn register(
    &self,
    context: &RefContext,
    name: &IdentToken,
    kind: Definition,
    span: Span,
    source: PathBuf,
) -> Result<()> {
    self.with_lock_mut(|inner| {
        let path = context.item(name.clone());  // Construct qualified name

        if inner.contains_key(&path) {
            return Err(Error::DuplicateType {
                name: path.display(),
            }.with_span(span));
        }

        inner.insert(
            path.clone(),
            ResolvedType {
                kind,
                qualified_path: path,
            }.with_source_and_span(source, span),
        );

        Ok(())
    })?
}
```

**Algorithm**:

1. **Construct Qualified Name**: Use `context.item(name)` to build `NamedItemContext`
2. **Acquire Lock**: Get mutable access to internal `HashMap`
3. **Check Duplicate**: If key exists in map, return `Error::DuplicateType` with qualified name
4. **Insert Entry**: Store `qualified_name → ResolvedType` mapping with source location
5. **Release Lock**: Implicit on scope exit

**Duplicate Detection**:

```rust
// First registration: OK
registry.register(&ctx, "Point", /* ... */)?;

// Second registration: ERROR
registry.register(&ctx, "Point", /* ... */)?;
// Returns: Error::DuplicateType { name: "shapes::geometry::Point" }
```

**Error Message Format**:

```text
Duplicate type definition: shapes::geometry::Point
```

### Rule 3: Candidate Generation for Simple Identifiers

**Requirement**: For simple identifier references, the compiler MUST generate candidates from local context and imported items.

**Implementation** (from `parser/src/ctx/graph/extract.rs:generate_candidates`):

```rust
pub fn generate_candidates(
    reference: &PathOrIdent,
    context: &RefContext,
    ns: &NamespaceCtx,
) -> Vec<NamedItemContext> {
    match reference {
        PathOrIdent::Ident(name) => {
            let true_local = context.item(name.clone());

            let mut candidates = ns
                .imports
                .iter()
                .filter_map(|it| {
                    match &it.value {
                        RefOrItemContext::Item(it) => {
                            if &it.name == name {
                                Some(it.clone())
                            } else {
                                None
                            }
                        }
                        RefOrItemContext::Ref(_) => None,
                    }
                })
                .collect::<Vec<_>>();

            candidates.push(true_local);
            candidates
        }
        // ... PathOrIdent::Path case ...
    }
}
```

**Algorithm for Simple Identifier** (`Point`):

1. **Local Candidate**: Construct `context.item(name)` → `current_package::current_namespace::Point`
2. **Imported Item Candidates**: For each import in `ns.imports`:
   - If import is `Item(qualified_name)` and name matches:
     - Add `qualified_name` to candidates
   - If import is `Ref(_)`:
     - Skip (namespace imports handled separately)
3. **Append Local**: Add local candidate last to candidates list
4. **Return**: All candidates in order

**Example**:

```rust
// Context: graphics::rendering
// Imports: [Item(shapes::geometry::Point)]
// Reference: Point

let candidates = generate_candidates(
    &PathOrIdent::Ident("Point"),
    &RefContext::new("graphics", vec!["rendering"]),
    &ns_with_imports,
);

// Result: [shapes::geometry::Point, graphics::rendering::Point]
```

### Rule 4: Candidate Generation for Qualified Paths

**Requirement**: For qualified path references, the compiler MUST generate candidates from extended local context and imported namespaces.

**Implementation** (from `parser/src/ctx/graph/extract.rs:generate_candidates`):

```rust
PathOrIdent::Path(path) => {
    let mut seg = path.segments().clone();
    let Some(last) = seg.pop() else {
        return Vec::new();  // Empty path → no candidates
    };

    let true_local = context
        .extend(&seg)
        .item(IdentToken::new(last.clone()));

    let mut candidates = ns
        .imports
        .iter()
        .filter_map(|it| {
            match &it.value {
                RefOrItemContext::Item(it) => {
                    if it.name.borrow_string() == &last {
                        Some(it.clone())
                    } else {
                        None
                    }
                }
                RefOrItemContext::Ref(r) => {
                    let qual = r
                        .merge_extend(&seg)
                        .item(IdentToken::new(last.clone()));
                    Some(qual)
                }
            }
        })
        .collect::<Vec<_>>();

    candidates.push(true_local);
    candidates
}
```

**Algorithm for Qualified Path** (`geometry::Point`):

1. **Parse Segments**: Split path into namespace segments `[geometry]` and name `Point`
2. **Local Candidate**: Extend context with segments, construct item:
   - `context.extend([geometry]).item(Point)` → `current_pkg::current_ns::geometry::Point`
3. **Imported Item Candidates**: For imports of type `Item(qualified)`:
   - If name matches `Point`, add `qualified`
4. **Imported Namespace Candidates**: For imports of type `Ref(namespace)`:
   - Merge namespace with segments: `namespace.merge_extend([geometry]).item(Point)`
   - Example: `Ref(shapes)` + `[geometry]` → `shapes::geometry::Point`
5. **Append Local**: Add local candidate last
6. **Return**: All candidates in order

**Example**:

```rust
// Context: graphics::rendering
// Imports: [Ref(shapes)]
// Reference: geometry::Point

let candidates = generate_candidates(
    &PathOrIdent::Path("geometry::Point"),
    &RefContext::new("graphics", vec!["rendering"]),
    &ns_with_ref_import,
);

// Result: [shapes::geometry::Point, graphics::rendering::geometry::Point]
```

### Rule 5: Type Resolution

**Requirement**: The compiler MUST resolve type references by probing candidates in order until match found.

**Implementation** (from `parser/src/ctx/registry.rs:resolve`):

```rust
pub fn resolve(
    &self,
    context: &RefContext,
    reference: &PathOrIdent,
    ns: &NamespaceCtx,
) -> Option<Spanned<ResolvedType>> {
    self.with_lock(|inner| {
        let uses_candidates = TypeExtractor::generate_candidates(
            reference,
            context,
            ns,
        );

        for candidate in &uses_candidates {
            if let Some(found) = inner.get(candidate) {
                return Some(found.clone());
            }
        }

        None
    })
    .ok()
    .flatten()
}
```

**Algorithm**:

1. **Generate Candidates**: Call `generate_candidates(reference, context, ns)` → list of qualified names
2. **Acquire Lock**: Get read access to internal `HashMap`
3. **Probe Registry**: For each candidate in order:
   - Check if candidate exists in registry
   - If found, return `Some(ResolvedType)`
4. **Not Found**: If all candidates exhausted, return `None`
5. **Release Lock**: Implicit on scope exit

**First-Match Semantics**: Resolution returns first matching candidate. Order matters!

**Example**:

```rust
// Candidates: [shapes::geometry::Point, graphics::rendering::Point]
// Registry contains: shapes::geometry::Point

let resolved = registry.resolve(&context, &reference, &ns);
// Returns: Some(ResolvedType { qualified_path: shapes::geometry::Point })

// If both candidates in registry, returns first: shapes::geometry::Point
```

### Rule 6: Required Resolution

**Requirement**: The compiler MUST provide error-returning resolution for required type references.

**Implementation** (from `parser/src/ctx/registry.rs:resolve_required`):

```rust
pub fn resolve_required(
    &self,
    context: &RefContext,
    reference: &PathOrIdent,
    ns: &NamespaceCtx,
) -> Result<Spanned<ResolvedType>> {
    self.resolve(context, reference, ns)
        .ok_or_else(|| {
            let type_name = match reference {
                PathOrIdent::Ident(name) => name.borrow_string().clone(),
                PathOrIdent::Path(path) => path.display(),
            };
            Error::UndefinedType { name: type_name }
        })
}
```

**Algorithm**:

1. **Call `resolve`**: Attempt resolution
2. **Check Result**:
   - If `Some(resolved)`, return `Ok(resolved)`
   - If `None`, construct error:
     - Extract type name from reference
     - Return `Error::UndefinedType { name }`

**Error Message Format**:

```text
Undefined type: geometry::Point
```

### Rule 7: Validation Check

**Requirement**: The compiler MUST provide boolean validation for optional type checking.

**Implementation** (from `parser/src/ctx/registry.rs:is_valid`):

```rust
pub fn is_valid(
    &self,
    context: &RefContext,
    reference: &PathOrIdent,
    ns: &NamespaceCtx,
) -> bool {
    self.resolve(context, reference, ns).is_some()
}
```

**Algorithm**:

1. **Call `resolve`**: Attempt resolution
2. **Check Result**: Return `true` if `Some`, `false` if `None`

**Usage**: Validation without error generation (e.g., checking optional fields).

### Rule 8: Thread-Safe Lock Acquisition

**Requirement**: The compiler MUST use mutex for thread-safe registry access during parallel compilation.

**Implementation** (from `parser/src/ctx/registry.rs`):

```rust
fn with_lock<F, R>(&self, f: F) -> Result<R>
where
    F: FnOnce(&HashMap<NamedItemContext, Spanned<ResolvedType>>) -> R
{
    self.inner
        .lock()
        .map(|guard| f(&guard))
        .map_err(|_| Error::InternalError {
            message: "TypeRegistry lock poisoned".into(),
        })
}

fn with_lock_mut<F, R>(&self, f: F) -> Result<R>
where
    F: FnOnce(&mut HashMap<NamedItemContext, Spanned<ResolvedType>>) -> R
{
    self.inner
        .lock()
        .map(|mut guard| f(&mut guard))
        .map_err(|_| Error::InternalError {
            message: "TypeRegistry lock poisoned".into(),
        })
}
```

**Algorithm**:

1. **Acquire Lock**: Call `self.inner.lock()`
2. **Handle Poison**: If lock poisoned (thread panic), return `Error::InternalError`
3. **Execute Operation**: Call closure with guard reference
4. **Release Lock**: Automatic on guard drop

**Concurrency Semantics**:

- Multiple threads can call `resolve` concurrently (mutual exclusion via Mutex)
- Registration and resolution serialize on Mutex
- Lock held for hash table operation only (typically < 100ns)

### Rule 9: Introspection

**Requirement**: The compiler MAY provide introspection for debugging and tooling.

**Implementation** (from `parser/src/ctx/registry.rs:all_types`):

```rust
pub fn all_types(&self) -> Vec<(NamedItemContext, PathBuf, Span)> {
    self.with_lock(|inner| {
        inner
            .iter()
            .map(|(path, spanned)| {
                (path.clone(), spanned.source().clone(), spanned.span().clone())
            })
            .collect()
    })
    .unwrap_or_default()
}
```

**Algorithm**:

1. **Acquire Lock**: Get read access to registry
2. **Collect Types**: Iterate all entries, extract (qualified_name, source_file, span)
3. **Return**: Vec of all registered types

**Usage**: Debugging, IDE tooling, documentation generation.

### Rule 10: Resolution Ordering Determinism

**Requirement**: The compiler MUST ensure deterministic candidate ordering for reproducible resolution.

**Algorithm**:

1. **Candidate Generation Order**:
   - Imported items (in import declaration order)
   - Local context (always last)

2. **Registry Probe Order**:
   - Candidates probed in generation order
   - First match returned

3. **Import Order Significance**:
   - Import order matters when multiple imports provide same name
   - First import wins

**Example**:

```kintsu
use shapes::geometry::Point;  // Import 1
use graphics::Point;          // Import 2

namespace rendering {
    struct Drawable {
        pos: Point,  // Resolves to shapes::geometry::Point (first import)
    }
}
```

**Candidates**: `[shapes::geometry::Point, graphics::Point, current_pkg::rendering::Point]`

**Resolution**: First probe succeeds → `shapes::geometry::Point`

## Acceptance Criteria

- [x] SPEC-0015.AC-1: Qualified names constructed by joining package, namespace path, and name with `::`
- [x] SPEC-0015.AC-2: Registration detects duplicates by checking key existence before insert
- [x] SPEC-0015.AC-3: Simple identifier candidates include imported items and local context
- [x] SPEC-0015.AC-4: Qualified path candidates include extended local context and merged imported namespaces
- [x] SPEC-0015.AC-5: Resolution probes candidates in generation order, returns first match
- [x] SPEC-0015.AC-6: `resolve_required` returns error if no candidate matches
- [x] SPEC-0015.AC-7: `is_valid` returns boolean without error generation
- [x] SPEC-0015.AC-8: Lock acquisition handles poisoning with error return
- [x] SPEC-0015.AC-9: Introspection provides list of all registered types
- [x] SPEC-0015.AC-10: Candidate ordering is deterministic (import order + local last)

## References

- [RFC-0015](/rfc/rfc-0015) — Type Registry Design
- [RFC-0014](/rfc/rfc-0014) — Parallel Compilation Design
- [AD-0002](/ad/ad-0002) — Parallel Compilation Architecture
- [SPEC-0014](/spec/spec-0014) — Schema Compilation
