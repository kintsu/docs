---
author: joshua-auchincloss
components:
  - compiler
  - parser
created: 2025-10-30
kind: SPEC
number: 9
status: draft
title: Operation Compilation
updates:
  - author: joshua-auchincloss
    date: 2025-10-30
    description: Created specification
version_after: 0.1.0
version_before: null
---

# SPEC-0009: Operation Compilation

## Overview

This SPEC documents the compiler's deterministic behavior for parsing, validating, and registering operation definitions. It specifies operation registration, parameter type resolution, return type validation, fallibility detection (identifying `Type::Result`), error type resolution algorithm (operation-level precedence over namespace-level), PascalCase name conversion for error metadata storage, and missing error attribute handling. This SPEC is normative for implementers who must reproduce the compiler's operation handling behavior.

![Operation Flow](../../../../diagrams/operation_flow.png)

## Motivation

Code generators rely on consistent operation metadata, including error type associations and parameter/return type resolution. This SPEC records the precise algorithms for detecting fallible operations, resolving error types with correct precedence, and converting operation names to PascalCase for error metadata so implementations produce identical outputs for the same source schemas.

## Deterministic compilation rules (normative)

> [!NOTE]
> These rules are normative for implementers of the Kintsu compiler.

### Operation registration

The compiler registers operation definitions during parsing. For each operation:

1. Parse `operation` keyword
2. Parse operation name (identifier)
3. Parse parameter list in parentheses
4. Parse `->` return type separator
5. Parse return type
6. Construct `Operation` AST node
7. Register in namespace as `NamespaceChild::Operation`

**Example:**

```kintsu
operation fetch_user(id: i64) -> User!;
```

Registered as `fetch_user` in namespace children.

> [!IMPORTANT]
> Operations are registered during parsing, but parameter/return type validation and error resolution occur in later phases.

### Parameter type resolution

Before finalizing operations, the compiler validates that all parameter types resolve to valid types.

**Resolution algorithm:**

1. For each parameter in the operation:
   - Extract parameter type
   - If named type (identifier), look up in type registry
     - If resolved alias, recursively validate resolved type
     - If namespace child (struct/enum/error/oneOf), valid ✓
     - If not found, error - "type not found"
   - If builtin type, valid ✓
   - If array type, recursively validate element type
   - If optional type, recursively validate inner type
   - If oneOf type, validate all variant types (per SPEC-0008)
   - If union type, validate all union component types (per SPEC-0007)
2. If all parameter types are valid, operation is valid
3. If any parameter type is invalid, operation validation fails

**Example validation:**

```kintsu
operation process(user: User, config: UnknownType) -> bool;
```

**Error:** `type 'UnknownType' not found in parameter list`

> [!WARNING]
> Parameter type validation must occur after all type definitions are parsed but before code generation. Missing types cause compilation failure.

### Return type validation

Return types follow the same validation rules as parameters:

**Validation:**

1. Extract return type from operation
2. If named type, look up in type registry
3. If builtin type, valid ✓
4. If array type, recursively validate element type
5. If optional type, recursively validate inner type
6. If result type (`Type::Result`), recursively validate inner success type
7. If oneOf type, validate all variant types
8. If union type, validate all union component types

**Example validation:**

```kintsu
operation get_data() -> CustomData;  // CustomData must exist
```

> [!NOTE]
> Return type validation uses the same type resolution logic as parameter validation.

### Fallibility detection (Type::Result)

The compiler identifies fallible operations by checking if the return type is `Type::Result`:

**Detection algorithm:**

1. Extract return type from operation
2. If return type is `Type::Result { .. }`, operation is fallible
3. If return type is `Type::Paren { ty, .. }`, recursively check inner type
4. Otherwise, operation is infallible

**Rust implementation reference:**

```rust
fn is_fallible_operation(return_type: &Type) -> bool {
    match return_type {
        Type::Result { .. } => true,
        Type::Paren { ty, .. } => is_fallible_operation(&ty.value),
        _ => false,
    }
}
```

**Example:**

```kintsu
operation fetch() -> User!;  // Type::Result -> fallible
operation calculate() -> i32;  // Not Type::Result -> infallible
```

> [!IMPORTANT]
> Only operations with `Type::Result` in their return type (accounting for parentheses) are considered fallible.

### Error type resolution algorithm

For fallible operations, the compiler resolves the error type using a two-level precedence:

**Resolution steps:**

1. Check for operation-level `#[err(...)]` attribute
   - If present, use this error type (highest precedence)
2. If no operation-level attribute, check for namespace-level `#![err(...)]` attribute
   - If present, use this error type (namespace default)
3. If no operation-level or namespace-level attribute, error - "missing error type"

**Precedence example:**

```kintsu
#![err(DefaultError)]
namespace api;

error DefaultError { Unknown };
error SpecificError { NotFound };

operation task1() -> str!;  // Uses DefaultError (namespace-level)

#[err(SpecificError)]
operation task2() -> i32!;  // Uses SpecificError (operation-level override)
```

**Rust implementation reference:**

```rust
let operation_error = extract_error_from_meta(&op_def.meta);

let resolved_error = match operation_error {
    Some(err) => err,  // Operation-level (highest precedence)
    None => {
        match namespace_error.clone() {
            Some(err) => err,  // Namespace-level (fallback)
            None => {
                return Err(Error::MissingErrorType {
                    operation: item_ctx.name.clone(),
                });
            },
        }
    },
};
```

> [!IMPORTANT]
> Operation-level attributes always take precedence over namespace-level attributes.

### PascalCase name conversion for error metadata

Operation names are converted to PascalCase when storing in error metadata HashMap:

**Conversion algorithm:**

1. Extract operation name (snake_case: e.g., `fetch_user`)
2. Convert to PascalCase: `FetchUser`
3. Store in `resolution.errors` HashMap with PascalCase key

**Example:**

```kintsu
#[err(MyError)]
operation fetch_user(id: i64) -> User!;
```

**Storage:** `errors.insert("FetchUser", "MyError")`

**Rationale:** Struct, enum, and error types use PascalCase naming. Error metadata associates operations with error types, so using PascalCase for operation names maintains consistency across type references.

> [!NOTE]
> The PascalCase conversion is deterministic: `fetch_user` always becomes `FetchUser`.

### Missing error attribute handling

If a fallible operation has no error attribute at operation level and no namespace-level default, the compiler emits a compilation error:

**Error detection:**

1. Identify fallible operation (has `Type::Result`)
2. Check operation-level `#[err(...)]` attribute → not found
3. Check namespace-level `#![err(...)]` attribute → not found
4. Emit error: "Missing error type for fallible operation '{name}'"

**Example:**

```kintsu
operation process() -> i64!;  // No error attribute
```

**Compilation error:**

```text
Error: Missing error type for fallible operation 'process'
```

> [!WARNING]
> Fallible operations without error types are compile-time errors. This ensures all fallible operations have well-defined error contracts.

### Infallible operation handling

Operations without `Type::Result` are infallible and do not require error attributes:

**Handling:**

1. Detect operation is infallible (return type is not `Type::Result`)
2. Skip error type resolution
3. No error metadata is stored for the operation

**Example:**

```kintsu
operation calculate(a: i32, b: i32) -> i32;  // Infallible, no error attribute needed
```

> [!NOTE]
> Infallible operations are not included in the error metadata HashMap.

## Acceptance Criteria

- **AC-1:** Operations are registered during parsing with parameter and return type information
- **AC-2:** Parameter types are validated to ensure all types exist in the type registry
- **AC-3:** Return types are validated using the same type resolution logic as parameters
- **AC-4:** Fallible operations are detected by checking for `Type::Result` (accounting for parentheses)
- **AC-5:** Error types are resolved with operation-level precedence over namespace-level
- **AC-6:** Operation names are converted to PascalCase for error metadata storage
- **AC-7:** Missing error attributes for fallible operations cause compilation errors
- **AC-8:** Infallible operations do not require error attributes and are excluded from error metadata

## Design Principles

- **Two-level precedence**: Operation-level overrides namespace-level for error types
- **PascalCase consistency**: Convert operation names to match struct/enum/error naming
- **Explicit error types**: Fallible operations must declare error types
- **Type resolution**: Validate all parameter and return types before code generation
- **Fallibility detection**: Use `Type::Result` to identify operations that may fail

## Implications

**For implementers:**

- Operation-level error attributes take precedence over namespace-level
- PascalCase conversion for error metadata storage is deterministic
- Fallibility is determined by `Type::Result`, not by error attribute presence
- Missing error types for fallible operations are compile-time errors

**For code generators:**

- Error metadata uses PascalCase operation names
- Fallible operations have resolved error types in metadata
- Infallible operations are not in error metadata
- All parameter and return types are validated and resolved

**For tooling:**

- Operation names in error metadata are PascalCase
- Error type resolution follows operation-level → namespace-level precedence
- Type validation ensures all parameter and return types are well-formed

## References

- [RFC-0009](/rfc/rfc-0009) - Operation design rationale
- [TSY-0009](/tsy/tsy-0009) - Operation type system rules
- [SPEC-0005](/spec/spec-0005) - Error type compilation
- [RFC-0005](/rfc/rfc-0005) - Error type design
