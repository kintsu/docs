---
title: "struct"
---

Structs are named types with named fields and types. Each field has a name and a type annotation, and may be marked optional with the `?` suffix.

## Syntax

```kintsu
struct User {
    id: i64,
    name: str,
    email?: str,
    tags: str[]
};

struct Request {
    // field with builtin type
    timestamp: datetime,
    // optional field
    metadata?: str,
    // array field
    items: Item[],
    // anonymous struct (extracted during compilation)
    config: {
        timeout: i32,
        retries: i32
    }
};
```

## Resolution Behaviour

### Field Types

The compiler validates all field types during compilation. Each field type must resolve to:

- A builtin primitive type (`i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `usize`, `f16`, `f32`, `f64`, `bool`, `str`, `binary`, `base64`, `datetime`, `complex`, `null`, `never`)
- A named type in the current namespace or imported namespace
- An array of a valid type
- A union of valid types
- A oneof of valid types
- An anonymous struct (automatically extracted and named)

### Anonymous Struct Extraction

Anonymous struct definitions in fields are automatically extracted into named struct types during compilation. The generated name is derived from the context path.

**Before resolution:**

```kintsu
struct Document {
    metadata: {
        created: datetime,
        author: str
    }
};
```

**After resolution:**

```kintsu
struct DocumentMetadata {
    created: datetime,
    author: str
};

struct Document {
    metadata: DocumentMetadata
};
```

The generated struct `DocumentMetadata` is placed in the same namespace as `Document`.

### Nested Anonymous Structs

Deeply nested anonymous structs are extracted recursively, with names built from the full context path:

```kintsu
struct Request {
    body: {
        data: {
            items: {
                id: i64,
                value: str
            }[]
        }
    }
};
```

Generates:

- `RequestBody` (from `Request.body`)
- `RequestBodyData` (from `Request.body.data`)
- `RequestBodyDataItems` (from `Request.body.data.items`)

Names are generated by joining context segments in PascalCase. The extraction happens depth-first, so nested structs are named before their parents reference them.

### Optional Fields

Fields marked with `?` are optional and may be omitted. Optional fields allow recursive references:

```kintsu
struct Node {
    value: i32,
    next?: Node
};
```

This is valid because the optional field provides a terminating path for recursion (the field can be omitted).

### Recursive Validation

Direct non-optional recursive references are rejected:

```kintsu
// INVALID: no termination path
struct Invalid {
    self: Invalid
};
```

Valid recursive patterns include:

- Optional fields: `field?: SameType`
- Array fields: `field: SameType[]` (empty array terminates)
- Indirect recursion through other types

### Dependency Ordering

During compilation, structs are registered in dependency order. If struct `A` references struct `B`, then `B` must be compiled before `A`. The compiler builds a dependency graph and uses topological sorting to determine the correct registration order.

Circular dependencies are detected and allowed only if the cycle includes a terminating edge (optional or array field).

## Validation Rules

The compiler enforces:

- All field names must be unique within the struct
- All field types must resolve to valid types
- Recursive references must include a terminating path
- Field types cannot create non-terminating dependency cycles
